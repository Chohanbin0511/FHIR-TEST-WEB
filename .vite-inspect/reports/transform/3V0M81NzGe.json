{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/mime-types/index.js","transforms":[{"name":"vite:load-fallback","result":"/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","start":1667202981847,"end":1667202982049},{"name":"commonjs","result":"/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as mimeTypes } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/mime-types/index.js?commonjs-exports\"\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/mime-db/index.js?commonjs-wrapped\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\n\nvar hasRequiredMimeTypes;\n\nfunction requireMimeTypes () {\n\tif (hasRequiredMimeTypes) return mimeTypes;\n\thasRequiredMimeTypes = 1;\n\t(function (exports) {\n\t\t'use strict'\n\n\t\t/**\n\t\t * Module dependencies.\n\t\t * @private\n\t\t */\n\n\t\tvar db = require$$0()\n\t\tvar extname = require$$1.extname\n\n\t\t/**\n\t\t * Module variables.\n\t\t * @private\n\t\t */\n\n\t\tvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\n\t\tvar TEXT_TYPE_REGEXP = /^text\\//i\n\n\t\t/**\n\t\t * Module exports.\n\t\t * @public\n\t\t */\n\n\t\texports.charset = charset\n\t\texports.charsets = { lookup: charset }\n\t\texports.contentType = contentType\n\t\texports.extension = extension\n\t\texports.extensions = Object.create(null)\n\t\texports.lookup = lookup\n\t\texports.types = Object.create(null)\n\n\t\t// Populate the extensions/types maps\n\t\tpopulateMaps(exports.extensions, exports.types)\n\n\t\t/**\n\t\t * Get the default charset for a MIME type.\n\t\t *\n\t\t * @param {string} type\n\t\t * @return {boolean|string}\n\t\t */\n\n\t\tfunction charset (type) {\n\t\t  if (!type || typeof type !== 'string') {\n\t\t    return false\n\t\t  }\n\n\t\t  // TODO: use media-typer\n\t\t  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\t\t  var mime = match && db[match[1].toLowerCase()]\n\n\t\t  if (mime && mime.charset) {\n\t\t    return mime.charset\n\t\t  }\n\n\t\t  // default text/* to utf-8\n\t\t  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n\t\t    return 'UTF-8'\n\t\t  }\n\n\t\t  return false\n\t\t}\n\n\t\t/**\n\t\t * Create a full Content-Type header given a MIME type or extension.\n\t\t *\n\t\t * @param {string} str\n\t\t * @return {boolean|string}\n\t\t */\n\n\t\tfunction contentType (str) {\n\t\t  // TODO: should this even be in this module?\n\t\t  if (!str || typeof str !== 'string') {\n\t\t    return false\n\t\t  }\n\n\t\t  var mime = str.indexOf('/') === -1\n\t\t    ? exports.lookup(str)\n\t\t    : str\n\n\t\t  if (!mime) {\n\t\t    return false\n\t\t  }\n\n\t\t  // TODO: use content-type or other module\n\t\t  if (mime.indexOf('charset') === -1) {\n\t\t    var charset = exports.charset(mime)\n\t\t    if (charset) mime += '; charset=' + charset.toLowerCase()\n\t\t  }\n\n\t\t  return mime\n\t\t}\n\n\t\t/**\n\t\t * Get the default extension for a MIME type.\n\t\t *\n\t\t * @param {string} type\n\t\t * @return {boolean|string}\n\t\t */\n\n\t\tfunction extension (type) {\n\t\t  if (!type || typeof type !== 'string') {\n\t\t    return false\n\t\t  }\n\n\t\t  // TODO: use media-typer\n\t\t  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n\t\t  // get extensions\n\t\t  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n\t\t  if (!exts || !exts.length) {\n\t\t    return false\n\t\t  }\n\n\t\t  return exts[0]\n\t\t}\n\n\t\t/**\n\t\t * Lookup the MIME type for a file path/extension.\n\t\t *\n\t\t * @param {string} path\n\t\t * @return {boolean|string}\n\t\t */\n\n\t\tfunction lookup (path) {\n\t\t  if (!path || typeof path !== 'string') {\n\t\t    return false\n\t\t  }\n\n\t\t  // get the extension (\"ext\" or \".ext\" or full path)\n\t\t  var extension = extname('x.' + path)\n\t\t    .toLowerCase()\n\t\t    .substr(1)\n\n\t\t  if (!extension) {\n\t\t    return false\n\t\t  }\n\n\t\t  return exports.types[extension] || false\n\t\t}\n\n\t\t/**\n\t\t * Populate the extensions and types maps.\n\t\t * @private\n\t\t */\n\n\t\tfunction populateMaps (extensions, types) {\n\t\t  // source preference (least -> most)\n\t\t  var preference = ['nginx', 'apache', undefined, 'iana']\n\n\t\t  Object.keys(db).forEach(function forEachMimeType (type) {\n\t\t    var mime = db[type]\n\t\t    var exts = mime.extensions\n\n\t\t    if (!exts || !exts.length) {\n\t\t      return\n\t\t    }\n\n\t\t    // mime -> extensions\n\t\t    extensions[type] = exts\n\n\t\t    // extension -> mime\n\t\t    for (var i = 0; i < exts.length; i++) {\n\t\t      var extension = exts[i]\n\n\t\t      if (types[extension]) {\n\t\t        var from = preference.indexOf(db[types[extension]].source)\n\t\t        var to = preference.indexOf(mime.source)\n\n\t\t        if (types[extension] !== 'application/octet-stream' &&\n\t\t          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n\t\t          // skip the remapping\n\t\t          continue\n\t\t        }\n\t\t      }\n\n\t\t      // set the extension -> mime\n\t\t      types[extension] = type\n\t\t    }\n\t\t  })\n\t\t}\n} (mimeTypes));\n\treturn mimeTypes;\n}\n\nexport { requireMimeTypes as __require };","start":1667202982050,"end":1667202983311,"order":"normal"}]}
