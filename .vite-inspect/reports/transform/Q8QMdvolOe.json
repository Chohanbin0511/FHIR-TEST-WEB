{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/oauth-sign/index.js","transforms":[{"name":"vite:load-fallback","result":"var crypto = require('crypto')\n\nfunction sha (key, body, algorithm) {\n  return crypto.createHmac(algorithm, key).update(body).digest('base64')\n}\n\nfunction rsa (key, body) {\n  return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64')\n}\n\nfunction rfc3986 (str) {\n  return encodeURIComponent(str)\n    .replace(/!/g,'%21')\n    .replace(/\\*/g,'%2A')\n    .replace(/\\(/g,'%28')\n    .replace(/\\)/g,'%29')\n    .replace(/'/g,'%27')\n}\n\n// Maps object to bi-dimensional array\n// Converts { foo: 'A', bar: [ 'b', 'B' ]} to\n// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]\nfunction map (obj) {\n  var key, val, arr = []\n  for (key in obj) {\n    val = obj[key]\n    if (Array.isArray(val))\n      for (var i = 0; i < val.length; i++)\n        arr.push([key, val[i]])\n    else if (typeof val === 'object')\n      for (var prop in val)\n        arr.push([key + '[' + prop + ']', val[prop]])\n    else\n      arr.push([key, val])\n  }\n  return arr\n}\n\n// Compare function for sort\nfunction compare (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\nfunction generateBase (httpMethod, base_uri, params) {\n  // adapted from https://dev.twitter.com/docs/auth/oauth and \n  // https://dev.twitter.com/docs/auth/creating-signature\n\n  // Parameter normalization\n  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n  var normalized = map(params)\n  // 1.  First, the name and value of each parameter are encoded\n  .map(function (p) {\n    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]\n  })\n  // 2.  The parameters are sorted by name, using ascending byte value\n  //     ordering.  If two or more parameters share the same name, they\n  //     are sorted by their value.\n  .sort(function (a, b) {\n    return compare(a[0], b[0]) || compare(a[1], b[1])\n  })\n  // 3.  The name of each parameter is concatenated to its corresponding\n  //     value using an \"=\" character (ASCII code 61) as a separator, even\n  //     if the value is empty.\n  .map(function (p) { return p.join('=') })\n   // 4.  The sorted name/value pairs are concatenated together into a\n   //     single string by using an \"&\" character (ASCII code 38) as\n   //     separator.\n  .join('&')\n\n  var base = [\n    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),\n    rfc3986(base_uri),\n    rfc3986(normalized)\n  ].join('&')\n\n  return base\n}\n\nfunction hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params)\n  var key = [\n    consumer_secret || '',\n    token_secret || ''\n  ].map(rfc3986).join('&')\n\n  return sha(key, base, 'sha1')\n}\n\nfunction hmacsign256 (httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params)\n  var key = [\n    consumer_secret || '',\n    token_secret || ''\n  ].map(rfc3986).join('&')\n\n  return sha(key, base, 'sha256')\n}\n\nfunction rsasign (httpMethod, base_uri, params, private_key, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params)\n  var key = private_key || ''\n\n  return rsa(key, base)\n}\n\nfunction plaintext (consumer_secret, token_secret) {\n  var key = [\n    consumer_secret || '',\n    token_secret || ''\n  ].map(rfc3986).join('&')\n\n  return key\n}\n\nfunction sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var method\n  var skipArgs = 1\n\n  switch (signMethod) {\n    case 'RSA-SHA1':\n      method = rsasign\n      break\n    case 'HMAC-SHA1':\n      method = hmacsign\n      break\n    case 'HMAC-SHA256':\n      method = hmacsign256\n      break\n    case 'PLAINTEXT':\n      method = plaintext\n      skipArgs = 4\n      break\n    default:\n     throw new Error('Signature method not supported: ' + signMethod)\n  }\n\n  return method.apply(null, [].slice.call(arguments, skipArgs))\n}\n\nexports.hmacsign = hmacsign\nexports.hmacsign256 = hmacsign256\nexports.rsasign = rsasign\nexports.plaintext = plaintext\nexports.sign = sign\nexports.rfc3986 = rfc3986\nexports.generateBase = generateBase","start":1667202982436,"end":1667202982595},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as oauthSign } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/oauth-sign/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\n\nvar hasRequiredOauthSign;\n\nfunction requireOauthSign () {\n\tif (hasRequiredOauthSign) return oauthSign;\n\thasRequiredOauthSign = 1;\n\tvar crypto = require$$0\n\n\tfunction sha (key, body, algorithm) {\n\t  return crypto.createHmac(algorithm, key).update(body).digest('base64')\n\t}\n\n\tfunction rsa (key, body) {\n\t  return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64')\n\t}\n\n\tfunction rfc3986 (str) {\n\t  return encodeURIComponent(str)\n\t    .replace(/!/g,'%21')\n\t    .replace(/\\*/g,'%2A')\n\t    .replace(/\\(/g,'%28')\n\t    .replace(/\\)/g,'%29')\n\t    .replace(/'/g,'%27')\n\t}\n\n\t// Maps object to bi-dimensional array\n\t// Converts { foo: 'A', bar: [ 'b', 'B' ]} to\n\t// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]\n\tfunction map (obj) {\n\t  var key, val, arr = []\n\t  for (key in obj) {\n\t    val = obj[key]\n\t    if (Array.isArray(val))\n\t      for (var i = 0; i < val.length; i++)\n\t        arr.push([key, val[i]])\n\t    else if (typeof val === 'object')\n\t      for (var prop in val)\n\t        arr.push([key + '[' + prop + ']', val[prop]])\n\t    else\n\t      arr.push([key, val])\n\t  }\n\t  return arr\n\t}\n\n\t// Compare function for sort\n\tfunction compare (a, b) {\n\t  return a > b ? 1 : a < b ? -1 : 0\n\t}\n\n\tfunction generateBase (httpMethod, base_uri, params) {\n\t  // adapted from https://dev.twitter.com/docs/auth/oauth and \n\t  // https://dev.twitter.com/docs/auth/creating-signature\n\n\t  // Parameter normalization\n\t  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n\t  var normalized = map(params)\n\t  // 1.  First, the name and value of each parameter are encoded\n\t  .map(function (p) {\n\t    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]\n\t  })\n\t  // 2.  The parameters are sorted by name, using ascending byte value\n\t  //     ordering.  If two or more parameters share the same name, they\n\t  //     are sorted by their value.\n\t  .sort(function (a, b) {\n\t    return compare(a[0], b[0]) || compare(a[1], b[1])\n\t  })\n\t  // 3.  The name of each parameter is concatenated to its corresponding\n\t  //     value using an \"=\" character (ASCII code 61) as a separator, even\n\t  //     if the value is empty.\n\t  .map(function (p) { return p.join('=') })\n\t   // 4.  The sorted name/value pairs are concatenated together into a\n\t   //     single string by using an \"&\" character (ASCII code 38) as\n\t   //     separator.\n\t  .join('&')\n\n\t  var base = [\n\t    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),\n\t    rfc3986(base_uri),\n\t    rfc3986(normalized)\n\t  ].join('&')\n\n\t  return base\n\t}\n\n\tfunction hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {\n\t  var base = generateBase(httpMethod, base_uri, params)\n\t  var key = [\n\t    consumer_secret || '',\n\t    token_secret || ''\n\t  ].map(rfc3986).join('&')\n\n\t  return sha(key, base, 'sha1')\n\t}\n\n\tfunction hmacsign256 (httpMethod, base_uri, params, consumer_secret, token_secret) {\n\t  var base = generateBase(httpMethod, base_uri, params)\n\t  var key = [\n\t    consumer_secret || '',\n\t    token_secret || ''\n\t  ].map(rfc3986).join('&')\n\n\t  return sha(key, base, 'sha256')\n\t}\n\n\tfunction rsasign (httpMethod, base_uri, params, private_key, token_secret) {\n\t  var base = generateBase(httpMethod, base_uri, params)\n\t  var key = private_key || ''\n\n\t  return rsa(key, base)\n\t}\n\n\tfunction plaintext (consumer_secret, token_secret) {\n\t  var key = [\n\t    consumer_secret || '',\n\t    token_secret || ''\n\t  ].map(rfc3986).join('&')\n\n\t  return key\n\t}\n\n\tfunction sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {\n\t  var method\n\t  var skipArgs = 1\n\n\t  switch (signMethod) {\n\t    case 'RSA-SHA1':\n\t      method = rsasign\n\t      break\n\t    case 'HMAC-SHA1':\n\t      method = hmacsign\n\t      break\n\t    case 'HMAC-SHA256':\n\t      method = hmacsign256\n\t      break\n\t    case 'PLAINTEXT':\n\t      method = plaintext\n\t      skipArgs = 4\n\t      break\n\t    default:\n\t     throw new Error('Signature method not supported: ' + signMethod)\n\t  }\n\n\t  return method.apply(null, [].slice.call(arguments, skipArgs))\n\t}\n\n\toauthSign.hmacsign = hmacsign\n\toauthSign.hmacsign256 = hmacsign256\n\toauthSign.rsasign = rsasign\n\toauthSign.plaintext = plaintext\n\toauthSign.sign = sign\n\toauthSign.rfc3986 = rfc3986\n\toauthSign.generateBase = generateBase\n\treturn oauthSign;\n}\n\nexport { requireOauthSign as __require };","start":1667202982595,"end":1667202982599,"order":"normal"}]}
