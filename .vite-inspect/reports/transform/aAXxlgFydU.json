{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/http-signature/lib/parser.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\nvar utils = require('./utils');\n\n\n\n///--- Globals\n\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\n\nvar State = {\n  New: 0,\n  Params: 1\n};\n\nvar ParamsState = {\n  Name: 0,\n  Quote: 1,\n  Value: 2,\n  Comma: 3\n};\n\n\n///--- Specific Errors\n\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\nfunction StrictParsingError(message) {\n  HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalFinite(options.clockSkew, 'options.clockSkew');\n\n    var authzHeaderName = options.authorizationHeaderName || 'authorization';\n\n    if (!request.headers[authzHeaderName]) {\n      throw new MissingHeaderError('no ' + authzHeaderName + ' header ' +\n                                   'present in the request');\n    }\n\n    options.clockSkew = options.clockSkew || 300;\n\n\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n\n    var parsed = {\n      scheme: '',\n      params: {},\n      signingString: ''\n    };\n\n    var authz = request.headers[authzHeaderName];\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n\n      case State.New:\n        if (c !== ' ') parsed.scheme += c;\n        else state = State.Params;\n        break;\n\n      case State.Params:\n        switch (Number(substate)) {\n\n        case ParamsState.Name:\n          var code = c.charCodeAt(0);\n          // restricted name of A-Z / a-z\n          if ((code >= 0x41 && code <= 0x5a) || // A-Z\n              (code >= 0x61 && code <= 0x7a)) { // a-z\n            tmpName += c;\n          } else if (c === '=') {\n            if (tmpName.length === 0)\n              throw new InvalidHeaderError('bad param format');\n            substate = ParamsState.Quote;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Quote:\n          if (c === '\"') {\n            tmpValue = '';\n            substate = ParamsState.Value;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        case ParamsState.Value:\n          if (c === '\"') {\n            parsed.params[tmpName] = tmpValue;\n            substate = ParamsState.Comma;\n          } else {\n            tmpValue += c;\n          }\n          break;\n\n        case ParamsState.Comma:\n          if (c === ',') {\n            tmpName = '';\n            substate = ParamsState.Name;\n          } else {\n            throw new InvalidHeaderError('bad param format');\n          }\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n        }\n        break;\n\n      default:\n        throw new Error('Invalid substate');\n      }\n\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature')\n      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n    if (!parsed.params.keyId)\n      throw new InvalidHeaderError('keyId was not specified');\n\n    if (!parsed.params.algorithm)\n      throw new InvalidHeaderError('algorithm was not specified');\n\n    if (!parsed.params.signature)\n      throw new InvalidHeaderError('signature was not specified');\n\n    // Check the algorithm against the official list\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    try {\n      validateAlgorithm(parsed.params.algorithm);\n    } catch (e) {\n      if (e instanceof InvalidAlgorithmError)\n        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +\n          'supported'));\n      else\n        throw (e);\n    }\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n\n      if (h === 'request-line') {\n        if (!options.strict) {\n          /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */\n          parsed.signingString +=\n            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n        } else {\n          /* Strict parsing doesn't allow older draft headers. */\n          throw (new StrictParsingError('request-line is not a valid header ' +\n            'with strict parsing enabled.'));\n        }\n      } else if (h === '(request-target)') {\n        parsed.signingString +=\n          '(request-target): ' + request.method.toLowerCase() + ' ' +\n          request.url;\n      } else {\n        var value = request.headers[h];\n        if (value === undefined)\n          throw new MissingHeaderError(h + ' was not in the request');\n        parsed.signingString += h + ': ' + value;\n      }\n\n      if ((i + 1) < parsed.params.headers.length)\n        parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    if (request.headers.date || request.headers['x-date']) {\n        if (request.headers['x-date']) {\n          date = new Date(request.headers['x-date']);\n        } else {\n          date = new Date(request.headers.date);\n        }\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' +\n                                      (skew / 1000) +\n                                      's was greater than ' +\n                                      options.clockSkew + 's');\n      }\n    }\n\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)\n        throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n        throw new InvalidParamsError(parsed.params.algorithm +\n                                     ' is not a supported algorithm');\n    }\n\n    parsed.algorithm = parsed.params.algorithm.toUpperCase();\n    parsed.keyId = parsed.params.keyId;\n    return parsed;\n  }\n\n};\n","start":1667202982391,"end":1667202982526},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/http-signature/lib/utils.js?commonjs-wrapped\";\n\nvar parser;\nvar hasRequiredParser;\n\nfunction requireParser () {\n\tif (hasRequiredParser) return parser;\n\thasRequiredParser = 1;\n\t// Copyright 2012 Joyent, Inc.  All rights reserved.\n\n\tvar assert = require$$0();\n\tvar util = require$$1();\n\tvar utils = require$$2();\n\n\n\n\t///--- Globals\n\n\tvar HASH_ALGOS = utils.HASH_ALGOS;\n\tvar PK_ALGOS = utils.PK_ALGOS;\n\tvar HttpSignatureError = utils.HttpSignatureError;\n\tvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\n\tvar validateAlgorithm = utils.validateAlgorithm;\n\n\tvar State = {\n\t  New: 0,\n\t  Params: 1\n\t};\n\n\tvar ParamsState = {\n\t  Name: 0,\n\t  Quote: 1,\n\t  Value: 2,\n\t  Comma: 3\n\t};\n\n\n\t///--- Specific Errors\n\n\n\tfunction ExpiredRequestError(message) {\n\t  HttpSignatureError.call(this, message, ExpiredRequestError);\n\t}\n\tutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\n\tfunction InvalidHeaderError(message) {\n\t  HttpSignatureError.call(this, message, InvalidHeaderError);\n\t}\n\tutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\n\tfunction InvalidParamsError(message) {\n\t  HttpSignatureError.call(this, message, InvalidParamsError);\n\t}\n\tutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\n\tfunction MissingHeaderError(message) {\n\t  HttpSignatureError.call(this, message, MissingHeaderError);\n\t}\n\tutil.inherits(MissingHeaderError, HttpSignatureError);\n\n\tfunction StrictParsingError(message) {\n\t  HttpSignatureError.call(this, message, StrictParsingError);\n\t}\n\tutil.inherits(StrictParsingError, HttpSignatureError);\n\n\t///--- Exported API\n\n\tparser = {\n\n\t  /**\n\t   * Parses the 'Authorization' header out of an http.ServerRequest object.\n\t   *\n\t   * Note that this API will fully validate the Authorization header, and throw\n\t   * on any error.  It will not however check the signature, or the keyId format\n\t   * as those are specific to your environment.  You can use the options object\n\t   * to pass in extra constraints.\n\t   *\n\t   * As a response object you can expect this:\n\t   *\n\t   *     {\n\t   *       \"scheme\": \"Signature\",\n\t   *       \"params\": {\n\t   *         \"keyId\": \"foo\",\n\t   *         \"algorithm\": \"rsa-sha256\",\n\t   *         \"headers\": [\n\t   *           \"date\" or \"x-date\",\n\t   *           \"digest\"\n\t   *         ],\n\t   *         \"signature\": \"base64\"\n\t   *       },\n\t   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n\t   *     }\n\t   *\n\t   * @param {Object} request an http.ServerRequest.\n\t   * @param {Object} options an optional options object with:\n\t   *                   - clockSkew: allowed clock skew in seconds (default 300).\n\t   *                   - headers: required header names (def: date or x-date)\n\t   *                   - algorithms: algorithms to support (default: all).\n\t   *                   - strict: should enforce latest spec parsing\n\t   *                             (default: false).\n\t   * @return {Object} parsed out object (see above).\n\t   * @throws {TypeError} on invalid input.\n\t   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n\t   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n\t   * @throws {MissingHeaderError} if the params indicate a header not present,\n\t   *                              either in the request headers from the params,\n\t   *                              or not in the params from a required header\n\t   *                              in options.\n\t   * @throws {StrictParsingError} if old attributes are used in strict parsing\n\t   *                              mode.\n\t   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n\t   */\n\t  parseRequest: function parseRequest(request, options) {\n\t    assert.object(request, 'request');\n\t    assert.object(request.headers, 'request.headers');\n\t    if (options === undefined) {\n\t      options = {};\n\t    }\n\t    if (options.headers === undefined) {\n\t      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n\t    }\n\t    assert.object(options, 'options');\n\t    assert.arrayOfString(options.headers, 'options.headers');\n\t    assert.optionalFinite(options.clockSkew, 'options.clockSkew');\n\n\t    var authzHeaderName = options.authorizationHeaderName || 'authorization';\n\n\t    if (!request.headers[authzHeaderName]) {\n\t      throw new MissingHeaderError('no ' + authzHeaderName + ' header ' +\n\t                                   'present in the request');\n\t    }\n\n\t    options.clockSkew = options.clockSkew || 300;\n\n\n\t    var i = 0;\n\t    var state = State.New;\n\t    var substate = ParamsState.Name;\n\t    var tmpName = '';\n\t    var tmpValue = '';\n\n\t    var parsed = {\n\t      scheme: '',\n\t      params: {},\n\t      signingString: ''\n\t    };\n\n\t    var authz = request.headers[authzHeaderName];\n\t    for (i = 0; i < authz.length; i++) {\n\t      var c = authz.charAt(i);\n\n\t      switch (Number(state)) {\n\n\t      case State.New:\n\t        if (c !== ' ') parsed.scheme += c;\n\t        else state = State.Params;\n\t        break;\n\n\t      case State.Params:\n\t        switch (Number(substate)) {\n\n\t        case ParamsState.Name:\n\t          var code = c.charCodeAt(0);\n\t          // restricted name of A-Z / a-z\n\t          if ((code >= 0x41 && code <= 0x5a) || // A-Z\n\t              (code >= 0x61 && code <= 0x7a)) { // a-z\n\t            tmpName += c;\n\t          } else if (c === '=') {\n\t            if (tmpName.length === 0)\n\t              throw new InvalidHeaderError('bad param format');\n\t            substate = ParamsState.Quote;\n\t          } else {\n\t            throw new InvalidHeaderError('bad param format');\n\t          }\n\t          break;\n\n\t        case ParamsState.Quote:\n\t          if (c === '\"') {\n\t            tmpValue = '';\n\t            substate = ParamsState.Value;\n\t          } else {\n\t            throw new InvalidHeaderError('bad param format');\n\t          }\n\t          break;\n\n\t        case ParamsState.Value:\n\t          if (c === '\"') {\n\t            parsed.params[tmpName] = tmpValue;\n\t            substate = ParamsState.Comma;\n\t          } else {\n\t            tmpValue += c;\n\t          }\n\t          break;\n\n\t        case ParamsState.Comma:\n\t          if (c === ',') {\n\t            tmpName = '';\n\t            substate = ParamsState.Name;\n\t          } else {\n\t            throw new InvalidHeaderError('bad param format');\n\t          }\n\t          break;\n\n\t        default:\n\t          throw new Error('Invalid substate');\n\t        }\n\t        break;\n\n\t      default:\n\t        throw new Error('Invalid substate');\n\t      }\n\n\t    }\n\n\t    if (!parsed.params.headers || parsed.params.headers === '') {\n\t      if (request.headers['x-date']) {\n\t        parsed.params.headers = ['x-date'];\n\t      } else {\n\t        parsed.params.headers = ['date'];\n\t      }\n\t    } else {\n\t      parsed.params.headers = parsed.params.headers.split(' ');\n\t    }\n\n\t    // Minimally validate the parsed object\n\t    if (!parsed.scheme || parsed.scheme !== 'Signature')\n\t      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n\t    if (!parsed.params.keyId)\n\t      throw new InvalidHeaderError('keyId was not specified');\n\n\t    if (!parsed.params.algorithm)\n\t      throw new InvalidHeaderError('algorithm was not specified');\n\n\t    if (!parsed.params.signature)\n\t      throw new InvalidHeaderError('signature was not specified');\n\n\t    // Check the algorithm against the official list\n\t    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n\t    try {\n\t      validateAlgorithm(parsed.params.algorithm);\n\t    } catch (e) {\n\t      if (e instanceof InvalidAlgorithmError)\n\t        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +\n\t          'supported'));\n\t      else\n\t        throw (e);\n\t    }\n\n\t    // Build the signingString\n\t    for (i = 0; i < parsed.params.headers.length; i++) {\n\t      var h = parsed.params.headers[i].toLowerCase();\n\t      parsed.params.headers[i] = h;\n\n\t      if (h === 'request-line') {\n\t        if (!options.strict) {\n\t          /*\n\t           * We allow headers from the older spec drafts if strict parsing isn't\n\t           * specified in options.\n\t           */\n\t          parsed.signingString +=\n\t            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n\t        } else {\n\t          /* Strict parsing doesn't allow older draft headers. */\n\t          throw (new StrictParsingError('request-line is not a valid header ' +\n\t            'with strict parsing enabled.'));\n\t        }\n\t      } else if (h === '(request-target)') {\n\t        parsed.signingString +=\n\t          '(request-target): ' + request.method.toLowerCase() + ' ' +\n\t          request.url;\n\t      } else {\n\t        var value = request.headers[h];\n\t        if (value === undefined)\n\t          throw new MissingHeaderError(h + ' was not in the request');\n\t        parsed.signingString += h + ': ' + value;\n\t      }\n\n\t      if ((i + 1) < parsed.params.headers.length)\n\t        parsed.signingString += '\\n';\n\t    }\n\n\t    // Check against the constraints\n\t    var date;\n\t    if (request.headers.date || request.headers['x-date']) {\n\t        if (request.headers['x-date']) {\n\t          date = new Date(request.headers['x-date']);\n\t        } else {\n\t          date = new Date(request.headers.date);\n\t        }\n\t      var now = new Date();\n\t      var skew = Math.abs(now.getTime() - date.getTime());\n\n\t      if (skew > options.clockSkew * 1000) {\n\t        throw new ExpiredRequestError('clock skew of ' +\n\t                                      (skew / 1000) +\n\t                                      's was greater than ' +\n\t                                      options.clockSkew + 's');\n\t      }\n\t    }\n\n\t    options.headers.forEach(function (hdr) {\n\t      // Remember that we already checked any headers in the params\n\t      // were in the request, so if this passes we're good.\n\t      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)\n\t        throw new MissingHeaderError(hdr + ' was not a signed header');\n\t    });\n\n\t    if (options.algorithms) {\n\t      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n\t        throw new InvalidParamsError(parsed.params.algorithm +\n\t                                     ' is not a supported algorithm');\n\t    }\n\n\t    parsed.algorithm = parsed.params.algorithm.toUpperCase();\n\t    parsed.keyId = parsed.params.keyId;\n\t    return parsed;\n\t  }\n\n\t};\n\treturn parser;\n}\n\nexport { requireParser as __require };","start":1667202982526,"end":1667202985159,"order":"normal"}]}
