{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ssh-buffer.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2015 Joyent, Inc.\n\nmodule.exports = SSHBuffer;\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\n\nfunction SSHBuffer(opts) {\n\tassert.object(opts, 'options');\n\tif (opts.buffer !== undefined)\n\t\tassert.buffer(opts.buffer, 'options.buffer');\n\n\tthis._size = opts.buffer ? opts.buffer.length : 1024;\n\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\n\tthis._offset = 0;\n}\n\nSSHBuffer.prototype.toBuffer = function () {\n\treturn (this._buffer.slice(0, this._offset));\n};\n\nSSHBuffer.prototype.atEnd = function () {\n\treturn (this._offset >= this._buffer.length);\n};\n\nSSHBuffer.prototype.remainder = function () {\n\treturn (this._buffer.slice(this._offset));\n};\n\nSSHBuffer.prototype.skip = function (n) {\n\tthis._offset += n;\n};\n\nSSHBuffer.prototype.expand = function () {\n\tthis._size *= 2;\n\tvar buf = Buffer.alloc(this._size);\n\tthis._buffer.copy(buf, 0);\n\tthis._buffer = buf;\n};\n\nSSHBuffer.prototype.readPart = function () {\n\treturn ({data: this.readBuffer()});\n};\n\nSSHBuffer.prototype.readBuffer = function () {\n\tvar len = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\tassert.ok(this._offset + len <= this._buffer.length,\n\t    'length out of bounds at +0x' + this._offset.toString(16) +\n\t    ' (data truncated?)');\n\tvar buf = this._buffer.slice(this._offset, this._offset + len);\n\tthis._offset += len;\n\treturn (buf);\n};\n\nSSHBuffer.prototype.readString = function () {\n\treturn (this.readBuffer().toString());\n};\n\nSSHBuffer.prototype.readCString = function () {\n\tvar offset = this._offset;\n\twhile (offset < this._buffer.length &&\n\t    this._buffer[offset] !== 0x00)\n\t\toffset++;\n\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\n\tvar str = this._buffer.slice(this._offset, offset).toString();\n\tthis._offset = offset + 1;\n\treturn (str);\n};\n\nSSHBuffer.prototype.readInt = function () {\n\tvar v = this._buffer.readUInt32BE(this._offset);\n\tthis._offset += 4;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readInt64 = function () {\n\tassert.ok(this._offset + 8 < this._buffer.length,\n\t    'buffer not long enough to read Int64');\n\tvar v = this._buffer.slice(this._offset, this._offset + 8);\n\tthis._offset += 8;\n\treturn (v);\n};\n\nSSHBuffer.prototype.readChar = function () {\n\tvar v = this._buffer[this._offset++];\n\treturn (v);\n};\n\nSSHBuffer.prototype.writeBuffer = function (buf) {\n\twhile (this._offset + 4 + buf.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(buf.length, this._offset);\n\tthis._offset += 4;\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n\nSSHBuffer.prototype.writeString = function (str) {\n\tthis.writeBuffer(Buffer.from(str, 'utf8'));\n};\n\nSSHBuffer.prototype.writeCString = function (str) {\n\twhile (this._offset + 1 + str.length > this._size)\n\t\tthis.expand();\n\tthis._buffer.write(str, this._offset);\n\tthis._offset += str.length;\n\tthis._buffer[this._offset++] = 0;\n};\n\nSSHBuffer.prototype.writeInt = function (v) {\n\twhile (this._offset + 4 > this._size)\n\t\tthis.expand();\n\tthis._buffer.writeUInt32BE(v, this._offset);\n\tthis._offset += 4;\n};\n\nSSHBuffer.prototype.writeInt64 = function (v) {\n\tassert.buffer(v, 'value');\n\tif (v.length > 8) {\n\t\tvar lead = v.slice(0, v.length - 8);\n\t\tfor (var i = 0; i < lead.length; ++i) {\n\t\t\tassert.strictEqual(lead[i], 0,\n\t\t\t    'must fit in 64 bits of precision');\n\t\t}\n\t\tv = v.slice(v.length - 8, v.length);\n\t}\n\twhile (this._offset + 8 > this._size)\n\t\tthis.expand();\n\tv.copy(this._buffer, this._offset);\n\tthis._offset += 8;\n};\n\nSSHBuffer.prototype.writeChar = function (v) {\n\twhile (this._offset + 1 > this._size)\n\t\tthis.expand();\n\tthis._buffer[this._offset++] = v;\n};\n\nSSHBuffer.prototype.writePart = function (p) {\n\tthis.writeBuffer(p.data);\n};\n\nSSHBuffer.prototype.write = function (buf) {\n\twhile (this._offset + buf.length > this._size)\n\t\tthis.expand();\n\tbuf.copy(this._buffer, this._offset);\n\tthis._offset += buf.length;\n};\n","start":1667202706642,"end":1667202706858},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\n\nvar sshBuffer;\nvar hasRequiredSshBuffer;\n\nfunction requireSshBuffer () {\n\tif (hasRequiredSshBuffer) return sshBuffer;\n\thasRequiredSshBuffer = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tsshBuffer = SSHBuffer;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\n\tfunction SSHBuffer(opts) {\n\t\tassert.object(opts, 'options');\n\t\tif (opts.buffer !== undefined)\n\t\t\tassert.buffer(opts.buffer, 'options.buffer');\n\n\t\tthis._size = opts.buffer ? opts.buffer.length : 1024;\n\t\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\n\t\tthis._offset = 0;\n\t}\n\n\tSSHBuffer.prototype.toBuffer = function () {\n\t\treturn (this._buffer.slice(0, this._offset));\n\t};\n\n\tSSHBuffer.prototype.atEnd = function () {\n\t\treturn (this._offset >= this._buffer.length);\n\t};\n\n\tSSHBuffer.prototype.remainder = function () {\n\t\treturn (this._buffer.slice(this._offset));\n\t};\n\n\tSSHBuffer.prototype.skip = function (n) {\n\t\tthis._offset += n;\n\t};\n\n\tSSHBuffer.prototype.expand = function () {\n\t\tthis._size *= 2;\n\t\tvar buf = Buffer.alloc(this._size);\n\t\tthis._buffer.copy(buf, 0);\n\t\tthis._buffer = buf;\n\t};\n\n\tSSHBuffer.prototype.readPart = function () {\n\t\treturn ({data: this.readBuffer()});\n\t};\n\n\tSSHBuffer.prototype.readBuffer = function () {\n\t\tvar len = this._buffer.readUInt32BE(this._offset);\n\t\tthis._offset += 4;\n\t\tassert.ok(this._offset + len <= this._buffer.length,\n\t\t    'length out of bounds at +0x' + this._offset.toString(16) +\n\t\t    ' (data truncated?)');\n\t\tvar buf = this._buffer.slice(this._offset, this._offset + len);\n\t\tthis._offset += len;\n\t\treturn (buf);\n\t};\n\n\tSSHBuffer.prototype.readString = function () {\n\t\treturn (this.readBuffer().toString());\n\t};\n\n\tSSHBuffer.prototype.readCString = function () {\n\t\tvar offset = this._offset;\n\t\twhile (offset < this._buffer.length &&\n\t\t    this._buffer[offset] !== 0x00)\n\t\t\toffset++;\n\t\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\n\t\tvar str = this._buffer.slice(this._offset, offset).toString();\n\t\tthis._offset = offset + 1;\n\t\treturn (str);\n\t};\n\n\tSSHBuffer.prototype.readInt = function () {\n\t\tvar v = this._buffer.readUInt32BE(this._offset);\n\t\tthis._offset += 4;\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.readInt64 = function () {\n\t\tassert.ok(this._offset + 8 < this._buffer.length,\n\t\t    'buffer not long enough to read Int64');\n\t\tvar v = this._buffer.slice(this._offset, this._offset + 8);\n\t\tthis._offset += 8;\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.readChar = function () {\n\t\tvar v = this._buffer[this._offset++];\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.writeBuffer = function (buf) {\n\t\twhile (this._offset + 4 + buf.length > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.writeUInt32BE(buf.length, this._offset);\n\t\tthis._offset += 4;\n\t\tbuf.copy(this._buffer, this._offset);\n\t\tthis._offset += buf.length;\n\t};\n\n\tSSHBuffer.prototype.writeString = function (str) {\n\t\tthis.writeBuffer(Buffer.from(str, 'utf8'));\n\t};\n\n\tSSHBuffer.prototype.writeCString = function (str) {\n\t\twhile (this._offset + 1 + str.length > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.write(str, this._offset);\n\t\tthis._offset += str.length;\n\t\tthis._buffer[this._offset++] = 0;\n\t};\n\n\tSSHBuffer.prototype.writeInt = function (v) {\n\t\twhile (this._offset + 4 > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.writeUInt32BE(v, this._offset);\n\t\tthis._offset += 4;\n\t};\n\n\tSSHBuffer.prototype.writeInt64 = function (v) {\n\t\tassert.buffer(v, 'value');\n\t\tif (v.length > 8) {\n\t\t\tvar lead = v.slice(0, v.length - 8);\n\t\t\tfor (var i = 0; i < lead.length; ++i) {\n\t\t\t\tassert.strictEqual(lead[i], 0,\n\t\t\t\t    'must fit in 64 bits of precision');\n\t\t\t}\n\t\t\tv = v.slice(v.length - 8, v.length);\n\t\t}\n\t\twhile (this._offset + 8 > this._size)\n\t\t\tthis.expand();\n\t\tv.copy(this._buffer, this._offset);\n\t\tthis._offset += 8;\n\t};\n\n\tSSHBuffer.prototype.writeChar = function (v) {\n\t\twhile (this._offset + 1 > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer[this._offset++] = v;\n\t};\n\n\tSSHBuffer.prototype.writePart = function (p) {\n\t\tthis.writeBuffer(p.data);\n\t};\n\n\tSSHBuffer.prototype.write = function (buf) {\n\t\twhile (this._offset + buf.length > this._size)\n\t\t\tthis.expand();\n\t\tbuf.copy(this._buffer, this._offset);\n\t\tthis._offset += buf.length;\n\t};\n\treturn sshBuffer;\n}\n\nexport { requireSshBuffer as __require };","start":1667202706858,"end":1667202707555,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\n\nvar sshBuffer;\nvar hasRequiredSshBuffer;\n\nfunction requireSshBuffer () {\n\tif (hasRequiredSshBuffer) return sshBuffer;\n\thasRequiredSshBuffer = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tsshBuffer = SSHBuffer;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\n\tfunction SSHBuffer(opts) {\n\t\tassert.object(opts, 'options');\n\t\tif (opts.buffer !== undefined)\n\t\t\tassert.buffer(opts.buffer, 'options.buffer');\n\n\t\tthis._size = opts.buffer ? opts.buffer.length : 1024;\n\t\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\n\t\tthis._offset = 0;\n\t}\n\n\tSSHBuffer.prototype.toBuffer = function () {\n\t\treturn (this._buffer.slice(0, this._offset));\n\t};\n\n\tSSHBuffer.prototype.atEnd = function () {\n\t\treturn (this._offset >= this._buffer.length);\n\t};\n\n\tSSHBuffer.prototype.remainder = function () {\n\t\treturn (this._buffer.slice(this._offset));\n\t};\n\n\tSSHBuffer.prototype.skip = function (n) {\n\t\tthis._offset += n;\n\t};\n\n\tSSHBuffer.prototype.expand = function () {\n\t\tthis._size *= 2;\n\t\tvar buf = Buffer.alloc(this._size);\n\t\tthis._buffer.copy(buf, 0);\n\t\tthis._buffer = buf;\n\t};\n\n\tSSHBuffer.prototype.readPart = function () {\n\t\treturn ({data: this.readBuffer()});\n\t};\n\n\tSSHBuffer.prototype.readBuffer = function () {\n\t\tvar len = this._buffer.readUInt32BE(this._offset);\n\t\tthis._offset += 4;\n\t\tassert.ok(this._offset + len <= this._buffer.length,\n\t\t    'length out of bounds at +0x' + this._offset.toString(16) +\n\t\t    ' (data truncated?)');\n\t\tvar buf = this._buffer.slice(this._offset, this._offset + len);\n\t\tthis._offset += len;\n\t\treturn (buf);\n\t};\n\n\tSSHBuffer.prototype.readString = function () {\n\t\treturn (this.readBuffer().toString());\n\t};\n\n\tSSHBuffer.prototype.readCString = function () {\n\t\tvar offset = this._offset;\n\t\twhile (offset < this._buffer.length &&\n\t\t    this._buffer[offset] !== 0x00)\n\t\t\toffset++;\n\t\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\n\t\tvar str = this._buffer.slice(this._offset, offset).toString();\n\t\tthis._offset = offset + 1;\n\t\treturn (str);\n\t};\n\n\tSSHBuffer.prototype.readInt = function () {\n\t\tvar v = this._buffer.readUInt32BE(this._offset);\n\t\tthis._offset += 4;\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.readInt64 = function () {\n\t\tassert.ok(this._offset + 8 < this._buffer.length,\n\t\t    'buffer not long enough to read Int64');\n\t\tvar v = this._buffer.slice(this._offset, this._offset + 8);\n\t\tthis._offset += 8;\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.readChar = function () {\n\t\tvar v = this._buffer[this._offset++];\n\t\treturn (v);\n\t};\n\n\tSSHBuffer.prototype.writeBuffer = function (buf) {\n\t\twhile (this._offset + 4 + buf.length > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.writeUInt32BE(buf.length, this._offset);\n\t\tthis._offset += 4;\n\t\tbuf.copy(this._buffer, this._offset);\n\t\tthis._offset += buf.length;\n\t};\n\n\tSSHBuffer.prototype.writeString = function (str) {\n\t\tthis.writeBuffer(Buffer.from(str, 'utf8'));\n\t};\n\n\tSSHBuffer.prototype.writeCString = function (str) {\n\t\twhile (this._offset + 1 + str.length > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.write(str, this._offset);\n\t\tthis._offset += str.length;\n\t\tthis._buffer[this._offset++] = 0;\n\t};\n\n\tSSHBuffer.prototype.writeInt = function (v) {\n\t\twhile (this._offset + 4 > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer.writeUInt32BE(v, this._offset);\n\t\tthis._offset += 4;\n\t};\n\n\tSSHBuffer.prototype.writeInt64 = function (v) {\n\t\tassert.buffer(v, 'value');\n\t\tif (v.length > 8) {\n\t\t\tvar lead = v.slice(0, v.length - 8);\n\t\t\tfor (var i = 0; i < lead.length; ++i) {\n\t\t\t\tassert.strictEqual(lead[i], 0,\n\t\t\t\t    'must fit in 64 bits of precision');\n\t\t\t}\n\t\t\tv = v.slice(v.length - 8, v.length);\n\t\t}\n\t\twhile (this._offset + 8 > this._size)\n\t\t\tthis.expand();\n\t\tv.copy(this._buffer, this._offset);\n\t\tthis._offset += 8;\n\t};\n\n\tSSHBuffer.prototype.writeChar = function (v) {\n\t\twhile (this._offset + 1 > this._size)\n\t\t\tthis.expand();\n\t\tthis._buffer[this._offset++] = v;\n\t};\n\n\tSSHBuffer.prototype.writePart = function (p) {\n\t\tthis.writeBuffer(p.data);\n\t};\n\n\tSSHBuffer.prototype.write = function (buf) {\n\t\twhile (this._offset + buf.length > this._size)\n\t\t\tthis.expand();\n\t\tbuf.copy(this._buffer, this._offset);\n\t\tthis._offset += buf.length;\n\t};\n\treturn sshBuffer;\n}\n\nexport { requireSshBuffer as __require };","start":1667202707577,"end":1667202707594,"order":"normal"}]}
