{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs8: readPkcs8,\n\twrite: write,\n\twritePkcs8: writePkcs8,\n\tpkcs8ToBuffer: pkcs8ToBuffer,\n\n\treadECDSACurve: readECDSACurve,\n\twriteECDSACurve: writeECDSACurve\n};\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar pem = require('./pem');\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs8'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs8'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs8(alg, type, der) {\n\t/* Private keys in pkcs#8 format have a weird extra int */\n\tif (der.peek() === asn1.Ber.Integer) {\n\t\tassert.strictEqual(type, 'private',\n\t\t    'unexpected Integer at start of public key');\n\t\tder.readString(asn1.Ber.Integer, true);\n\t}\n\n\tder.readSequence();\n\tvar next = der.offset + der.length;\n\n\tvar oid = der.readOID();\n\tswitch (oid) {\n\tcase '1.2.840.113549.1.1.1':\n\t\tder._offset = next;\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8RSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8RSAPrivate(der));\n\tcase '1.2.840.10040.4.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8DSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8DSAPrivate(der));\n\tcase '1.2.840.10045.2.1':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs8ECDSAPublic(der));\n\t\telse\n\t\t\treturn (readPkcs8ECDSAPrivate(der));\n\tcase '1.3.101.112':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8EdDSAPublic(der));\n\t\t} else {\n\t\t\treturn (readPkcs8EdDSAPrivate(der));\n\t\t}\n\tcase '1.3.101.110':\n\t\tif (type === 'public') {\n\t\t\treturn (readPkcs8X25519Public(der));\n\t\t} else {\n\t\t\treturn (readPkcs8X25519Private(der));\n\t\t}\n\tdefault:\n\t\tthrow (new Error('Unknown key type OID ' + oid));\n\t}\n}\n\nfunction readPkcs8RSAPublic(der) {\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\tder.readSequence();\n\n\t// modulus\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tsource: der.originalInput,\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8RSAPrivate(der) {\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar ver = readMPInt(der, 'version');\n\tassert.equal(ver[0], 0x0, 'unknown RSA private key version');\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8DSAPublic(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\t// bit string sequence\n\tder.readSequence(asn1.Ber.BitString);\n\tder.readByte();\n\n\tvar y = readMPInt(der, 'y');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8DSAPrivate(der) {\n\tder.readSequence();\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar x = readMPInt(der, 'x');\n\n\t/* The pkcs#8 format does not include the public key */\n\tvar y = utils.calculateDSAPublic(g, p, x);\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readECDSACurve(der) {\n\tvar curveName, curveNames;\n\tvar j, c, cd;\n\n\tif (der.peek() === asn1.Ber.OID) {\n\t\tvar oid = der.readOID();\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tif (cd.pkcs8oid === oid) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.readSequence();\n\t\tvar version = der.readString(asn1.Ber.Integer, true);\n\t\tassert.strictEqual(version[0], 1, 'ECDSA key not version 1');\n\n\t\tvar curve = {};\n\n\t\t// FieldID sequence\n\t\tder.readSequence();\n\t\tvar fieldTypeOid = der.readOID();\n\t\tassert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',\n\t\t    'ECDSA key is not from a prime-field');\n\t\tvar p = curve.p = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t/*\n\t\t * p always starts with a 1 bit, so count the zeros to get its\n\t\t * real size.\n\t\t */\n\t\tcurve.size = p.length * 8 - utils.countZeros(p);\n\n\t\t// Curve sequence\n\t\tder.readSequence();\n\t\tcurve.a = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tcurve.b = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\tif (der.peek() === asn1.Ber.BitString)\n\t\t\tcurve.s = der.readString(asn1.Ber.BitString, true);\n\n\t\t// Combined Gx and Gy\n\t\tcurve.G = der.readString(asn1.Ber.OctetString, true);\n\t\tassert.strictEqual(curve.G[0], 0x4,\n\t\t    'uncompressed G is required');\n\n\t\tcurve.n = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tcurve.h = utils.mpNormalize(\n\t\t    der.readString(asn1.Ber.Integer, true));\n\t\tassert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +\n\t\t    'required');\n\n\t\tcurveNames = Object.keys(algs.curves);\n\t\tvar ks = Object.keys(curve);\n\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\tc = curveNames[j];\n\t\t\tcd = algs.curves[c];\n\t\t\tvar equal = true;\n\t\t\tfor (var i = 0; i < ks.length; ++i) {\n\t\t\t\tvar k = ks[i];\n\t\t\t\tif (cd[k] === undefined)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (typeof (cd[k]) === 'object' &&\n\t\t\t\t    cd[k].equals !== undefined) {\n\t\t\t\t\tif (!cd[k].equals(curve[k])) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (Buffer.isBuffer(cd[k])) {\n\t\t\t\t\tif (cd[k].toString('binary')\n\t\t\t\t\t    !== curve[k].toString('binary')) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cd[k] !== curve[k]) {\n\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tcurveName = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn (curveName);\n}\n\nfunction readPkcs8ECDSAPrivate(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tder.readSequence();\n\n\tvar version = readMPInt(der, 'version');\n\tassert.equal(version[0], 1, 'unknown version of ECDSA key');\n\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\tvar Q;\n\n\tif (der.peek() == 0xa0) {\n\t\tder.readSequence(0xa0);\n\t\tder._offset += der.length;\n\t}\n\tif (der.peek() == 0xa1) {\n\t\tder.readSequence(0xa1);\n\t\tQ = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\t}\n\n\tif (Q === undefined) {\n\t\tvar pub = utils.publicFromPrivateECDSA(curveName, d);\n\t\tQ = pub.part.Q.data;\n\t}\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8ECDSAPublic(der) {\n\tvar curveName = readECDSACurve(der);\n\tassert.string(curveName, 'a known elliptic curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPublic(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8X25519Public(der) {\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs8EdDSAPrivate(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A;\n\tif (der.peek() === asn1.Ber.BitString) {\n\t\tA = utils.readBitString(der);\n\t\tA = utils.zeroPadToLength(A, 32);\n\t} else {\n\t\tA = utils.calculateED25519Public(k);\n\t}\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs8X25519Private(der) {\n\tif (der.peek() === 0x00)\n\t\tder.readByte();\n\n\tder.readSequence(asn1.Ber.OctetString);\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\tk = utils.zeroPadToLength(k, 32);\n\n\tvar A = utils.calculateX25519Public(k);\n\n\tvar key = {\n\t\ttype: 'curve25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction pkcs8ToBuffer(key) {\n\tvar der = new asn1.BerWriter();\n\twritePkcs8(der, key);\n\treturn (der.buffer);\n}\n\nfunction writePkcs8(der, key) {\n\tder.startSequence();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tvar sillyInt = Buffer.from([0]);\n\t\tder.writeBuffer(sillyInt, asn1.Ber.Integer);\n\t}\n\n\tder.startSequence();\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tder.writeOID('1.2.840.113549.1.1.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8RSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8RSAPublic(key, der);\n\t\tbreak;\n\tcase 'dsa':\n\t\tder.writeOID('1.2.840.10040.4.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8DSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8DSAPublic(key, der);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tder.writeOID('1.2.840.10045.2.1');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs8ECDSAPrivate(key, der);\n\t\telse\n\t\t\twritePkcs8ECDSAPublic(key, der);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tder.writeOID('1.3.101.112');\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\tthrow (new Error('Ed25519 private keys in pkcs8 ' +\n\t\t\t    'format are not supported'));\n\t\twritePkcs8EdDSAPublic(key, der);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unsupported key type: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPrivate(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([0]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8RSAPublic(key, der) {\n\tder.writeNull();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\n\tder.startSequence();\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPrivate(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writePkcs8DSAPublic(key, der) {\n\tder.startSequence();\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.endSequence();\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.BitString);\n\tder.writeByte(0x00);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.endSequence();\n}\n\nfunction writeECDSACurve(key, der) {\n\tvar curve = algs.curves[key.curve];\n\tif (curve.pkcs8oid) {\n\t\t/* This one has a name in pkcs#8, so just write the oid */\n\t\tder.writeOID(curve.pkcs8oid);\n\n\t} else {\n\t\t// ECParameters sequence\n\t\tder.startSequence();\n\n\t\tvar version = Buffer.from([1]);\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\t// FieldID sequence\n\t\tder.startSequence();\n\t\tder.writeOID('1.2.840.10045.1.1'); // prime-field\n\t\tder.writeBuffer(curve.p, asn1.Ber.Integer);\n\t\tder.endSequence();\n\n\t\t// Curve sequence\n\t\tder.startSequence();\n\t\tvar a = curve.p;\n\t\tif (a[0] === 0x0)\n\t\t\ta = a.slice(1);\n\t\tder.writeBuffer(a, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.b, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.s, asn1.Ber.BitString);\n\t\tder.endSequence();\n\n\t\tder.writeBuffer(curve.G, asn1.Ber.OctetString);\n\t\tder.writeBuffer(curve.n, asn1.Ber.Integer);\n\t\tvar h = curve.h;\n\t\tif (!h) {\n\t\t\th = Buffer.from([1]);\n\t\t}\n\t\tder.writeBuffer(h, asn1.Ber.Integer);\n\n\t\t// ECParameters\n\t\tder.endSequence();\n\t}\n}\n\nfunction writePkcs8ECDSAPublic(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs8ECDSAPrivate(key, der) {\n\twriteECDSACurve(key, der);\n\tder.endSequence();\n\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.startSequence();\n\n\tvar version = Buffer.from([1]);\n\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n\n\tder.endSequence();\n\tder.endSequence();\n}\n\nfunction writePkcs8EdDSAPublic(key, der) {\n\tder.endSequence();\n\n\tutils.writeBitString(der, key.part.A.data);\n}\n\nfunction writePkcs8EdDSAPrivate(key, der) {\n\tder.endSequence();\n\n\tvar k = utils.mpNormalize(key.part.k.data, true);\n\tder.startSequence(asn1.Ber.OctetString);\n\tder.writeBuffer(k, asn1.Ber.OctetString);\n\tder.endSequence();\n}\n","start":1667202983827,"end":1667202983994},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\n\nvar pkcs8;\nvar hasRequiredPkcs8;\n\nfunction requirePkcs8 () {\n\tif (hasRequiredPkcs8) return pkcs8;\n\thasRequiredPkcs8 = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tpkcs8 = {\n\t\tread: read,\n\t\treadPkcs8: readPkcs8,\n\t\twrite: write,\n\t\twritePkcs8: writePkcs8,\n\t\tpkcs8ToBuffer: pkcs8ToBuffer,\n\n\t\treadECDSACurve: readECDSACurve,\n\t\twriteECDSACurve: writeECDSACurve\n\t};\n\n\tvar assert = require$$0();\n\tvar asn1 = require$$1();\n\tvar Buffer = require$$2().Buffer;\n\tvar algs = require$$3();\n\tvar utils = require$$4();\n\tvar Key = require$$5();\n\tvar PrivateKey = require$$6();\n\tvar pem = require$$7();\n\n\tfunction read(buf, options) {\n\t\treturn (pem.read(buf, options, 'pkcs8'));\n\t}\n\n\tfunction write(key, options) {\n\t\treturn (pem.write(key, options, 'pkcs8'));\n\t}\n\n\t/* Helper to read in a single mpint */\n\tfunction readMPInt(der, nm) {\n\t\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t\t    nm + ' is not an Integer');\n\t\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n\t}\n\n\tfunction readPkcs8(alg, type, der) {\n\t\t/* Private keys in pkcs#8 format have a weird extra int */\n\t\tif (der.peek() === asn1.Ber.Integer) {\n\t\t\tassert.strictEqual(type, 'private',\n\t\t\t    'unexpected Integer at start of public key');\n\t\t\tder.readString(asn1.Ber.Integer, true);\n\t\t}\n\n\t\tder.readSequence();\n\t\tvar next = der.offset + der.length;\n\n\t\tvar oid = der.readOID();\n\t\tswitch (oid) {\n\t\tcase '1.2.840.113549.1.1.1':\n\t\t\tder._offset = next;\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs8RSAPublic(der));\n\t\t\telse\n\t\t\t\treturn (readPkcs8RSAPrivate(der));\n\t\tcase '1.2.840.10040.4.1':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs8DSAPublic(der));\n\t\t\telse\n\t\t\t\treturn (readPkcs8DSAPrivate(der));\n\t\tcase '1.2.840.10045.2.1':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs8ECDSAPublic(der));\n\t\t\telse\n\t\t\t\treturn (readPkcs8ECDSAPrivate(der));\n\t\tcase '1.3.101.112':\n\t\t\tif (type === 'public') {\n\t\t\t\treturn (readPkcs8EdDSAPublic(der));\n\t\t\t} else {\n\t\t\t\treturn (readPkcs8EdDSAPrivate(der));\n\t\t\t}\n\t\tcase '1.3.101.110':\n\t\t\tif (type === 'public') {\n\t\t\t\treturn (readPkcs8X25519Public(der));\n\t\t\t} else {\n\t\t\t\treturn (readPkcs8X25519Private(der));\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown key type OID ' + oid));\n\t\t}\n\t}\n\n\tfunction readPkcs8RSAPublic(der) {\n\t\t// bit string sequence\n\t\tder.readSequence(asn1.Ber.BitString);\n\t\tder.readByte();\n\t\tder.readSequence();\n\n\t\t// modulus\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'exponent');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tsource: der.originalInput,\n\t\t\tparts: [\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'n', data: n }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs8RSAPrivate(der) {\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\n\t\tvar ver = readMPInt(der, 'version');\n\t\tassert.equal(ver[0], 0x0, 'unknown RSA private key version');\n\n\t\t// modulus then public exponent\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'public exponent');\n\t\tvar d = readMPInt(der, 'private exponent');\n\t\tvar p = readMPInt(der, 'prime1');\n\t\tvar q = readMPInt(der, 'prime2');\n\t\tvar dmodp = readMPInt(der, 'exponent1');\n\t\tvar dmodq = readMPInt(der, 'exponent2');\n\t\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'n', data: n },\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'd', data: d },\n\t\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs8DSAPublic(der) {\n\t\tder.readSequence();\n\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\n\t\t// bit string sequence\n\t\tder.readSequence(asn1.Ber.BitString);\n\t\tder.readByte();\n\n\t\tvar y = readMPInt(der, 'y');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g },\n\t\t\t\t{ name: 'y', data: y }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs8DSAPrivate(der) {\n\t\tder.readSequence();\n\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar x = readMPInt(der, 'x');\n\n\t\t/* The pkcs#8 format does not include the public key */\n\t\tvar y = utils.calculateDSAPublic(g, p, x);\n\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g },\n\t\t\t\t{ name: 'y', data: y },\n\t\t\t\t{ name: 'x', data: x }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readECDSACurve(der) {\n\t\tvar curveName, curveNames;\n\t\tvar j, c, cd;\n\n\t\tif (der.peek() === asn1.Ber.OID) {\n\t\t\tvar oid = der.readOID();\n\n\t\t\tcurveNames = Object.keys(algs.curves);\n\t\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\t\tc = curveNames[j];\n\t\t\t\tcd = algs.curves[c];\n\t\t\t\tif (cd.pkcs8oid === oid) {\n\t\t\t\t\tcurveName = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// ECParameters sequence\n\t\t\tder.readSequence();\n\t\t\tvar version = der.readString(asn1.Ber.Integer, true);\n\t\t\tassert.strictEqual(version[0], 1, 'ECDSA key not version 1');\n\n\t\t\tvar curve = {};\n\n\t\t\t// FieldID sequence\n\t\t\tder.readSequence();\n\t\t\tvar fieldTypeOid = der.readOID();\n\t\t\tassert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',\n\t\t\t    'ECDSA key is not from a prime-field');\n\t\t\tvar p = curve.p = utils.mpNormalize(\n\t\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t\t/*\n\t\t\t * p always starts with a 1 bit, so count the zeros to get its\n\t\t\t * real size.\n\t\t\t */\n\t\t\tcurve.size = p.length * 8 - utils.countZeros(p);\n\n\t\t\t// Curve sequence\n\t\t\tder.readSequence();\n\t\t\tcurve.a = utils.mpNormalize(\n\t\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\t\tcurve.b = utils.mpNormalize(\n\t\t\t    der.readString(asn1.Ber.OctetString, true));\n\t\t\tif (der.peek() === asn1.Ber.BitString)\n\t\t\t\tcurve.s = der.readString(asn1.Ber.BitString, true);\n\n\t\t\t// Combined Gx and Gy\n\t\t\tcurve.G = der.readString(asn1.Ber.OctetString, true);\n\t\t\tassert.strictEqual(curve.G[0], 0x4,\n\t\t\t    'uncompressed G is required');\n\n\t\t\tcurve.n = utils.mpNormalize(\n\t\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t\tcurve.h = utils.mpNormalize(\n\t\t\t    der.readString(asn1.Ber.Integer, true));\n\t\t\tassert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +\n\t\t\t    'required');\n\n\t\t\tcurveNames = Object.keys(algs.curves);\n\t\t\tvar ks = Object.keys(curve);\n\t\t\tfor (j = 0; j < curveNames.length; ++j) {\n\t\t\t\tc = curveNames[j];\n\t\t\t\tcd = algs.curves[c];\n\t\t\t\tvar equal = true;\n\t\t\t\tfor (var i = 0; i < ks.length; ++i) {\n\t\t\t\t\tvar k = ks[i];\n\t\t\t\t\tif (cd[k] === undefined)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (typeof (cd[k]) === 'object' &&\n\t\t\t\t\t    cd[k].equals !== undefined) {\n\t\t\t\t\t\tif (!cd[k].equals(curve[k])) {\n\t\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Buffer.isBuffer(cd[k])) {\n\t\t\t\t\t\tif (cd[k].toString('binary')\n\t\t\t\t\t\t    !== curve[k].toString('binary')) {\n\t\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cd[k] !== curve[k]) {\n\t\t\t\t\t\t\tequal = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (equal) {\n\t\t\t\t\tcurveName = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (curveName);\n\t}\n\n\tfunction readPkcs8ECDSAPrivate(der) {\n\t\tvar curveName = readECDSACurve(der);\n\t\tassert.string(curveName, 'a known elliptic curve');\n\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tder.readSequence();\n\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.equal(version[0], 1, 'unknown version of ECDSA key');\n\n\t\tvar d = der.readString(asn1.Ber.OctetString, true);\n\t\tvar Q;\n\n\t\tif (der.peek() == 0xa0) {\n\t\t\tder.readSequence(0xa0);\n\t\t\tder._offset += der.length;\n\t\t}\n\t\tif (der.peek() == 0xa1) {\n\t\t\tder.readSequence(0xa1);\n\t\t\tQ = der.readString(asn1.Ber.BitString, true);\n\t\t\tQ = utils.ecNormalize(Q);\n\t\t}\n\n\t\tif (Q === undefined) {\n\t\t\tvar pub = utils.publicFromPrivateECDSA(curveName, d);\n\t\t\tQ = pub.part.Q.data;\n\t\t}\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t\t{ name: 'Q', data: Q },\n\t\t\t\t{ name: 'd', data: d }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs8ECDSAPublic(der) {\n\t\tvar curveName = readECDSACurve(der);\n\t\tassert.string(curveName, 'a known elliptic curve');\n\n\t\tvar Q = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\n\t\t\t\t{ name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs8EdDSAPublic(der) {\n\t\tif (der.peek() === 0x00)\n\t\t\tder.readByte();\n\n\t\tvar A = utils.readBitString(der);\n\n\t\tvar key = {\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs8X25519Public(der) {\n\t\tvar A = utils.readBitString(der);\n\n\t\tvar key = {\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs8EdDSAPrivate(der) {\n\t\tif (der.peek() === 0x00)\n\t\t\tder.readByte();\n\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar k = der.readString(asn1.Ber.OctetString, true);\n\t\tk = utils.zeroPadToLength(k, 32);\n\n\t\tvar A;\n\t\tif (der.peek() === asn1.Ber.BitString) {\n\t\t\tA = utils.readBitString(der);\n\t\t\tA = utils.zeroPadToLength(A, 32);\n\t\t} else {\n\t\t\tA = utils.calculateED25519Public(k);\n\t\t}\n\n\t\tvar key = {\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs8X25519Private(der) {\n\t\tif (der.peek() === 0x00)\n\t\t\tder.readByte();\n\n\t\tder.readSequence(asn1.Ber.OctetString);\n\t\tvar k = der.readString(asn1.Ber.OctetString, true);\n\t\tk = utils.zeroPadToLength(k, 32);\n\n\t\tvar A = utils.calculateX25519Public(k);\n\n\t\tvar key = {\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction pkcs8ToBuffer(key) {\n\t\tvar der = new asn1.BerWriter();\n\t\twritePkcs8(der, key);\n\t\treturn (der.buffer);\n\t}\n\n\tfunction writePkcs8(der, key) {\n\t\tder.startSequence();\n\n\t\tif (PrivateKey.isPrivateKey(key)) {\n\t\t\tvar sillyInt = Buffer.from([0]);\n\t\t\tder.writeBuffer(sillyInt, asn1.Ber.Integer);\n\t\t}\n\n\t\tder.startSequence();\n\t\tswitch (key.type) {\n\t\tcase 'rsa':\n\t\t\tder.writeOID('1.2.840.113549.1.1.1');\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs8RSAPrivate(key, der);\n\t\t\telse\n\t\t\t\twritePkcs8RSAPublic(key, der);\n\t\t\tbreak;\n\t\tcase 'dsa':\n\t\t\tder.writeOID('1.2.840.10040.4.1');\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs8DSAPrivate(key, der);\n\t\t\telse\n\t\t\t\twritePkcs8DSAPublic(key, der);\n\t\t\tbreak;\n\t\tcase 'ecdsa':\n\t\t\tder.writeOID('1.2.840.10045.2.1');\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs8ECDSAPrivate(key, der);\n\t\t\telse\n\t\t\t\twritePkcs8ECDSAPublic(key, der);\n\t\t\tbreak;\n\t\tcase 'ed25519':\n\t\t\tder.writeOID('1.3.101.112');\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\tthrow (new Error('Ed25519 private keys in pkcs8 ' +\n\t\t\t\t    'format are not supported'));\n\t\t\twritePkcs8EdDSAPublic(key, der);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unsupported key type: ' + key.type));\n\t\t}\n\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs8RSAPrivate(key, der) {\n\t\tder.writeNull();\n\t\tder.endSequence();\n\n\t\tder.startSequence(asn1.Ber.OctetString);\n\t\tder.startSequence();\n\n\t\tvar version = Buffer.from([0]);\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tif (!key.part.dmodp || !key.part.dmodq)\n\t\t\tutils.addRSAMissing(key);\n\t\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs8RSAPublic(key, der) {\n\t\tder.writeNull();\n\t\tder.endSequence();\n\n\t\tder.startSequence(asn1.Ber.BitString);\n\t\tder.writeByte(0x00);\n\n\t\tder.startSequence();\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t\tder.endSequence();\n\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs8DSAPrivate(key, der) {\n\t\tder.startSequence();\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t\tder.endSequence();\n\n\t\tder.endSequence();\n\n\t\tder.startSequence(asn1.Ber.OctetString);\n\t\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs8DSAPublic(key, der) {\n\t\tder.startSequence();\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t\tder.endSequence();\n\t\tder.endSequence();\n\n\t\tder.startSequence(asn1.Ber.BitString);\n\t\tder.writeByte(0x00);\n\t\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\t\tder.endSequence();\n\t}\n\n\tfunction writeECDSACurve(key, der) {\n\t\tvar curve = algs.curves[key.curve];\n\t\tif (curve.pkcs8oid) {\n\t\t\t/* This one has a name in pkcs#8, so just write the oid */\n\t\t\tder.writeOID(curve.pkcs8oid);\n\n\t\t} else {\n\t\t\t// ECParameters sequence\n\t\t\tder.startSequence();\n\n\t\t\tvar version = Buffer.from([1]);\n\t\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\t\t// FieldID sequence\n\t\t\tder.startSequence();\n\t\t\tder.writeOID('1.2.840.10045.1.1'); // prime-field\n\t\t\tder.writeBuffer(curve.p, asn1.Ber.Integer);\n\t\t\tder.endSequence();\n\n\t\t\t// Curve sequence\n\t\t\tder.startSequence();\n\t\t\tvar a = curve.p;\n\t\t\tif (a[0] === 0x0)\n\t\t\t\ta = a.slice(1);\n\t\t\tder.writeBuffer(a, asn1.Ber.OctetString);\n\t\t\tder.writeBuffer(curve.b, asn1.Ber.OctetString);\n\t\t\tder.writeBuffer(curve.s, asn1.Ber.BitString);\n\t\t\tder.endSequence();\n\n\t\t\tder.writeBuffer(curve.G, asn1.Ber.OctetString);\n\t\t\tder.writeBuffer(curve.n, asn1.Ber.Integer);\n\t\t\tvar h = curve.h;\n\t\t\tif (!h) {\n\t\t\t\th = Buffer.from([1]);\n\t\t\t}\n\t\t\tder.writeBuffer(h, asn1.Ber.Integer);\n\n\t\t\t// ECParameters\n\t\t\tder.endSequence();\n\t\t}\n\t}\n\n\tfunction writePkcs8ECDSAPublic(key, der) {\n\t\twriteECDSACurve(key, der);\n\t\tder.endSequence();\n\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t}\n\n\tfunction writePkcs8ECDSAPrivate(key, der) {\n\t\twriteECDSACurve(key, der);\n\t\tder.endSequence();\n\n\t\tder.startSequence(asn1.Ber.OctetString);\n\t\tder.startSequence();\n\n\t\tvar version = Buffer.from([1]);\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\t\tder.startSequence(0xa1);\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t\tder.endSequence();\n\n\t\tder.endSequence();\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs8EdDSAPublic(key, der) {\n\t\tder.endSequence();\n\n\t\tutils.writeBitString(der, key.part.A.data);\n\t}\n\n\tfunction writePkcs8EdDSAPrivate(key, der) {\n\t\tder.endSequence();\n\n\t\tvar k = utils.mpNormalize(key.part.k.data, true);\n\t\tder.startSequence(asn1.Ber.OctetString);\n\t\tder.writeBuffer(k, asn1.Ber.OctetString);\n\t\tder.endSequence();\n\t}\n\treturn pkcs8;\n}\n\nexport { requirePkcs8 as __require };","start":1667202983994,"end":1667202985001,"order":"normal"}]}
