{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/http-signature/lib/utils.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar sshpk = require('sshpk');\nvar util = require('util');\n\nvar HASH_ALGOS = {\n  'sha1': true,\n  'sha256': true,\n  'sha512': true\n};\n\nvar PK_ALGOS = {\n  'rsa': true,\n  'dsa': true,\n  'ecdsa': true\n};\n\nfunction HttpSignatureError(message, caller) {\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, caller || HttpSignatureError);\n\n  this.message = message;\n  this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\n\nfunction InvalidAlgorithmError(message) {\n  HttpSignatureError.call(this, message, InvalidAlgorithmError);\n}\nutil.inherits(InvalidAlgorithmError, HttpSignatureError);\n\nfunction validateAlgorithm(algorithm) {\n  var alg = algorithm.toLowerCase().split('-');\n\n  if (alg.length !== 2) {\n    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a ' +\n      'valid algorithm'));\n  }\n\n  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {\n    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys ' +\n      'are not supported'));\n  }\n\n  if (!HASH_ALGOS[alg[1]]) {\n    throw (new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a ' +\n      'supported hash algorithm'));\n  }\n\n  return (alg);\n}\n\n///--- API\n\nmodule.exports = {\n\n  HASH_ALGOS: HASH_ALGOS,\n  PK_ALGOS: PK_ALGOS,\n\n  HttpSignatureError: HttpSignatureError,\n  InvalidAlgorithmError: InvalidAlgorithmError,\n\n  validateAlgorithm: validateAlgorithm,\n\n  /**\n   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n   *\n   * The intent of this module is to interoperate with OpenSSL only,\n   * specifically the node crypto module's `verify` method.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} PEM encoded form of the RSA public key.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} on invalid ssh key formatted data.\n   */\n  sshKeyToPEM: function sshKeyToPEM(key) {\n    assert.string(key, 'ssh_key');\n\n    var k = sshpk.parseKey(key, 'ssh');\n    return (k.toString('pem'));\n  },\n\n\n  /**\n   * Generates an OpenSSH fingerprint from an ssh public key.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} key fingerprint.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} if what you passed doesn't look like an ssh public key.\n   */\n  fingerprint: function fingerprint(key) {\n    assert.string(key, 'ssh_key');\n\n    var k = sshpk.parseKey(key, 'ssh');\n    return (k.fingerprint('md5').toString('hex'));\n  },\n\n  /**\n   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n   *\n   * The reverse of the above function.\n   */\n  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n    assert.equal('string', typeof (pem), 'typeof pem');\n\n    var k = sshpk.parseKey(pem, 'pem');\n    k.comment = comment;\n    return (k.toString('ssh'));\n  }\n};\n","start":1667202705126,"end":1667202705290},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\n\nvar utils;\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\t// Copyright 2012 Joyent, Inc.  All rights reserved.\n\n\tvar assert = require$$0();\n\tvar sshpk = require$$1();\n\tvar util = require$$2();\n\n\tvar HASH_ALGOS = {\n\t  'sha1': true,\n\t  'sha256': true,\n\t  'sha512': true\n\t};\n\n\tvar PK_ALGOS = {\n\t  'rsa': true,\n\t  'dsa': true,\n\t  'ecdsa': true\n\t};\n\n\tfunction HttpSignatureError(message, caller) {\n\t  if (Error.captureStackTrace)\n\t    Error.captureStackTrace(this, caller || HttpSignatureError);\n\n\t  this.message = message;\n\t  this.name = caller.name;\n\t}\n\tutil.inherits(HttpSignatureError, Error);\n\n\tfunction InvalidAlgorithmError(message) {\n\t  HttpSignatureError.call(this, message, InvalidAlgorithmError);\n\t}\n\tutil.inherits(InvalidAlgorithmError, HttpSignatureError);\n\n\tfunction validateAlgorithm(algorithm) {\n\t  var alg = algorithm.toLowerCase().split('-');\n\n\t  if (alg.length !== 2) {\n\t    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a ' +\n\t      'valid algorithm'));\n\t  }\n\n\t  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {\n\t    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys ' +\n\t      'are not supported'));\n\t  }\n\n\t  if (!HASH_ALGOS[alg[1]]) {\n\t    throw (new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a ' +\n\t      'supported hash algorithm'));\n\t  }\n\n\t  return (alg);\n\t}\n\n\t///--- API\n\n\tutils = {\n\n\t  HASH_ALGOS: HASH_ALGOS,\n\t  PK_ALGOS: PK_ALGOS,\n\n\t  HttpSignatureError: HttpSignatureError,\n\t  InvalidAlgorithmError: InvalidAlgorithmError,\n\n\t  validateAlgorithm: validateAlgorithm,\n\n\t  /**\n\t   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n\t   *\n\t   * The intent of this module is to interoperate with OpenSSL only,\n\t   * specifically the node crypto module's `verify` method.\n\t   *\n\t   * @param {String} key an OpenSSH public key.\n\t   * @return {String} PEM encoded form of the RSA public key.\n\t   * @throws {TypeError} on bad input.\n\t   * @throws {Error} on invalid ssh key formatted data.\n\t   */\n\t  sshKeyToPEM: function sshKeyToPEM(key) {\n\t    assert.string(key, 'ssh_key');\n\n\t    var k = sshpk.parseKey(key, 'ssh');\n\t    return (k.toString('pem'));\n\t  },\n\n\n\t  /**\n\t   * Generates an OpenSSH fingerprint from an ssh public key.\n\t   *\n\t   * @param {String} key an OpenSSH public key.\n\t   * @return {String} key fingerprint.\n\t   * @throws {TypeError} on bad input.\n\t   * @throws {Error} if what you passed doesn't look like an ssh public key.\n\t   */\n\t  fingerprint: function fingerprint(key) {\n\t    assert.string(key, 'ssh_key');\n\n\t    var k = sshpk.parseKey(key, 'ssh');\n\t    return (k.fingerprint('md5').toString('hex'));\n\t  },\n\n\t  /**\n\t   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n\t   *\n\t   * The reverse of the above function.\n\t   */\n\t  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n\t    assert.equal('string', typeof (pem), 'typeof pem');\n\n\t    var k = sshpk.parseKey(pem, 'pem');\n\t    k.comment = comment;\n\t    return (k.toString('ssh'));\n\t  }\n\t};\n\treturn utils;\n}\n\nexport { requireUtils as __require };","start":1667202705290,"end":1667202707991,"order":"normal"}]}
