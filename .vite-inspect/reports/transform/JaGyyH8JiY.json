{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Key;\n\nvar assert = require('assert-plus');\nvar algs = require('./algs');\nvar crypto = require('crypto');\nvar Fingerprint = require('./fingerprint');\nvar Signature = require('./signature');\nvar DiffieHellman = require('./dhe').DiffieHellman;\nvar errs = require('./errors');\nvar utils = require('./utils');\nvar PrivateKey = require('./private-key');\nvar edCompat;\n\ntry {\n\tedCompat = require('./ed-compat');\n} catch (e) {\n\t/* Just continue through, and bail out if we try to use it. */\n}\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\n\nvar formats = {};\nformats['auto'] = require('./formats/auto');\nformats['pem'] = require('./formats/pem');\nformats['pkcs1'] = require('./formats/pkcs1');\nformats['pkcs8'] = require('./formats/pkcs8');\nformats['rfc4253'] = require('./formats/rfc4253');\nformats['ssh'] = require('./formats/ssh');\nformats['ssh-private'] = require('./formats/ssh-private');\nformats['openssh'] = formats['ssh-private'];\nformats['dnssec'] = require('./formats/dnssec');\nformats['putty'] = require('./formats/putty');\nformats['ppk'] = formats['putty'];\n\nfunction Key(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\tassert.optionalString(opts.comment, 'options.comment');\n\n\tvar algInfo = algs.info[opts.type];\n\tif (typeof (algInfo) !== 'object')\n\t\tthrow (new InvalidAlgorithmError(opts.type));\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n\tthis.comment = undefined;\n\tthis.source = opts.source;\n\n\t/* for speeding up hashing/fingerprint operations */\n\tthis._rfc4253Cache = opts._rfc4253Cache;\n\tthis._hashCache = {};\n\n\tvar sz;\n\tthis.curve = undefined;\n\tif (this.type === 'ecdsa') {\n\t\tvar curve = this.part.curve.data.toString();\n\t\tthis.curve = curve;\n\t\tsz = algs.curves[curve].size;\n\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\n\t\tsz = 256;\n\t\tthis.curve = 'curve25519';\n\t} else {\n\t\tvar szPart = this.part[algInfo.sizePart];\n\t\tsz = szPart.data.length;\n\t\tsz = sz * 8 - utils.countZeros(szPart.data);\n\t}\n\tthis.size = sz;\n}\n\nKey.formats = formats;\n\nKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'ssh';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\tif (format === 'rfc4253') {\n\t\tif (this._rfc4253Cache === undefined)\n\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\n\t\treturn (this._rfc4253Cache);\n\t}\n\n\treturn (formats[format].write(this, options));\n};\n\nKey.prototype.toString = function (format, options) {\n\treturn (this.toBuffer(format, options).toString());\n};\n\nKey.prototype.hash = function (algo, type) {\n\tassert.string(algo, 'algorithm');\n\tassert.optionalString(type, 'type');\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\talgo = algo.toLowerCase();\n\tif (algs.hashAlgs[algo] === undefined)\n\t\tthrow (new InvalidAlgorithmError(algo));\n\n\tvar cacheKey = algo + '||' + type;\n\tif (this._hashCache[cacheKey])\n\t\treturn (this._hashCache[cacheKey]);\n\n\tvar buf;\n\tif (type === 'ssh') {\n\t\tbuf = this.toBuffer('rfc4253');\n\t} else if (type === 'spki') {\n\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\n\t} else {\n\t\tthrow (new Error('Hash type ' + type + ' not supported'));\n\t}\n\tvar hash = crypto.createHash(algo).update(buf).digest();\n\tthis._hashCache[cacheKey] = hash;\n\treturn (hash);\n};\n\nKey.prototype.fingerprint = function (algo, type) {\n\tif (algo === undefined)\n\t\talgo = 'sha256';\n\tif (type === undefined)\n\t\ttype = 'ssh';\n\tassert.string(algo, 'algorithm');\n\tassert.string(type, 'type');\n\tvar opts = {\n\t\ttype: 'key',\n\t\thash: this.hash(algo, type),\n\t\talgorithm: algo,\n\t\thashType: type\n\t};\n\treturn (new Fingerprint(opts));\n};\n\nKey.prototype.defaultHashAlgorithm = function () {\n\tvar hashAlgo = 'sha1';\n\tif (this.type === 'rsa')\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'dsa' && this.size > 1024)\n\t\thashAlgo = 'sha256';\n\tif (this.type === 'ed25519')\n\t\thashAlgo = 'sha512';\n\tif (this.type === 'ecdsa') {\n\t\tif (this.size <= 256)\n\t\t\thashAlgo = 'sha256';\n\t\telse if (this.size <= 384)\n\t\t\thashAlgo = 'sha384';\n\t\telse\n\t\t\thashAlgo = 'sha512';\n\t}\n\treturn (hashAlgo);\n};\n\nKey.prototype.createVerify = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Verifier(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createVerify(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldVerify = v.verify.bind(v);\n\tvar key = this.toBuffer('pkcs8');\n\tvar curve = this.curve;\n\tvar self = this;\n\tv.verify = function (signature, fmt) {\n\t\tif (Signature.isSignature(signature, [2, 0])) {\n\t\t\tif (signature.type !== self.type)\n\t\t\t\treturn (false);\n\t\t\tif (signature.hashAlgorithm &&\n\t\t\t    signature.hashAlgorithm !== hashAlgo)\n\t\t\t\treturn (false);\n\t\t\tif (signature.curve && self.type === 'ecdsa' &&\n\t\t\t    signature.curve !== curve)\n\t\t\t\treturn (false);\n\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\n\n\t\t} else if (typeof (signature) === 'string' ||\n\t\t    Buffer.isBuffer(signature)) {\n\t\t\treturn (oldVerify(key, signature, fmt));\n\n\t\t/*\n\t\t * Avoid doing this on valid arguments, walking the prototype\n\t\t * chain can be quite slow.\n\t\t */\n\t\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\t\tthrow (new Error('signature was created by too old ' +\n\t\t\t    'a version of sshpk and cannot be verified'));\n\n\t\t} else {\n\t\t\tthrow (new TypeError('signature must be a string, ' +\n\t\t\t    'Buffer, or Signature object'));\n\t\t}\n\t};\n\treturn (v);\n};\n\nKey.prototype.createDiffieHellman = function () {\n\tif (this.type === 'rsa')\n\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\n\n\treturn (new DiffieHellman(this));\n};\nKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\nKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tif (k instanceof PrivateKey)\n\t\t\tk = k.toPublic();\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nKey.isKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Key, ver));\n};\n\n/*\n * API versions for Key:\n * [1,0] -- initial ver, may take Signature for createVerify or may not\n * [1,1] -- added pkcs1, pkcs8 formats\n * [1,2] -- added auto, ssh-private, openssh formats\n * [1,3] -- added defaultHashAlgorithm\n * [1,4] -- added ed support, createDH\n * [1,5] -- first explicitly tagged version\n * [1,6] -- changed ed25519 part names\n * [1,7] -- spki hash types\n */\nKey.prototype._sshpkApiVersion = [1, 7];\n\nKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tassert.func(obj.fingerprint);\n\tif (obj.createDH)\n\t\treturn ([1, 4]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 3]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 2]);\n\tif (obj.formats['pkcs1'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n","start":1667202705817,"end":1667202706303},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/fingerprint.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/dhe.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ed-compat.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/auto.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/dnssec.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/putty.js?commonjs-wrapped\";\n\nvar key;\nvar hasRequiredKey;\n\nfunction requireKey () {\n\tif (hasRequiredKey) return key;\n\thasRequiredKey = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tkey = Key;\n\n\tvar assert = require$$0();\n\tvar algs = require$$1();\n\tvar crypto = require$$2;\n\tvar Fingerprint = require$$3();\n\tvar Signature = require$$4();\n\tvar DiffieHellman = require$$5().DiffieHellman;\n\tvar errs = require$$6();\n\tvar utils = require$$7();\n\tvar PrivateKey = require$$8();\n\tvar edCompat;\n\n\ttry {\n\t\tedCompat = require$$9();\n\t} catch (e) {\n\t\t/* Just continue through, and bail out if we try to use it. */\n\t}\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar KeyParseError = errs.KeyParseError;\n\n\tvar formats = {};\n\tformats['auto'] = require$$10();\n\tformats['pem'] = require$$11();\n\tformats['pkcs1'] = require$$12();\n\tformats['pkcs8'] = require$$13();\n\tformats['rfc4253'] = require$$14();\n\tformats['ssh'] = require$$15();\n\tformats['ssh-private'] = require$$16();\n\tformats['openssh'] = formats['ssh-private'];\n\tformats['dnssec'] = require$$17();\n\tformats['putty'] = require$$18();\n\tformats['ppk'] = formats['putty'];\n\n\tfunction Key(opts) {\n\t\tassert.object(opts, 'options');\n\t\tassert.arrayOfObject(opts.parts, 'options.parts');\n\t\tassert.string(opts.type, 'options.type');\n\t\tassert.optionalString(opts.comment, 'options.comment');\n\n\t\tvar algInfo = algs.info[opts.type];\n\t\tif (typeof (algInfo) !== 'object')\n\t\t\tthrow (new InvalidAlgorithmError(opts.type));\n\n\t\tvar partLookup = {};\n\t\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\t\tvar part = opts.parts[i];\n\t\t\tpartLookup[part.name] = part;\n\t\t}\n\n\t\tthis.type = opts.type;\n\t\tthis.parts = opts.parts;\n\t\tthis.part = partLookup;\n\t\tthis.comment = undefined;\n\t\tthis.source = opts.source;\n\n\t\t/* for speeding up hashing/fingerprint operations */\n\t\tthis._rfc4253Cache = opts._rfc4253Cache;\n\t\tthis._hashCache = {};\n\n\t\tvar sz;\n\t\tthis.curve = undefined;\n\t\tif (this.type === 'ecdsa') {\n\t\t\tvar curve = this.part.curve.data.toString();\n\t\t\tthis.curve = curve;\n\t\t\tsz = algs.curves[curve].size;\n\t\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\n\t\t\tsz = 256;\n\t\t\tthis.curve = 'curve25519';\n\t\t} else {\n\t\t\tvar szPart = this.part[algInfo.sizePart];\n\t\t\tsz = szPart.data.length;\n\t\t\tsz = sz * 8 - utils.countZeros(szPart.data);\n\t\t}\n\t\tthis.size = sz;\n\t}\n\n\tKey.formats = formats;\n\n\tKey.prototype.toBuffer = function (format, options) {\n\t\tif (format === undefined)\n\t\t\tformat = 'ssh';\n\t\tassert.string(format, 'format');\n\t\tassert.object(formats[format], 'formats[format]');\n\t\tassert.optionalObject(options, 'options');\n\n\t\tif (format === 'rfc4253') {\n\t\t\tif (this._rfc4253Cache === undefined)\n\t\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\n\t\t\treturn (this._rfc4253Cache);\n\t\t}\n\n\t\treturn (formats[format].write(this, options));\n\t};\n\n\tKey.prototype.toString = function (format, options) {\n\t\treturn (this.toBuffer(format, options).toString());\n\t};\n\n\tKey.prototype.hash = function (algo, type) {\n\t\tassert.string(algo, 'algorithm');\n\t\tassert.optionalString(type, 'type');\n\t\tif (type === undefined)\n\t\t\ttype = 'ssh';\n\t\talgo = algo.toLowerCase();\n\t\tif (algs.hashAlgs[algo] === undefined)\n\t\t\tthrow (new InvalidAlgorithmError(algo));\n\n\t\tvar cacheKey = algo + '||' + type;\n\t\tif (this._hashCache[cacheKey])\n\t\t\treturn (this._hashCache[cacheKey]);\n\n\t\tvar buf;\n\t\tif (type === 'ssh') {\n\t\t\tbuf = this.toBuffer('rfc4253');\n\t\t} else if (type === 'spki') {\n\t\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\n\t\t} else {\n\t\t\tthrow (new Error('Hash type ' + type + ' not supported'));\n\t\t}\n\t\tvar hash = crypto.createHash(algo).update(buf).digest();\n\t\tthis._hashCache[cacheKey] = hash;\n\t\treturn (hash);\n\t};\n\n\tKey.prototype.fingerprint = function (algo, type) {\n\t\tif (algo === undefined)\n\t\t\talgo = 'sha256';\n\t\tif (type === undefined)\n\t\t\ttype = 'ssh';\n\t\tassert.string(algo, 'algorithm');\n\t\tassert.string(type, 'type');\n\t\tvar opts = {\n\t\t\ttype: 'key',\n\t\t\thash: this.hash(algo, type),\n\t\t\talgorithm: algo,\n\t\t\thashType: type\n\t\t};\n\t\treturn (new Fingerprint(opts));\n\t};\n\n\tKey.prototype.defaultHashAlgorithm = function () {\n\t\tvar hashAlgo = 'sha1';\n\t\tif (this.type === 'rsa')\n\t\t\thashAlgo = 'sha256';\n\t\tif (this.type === 'dsa' && this.size > 1024)\n\t\t\thashAlgo = 'sha256';\n\t\tif (this.type === 'ed25519')\n\t\t\thashAlgo = 'sha512';\n\t\tif (this.type === 'ecdsa') {\n\t\t\tif (this.size <= 256)\n\t\t\t\thashAlgo = 'sha256';\n\t\t\telse if (this.size <= 384)\n\t\t\t\thashAlgo = 'sha384';\n\t\t\telse\n\t\t\t\thashAlgo = 'sha512';\n\t\t}\n\t\treturn (hashAlgo);\n\t};\n\n\tKey.prototype.createVerify = function (hashAlgo) {\n\t\tif (hashAlgo === undefined)\n\t\t\thashAlgo = this.defaultHashAlgorithm();\n\t\tassert.string(hashAlgo, 'hash algorithm');\n\n\t\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\t\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\t\treturn (new edCompat.Verifier(this, hashAlgo));\n\t\tif (this.type === 'curve25519')\n\t\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t\t    'signing or verification'));\n\n\t\tvar v, nm, err;\n\t\ttry {\n\t\t\tnm = hashAlgo.toUpperCase();\n\t\t\tv = crypto.createVerify(nm);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t}\n\t\tif (v === undefined || (err instanceof Error &&\n\t\t    err.message.match(/Unknown message digest/))) {\n\t\t\tnm = 'RSA-';\n\t\t\tnm += hashAlgo.toUpperCase();\n\t\t\tv = crypto.createVerify(nm);\n\t\t}\n\t\tassert.ok(v, 'failed to create verifier');\n\t\tvar oldVerify = v.verify.bind(v);\n\t\tvar key = this.toBuffer('pkcs8');\n\t\tvar curve = this.curve;\n\t\tvar self = this;\n\t\tv.verify = function (signature, fmt) {\n\t\t\tif (Signature.isSignature(signature, [2, 0])) {\n\t\t\t\tif (signature.type !== self.type)\n\t\t\t\t\treturn (false);\n\t\t\t\tif (signature.hashAlgorithm &&\n\t\t\t\t    signature.hashAlgorithm !== hashAlgo)\n\t\t\t\t\treturn (false);\n\t\t\t\tif (signature.curve && self.type === 'ecdsa' &&\n\t\t\t\t    signature.curve !== curve)\n\t\t\t\t\treturn (false);\n\t\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\n\n\t\t\t} else if (typeof (signature) === 'string' ||\n\t\t\t    Buffer.isBuffer(signature)) {\n\t\t\t\treturn (oldVerify(key, signature, fmt));\n\n\t\t\t/*\n\t\t\t * Avoid doing this on valid arguments, walking the prototype\n\t\t\t * chain can be quite slow.\n\t\t\t */\n\t\t\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\t\t\tthrow (new Error('signature was created by too old ' +\n\t\t\t\t    'a version of sshpk and cannot be verified'));\n\n\t\t\t} else {\n\t\t\t\tthrow (new TypeError('signature must be a string, ' +\n\t\t\t\t    'Buffer, or Signature object'));\n\t\t\t}\n\t\t};\n\t\treturn (v);\n\t};\n\n\tKey.prototype.createDiffieHellman = function () {\n\t\tif (this.type === 'rsa')\n\t\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\n\n\t\treturn (new DiffieHellman(this));\n\t};\n\tKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\n\tKey.parse = function (data, format, options) {\n\t\tif (typeof (data) !== 'string')\n\t\t\tassert.buffer(data, 'data');\n\t\tif (format === undefined)\n\t\t\tformat = 'auto';\n\t\tassert.string(format, 'format');\n\t\tif (typeof (options) === 'string')\n\t\t\toptions = { filename: options };\n\t\tassert.optionalObject(options, 'options');\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.optionalString(options.filename, 'options.filename');\n\t\tif (options.filename === undefined)\n\t\t\toptions.filename = '(unnamed)';\n\n\t\tassert.object(formats[format], 'formats[format]');\n\n\t\ttry {\n\t\t\tvar k = formats[format].read(data, options);\n\t\t\tif (k instanceof PrivateKey)\n\t\t\t\tk = k.toPublic();\n\t\t\tif (!k.comment)\n\t\t\t\tk.comment = options.filename;\n\t\t\treturn (k);\n\t\t} catch (e) {\n\t\t\tif (e.name === 'KeyEncryptedError')\n\t\t\t\tthrow (e);\n\t\t\tthrow (new KeyParseError(options.filename, format, e));\n\t\t}\n\t};\n\n\tKey.isKey = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, Key, ver));\n\t};\n\n\t/*\n\t * API versions for Key:\n\t * [1,0] -- initial ver, may take Signature for createVerify or may not\n\t * [1,1] -- added pkcs1, pkcs8 formats\n\t * [1,2] -- added auto, ssh-private, openssh formats\n\t * [1,3] -- added defaultHashAlgorithm\n\t * [1,4] -- added ed support, createDH\n\t * [1,5] -- first explicitly tagged version\n\t * [1,6] -- changed ed25519 part names\n\t * [1,7] -- spki hash types\n\t */\n\tKey.prototype._sshpkApiVersion = [1, 7];\n\n\tKey._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toBuffer);\n\t\tassert.func(obj.fingerprint);\n\t\tif (obj.createDH)\n\t\t\treturn ([1, 4]);\n\t\tif (obj.defaultHashAlgorithm)\n\t\t\treturn ([1, 3]);\n\t\tif (obj.formats['auto'])\n\t\t\treturn ([1, 2]);\n\t\tif (obj.formats['pkcs1'])\n\t\t\treturn ([1, 1]);\n\t\treturn ([1, 0]);\n\t};\n\treturn key;\n}\n\nexport { requireKey as __require };","start":1667202706303,"end":1667202707973,"order":"normal"},{"name":"node-polyfills","result":"import { Buffer as Buffer } from 'buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/fingerprint.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/dhe.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ed-compat.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/auto.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/dnssec.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/putty.js?commonjs-wrapped\";\n\nvar key;\nvar hasRequiredKey;\n\nfunction requireKey () {\n\tif (hasRequiredKey) return key;\n\thasRequiredKey = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tkey = Key;\n\n\tvar assert = require$$0();\n\tvar algs = require$$1();\n\tvar crypto = require$$2;\n\tvar Fingerprint = require$$3();\n\tvar Signature = require$$4();\n\tvar DiffieHellman = require$$5().DiffieHellman;\n\tvar errs = require$$6();\n\tvar utils = require$$7();\n\tvar PrivateKey = require$$8();\n\tvar edCompat;\n\n\ttry {\n\t\tedCompat = require$$9();\n\t} catch (e) {\n\t\t/* Just continue through, and bail out if we try to use it. */\n\t}\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar KeyParseError = errs.KeyParseError;\n\n\tvar formats = {};\n\tformats['auto'] = require$$10();\n\tformats['pem'] = require$$11();\n\tformats['pkcs1'] = require$$12();\n\tformats['pkcs8'] = require$$13();\n\tformats['rfc4253'] = require$$14();\n\tformats['ssh'] = require$$15();\n\tformats['ssh-private'] = require$$16();\n\tformats['openssh'] = formats['ssh-private'];\n\tformats['dnssec'] = require$$17();\n\tformats['putty'] = require$$18();\n\tformats['ppk'] = formats['putty'];\n\n\tfunction Key(opts) {\n\t\tassert.object(opts, 'options');\n\t\tassert.arrayOfObject(opts.parts, 'options.parts');\n\t\tassert.string(opts.type, 'options.type');\n\t\tassert.optionalString(opts.comment, 'options.comment');\n\n\t\tvar algInfo = algs.info[opts.type];\n\t\tif (typeof (algInfo) !== 'object')\n\t\t\tthrow (new InvalidAlgorithmError(opts.type));\n\n\t\tvar partLookup = {};\n\t\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\t\tvar part = opts.parts[i];\n\t\t\tpartLookup[part.name] = part;\n\t\t}\n\n\t\tthis.type = opts.type;\n\t\tthis.parts = opts.parts;\n\t\tthis.part = partLookup;\n\t\tthis.comment = undefined;\n\t\tthis.source = opts.source;\n\n\t\t/* for speeding up hashing/fingerprint operations */\n\t\tthis._rfc4253Cache = opts._rfc4253Cache;\n\t\tthis._hashCache = {};\n\n\t\tvar sz;\n\t\tthis.curve = undefined;\n\t\tif (this.type === 'ecdsa') {\n\t\t\tvar curve = this.part.curve.data.toString();\n\t\t\tthis.curve = curve;\n\t\t\tsz = algs.curves[curve].size;\n\t\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\n\t\t\tsz = 256;\n\t\t\tthis.curve = 'curve25519';\n\t\t} else {\n\t\t\tvar szPart = this.part[algInfo.sizePart];\n\t\t\tsz = szPart.data.length;\n\t\t\tsz = sz * 8 - utils.countZeros(szPart.data);\n\t\t}\n\t\tthis.size = sz;\n\t}\n\n\tKey.formats = formats;\n\n\tKey.prototype.toBuffer = function (format, options) {\n\t\tif (format === undefined)\n\t\t\tformat = 'ssh';\n\t\tassert.string(format, 'format');\n\t\tassert.object(formats[format], 'formats[format]');\n\t\tassert.optionalObject(options, 'options');\n\n\t\tif (format === 'rfc4253') {\n\t\t\tif (this._rfc4253Cache === undefined)\n\t\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\n\t\t\treturn (this._rfc4253Cache);\n\t\t}\n\n\t\treturn (formats[format].write(this, options));\n\t};\n\n\tKey.prototype.toString = function (format, options) {\n\t\treturn (this.toBuffer(format, options).toString());\n\t};\n\n\tKey.prototype.hash = function (algo, type) {\n\t\tassert.string(algo, 'algorithm');\n\t\tassert.optionalString(type, 'type');\n\t\tif (type === undefined)\n\t\t\ttype = 'ssh';\n\t\talgo = algo.toLowerCase();\n\t\tif (algs.hashAlgs[algo] === undefined)\n\t\t\tthrow (new InvalidAlgorithmError(algo));\n\n\t\tvar cacheKey = algo + '||' + type;\n\t\tif (this._hashCache[cacheKey])\n\t\t\treturn (this._hashCache[cacheKey]);\n\n\t\tvar buf;\n\t\tif (type === 'ssh') {\n\t\t\tbuf = this.toBuffer('rfc4253');\n\t\t} else if (type === 'spki') {\n\t\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\n\t\t} else {\n\t\t\tthrow (new Error('Hash type ' + type + ' not supported'));\n\t\t}\n\t\tvar hash = crypto.createHash(algo).update(buf).digest();\n\t\tthis._hashCache[cacheKey] = hash;\n\t\treturn (hash);\n\t};\n\n\tKey.prototype.fingerprint = function (algo, type) {\n\t\tif (algo === undefined)\n\t\t\talgo = 'sha256';\n\t\tif (type === undefined)\n\t\t\ttype = 'ssh';\n\t\tassert.string(algo, 'algorithm');\n\t\tassert.string(type, 'type');\n\t\tvar opts = {\n\t\t\ttype: 'key',\n\t\t\thash: this.hash(algo, type),\n\t\t\talgorithm: algo,\n\t\t\thashType: type\n\t\t};\n\t\treturn (new Fingerprint(opts));\n\t};\n\n\tKey.prototype.defaultHashAlgorithm = function () {\n\t\tvar hashAlgo = 'sha1';\n\t\tif (this.type === 'rsa')\n\t\t\thashAlgo = 'sha256';\n\t\tif (this.type === 'dsa' && this.size > 1024)\n\t\t\thashAlgo = 'sha256';\n\t\tif (this.type === 'ed25519')\n\t\t\thashAlgo = 'sha512';\n\t\tif (this.type === 'ecdsa') {\n\t\t\tif (this.size <= 256)\n\t\t\t\thashAlgo = 'sha256';\n\t\t\telse if (this.size <= 384)\n\t\t\t\thashAlgo = 'sha384';\n\t\t\telse\n\t\t\t\thashAlgo = 'sha512';\n\t\t}\n\t\treturn (hashAlgo);\n\t};\n\n\tKey.prototype.createVerify = function (hashAlgo) {\n\t\tif (hashAlgo === undefined)\n\t\t\thashAlgo = this.defaultHashAlgorithm();\n\t\tassert.string(hashAlgo, 'hash algorithm');\n\n\t\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\t\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\t\treturn (new edCompat.Verifier(this, hashAlgo));\n\t\tif (this.type === 'curve25519')\n\t\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t\t    'signing or verification'));\n\n\t\tvar v, nm, err;\n\t\ttry {\n\t\t\tnm = hashAlgo.toUpperCase();\n\t\t\tv = crypto.createVerify(nm);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t}\n\t\tif (v === undefined || (err instanceof Error &&\n\t\t    err.message.match(/Unknown message digest/))) {\n\t\t\tnm = 'RSA-';\n\t\t\tnm += hashAlgo.toUpperCase();\n\t\t\tv = crypto.createVerify(nm);\n\t\t}\n\t\tassert.ok(v, 'failed to create verifier');\n\t\tvar oldVerify = v.verify.bind(v);\n\t\tvar key = this.toBuffer('pkcs8');\n\t\tvar curve = this.curve;\n\t\tvar self = this;\n\t\tv.verify = function (signature, fmt) {\n\t\t\tif (Signature.isSignature(signature, [2, 0])) {\n\t\t\t\tif (signature.type !== self.type)\n\t\t\t\t\treturn (false);\n\t\t\t\tif (signature.hashAlgorithm &&\n\t\t\t\t    signature.hashAlgorithm !== hashAlgo)\n\t\t\t\t\treturn (false);\n\t\t\t\tif (signature.curve && self.type === 'ecdsa' &&\n\t\t\t\t    signature.curve !== curve)\n\t\t\t\t\treturn (false);\n\t\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\n\n\t\t\t} else if (typeof (signature) === 'string' ||\n\t\t\t    Buffer.isBuffer(signature)) {\n\t\t\t\treturn (oldVerify(key, signature, fmt));\n\n\t\t\t/*\n\t\t\t * Avoid doing this on valid arguments, walking the prototype\n\t\t\t * chain can be quite slow.\n\t\t\t */\n\t\t\t} else if (Signature.isSignature(signature, [1, 0])) {\n\t\t\t\tthrow (new Error('signature was created by too old ' +\n\t\t\t\t    'a version of sshpk and cannot be verified'));\n\n\t\t\t} else {\n\t\t\t\tthrow (new TypeError('signature must be a string, ' +\n\t\t\t\t    'Buffer, or Signature object'));\n\t\t\t}\n\t\t};\n\t\treturn (v);\n\t};\n\n\tKey.prototype.createDiffieHellman = function () {\n\t\tif (this.type === 'rsa')\n\t\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\n\n\t\treturn (new DiffieHellman(this));\n\t};\n\tKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\n\tKey.parse = function (data, format, options) {\n\t\tif (typeof (data) !== 'string')\n\t\t\tassert.buffer(data, 'data');\n\t\tif (format === undefined)\n\t\t\tformat = 'auto';\n\t\tassert.string(format, 'format');\n\t\tif (typeof (options) === 'string')\n\t\t\toptions = { filename: options };\n\t\tassert.optionalObject(options, 'options');\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.optionalString(options.filename, 'options.filename');\n\t\tif (options.filename === undefined)\n\t\t\toptions.filename = '(unnamed)';\n\n\t\tassert.object(formats[format], 'formats[format]');\n\n\t\ttry {\n\t\t\tvar k = formats[format].read(data, options);\n\t\t\tif (k instanceof PrivateKey)\n\t\t\t\tk = k.toPublic();\n\t\t\tif (!k.comment)\n\t\t\t\tk.comment = options.filename;\n\t\t\treturn (k);\n\t\t} catch (e) {\n\t\t\tif (e.name === 'KeyEncryptedError')\n\t\t\t\tthrow (e);\n\t\t\tthrow (new KeyParseError(options.filename, format, e));\n\t\t}\n\t};\n\n\tKey.isKey = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, Key, ver));\n\t};\n\n\t/*\n\t * API versions for Key:\n\t * [1,0] -- initial ver, may take Signature for createVerify or may not\n\t * [1,1] -- added pkcs1, pkcs8 formats\n\t * [1,2] -- added auto, ssh-private, openssh formats\n\t * [1,3] -- added defaultHashAlgorithm\n\t * [1,4] -- added ed support, createDH\n\t * [1,5] -- first explicitly tagged version\n\t * [1,6] -- changed ed25519 part names\n\t * [1,7] -- spki hash types\n\t */\n\tKey.prototype._sshpkApiVersion = [1, 7];\n\n\tKey._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toBuffer);\n\t\tassert.func(obj.fingerprint);\n\t\tif (obj.createDH)\n\t\t\treturn ([1, 4]);\n\t\tif (obj.defaultHashAlgorithm)\n\t\t\treturn ([1, 3]);\n\t\tif (obj.formats['auto'])\n\t\t\treturn ([1, 2]);\n\t\tif (obj.formats['pkcs1'])\n\t\t\treturn ([1, 1]);\n\t\treturn ([1, 0]);\n\t};\n\treturn key;\n}\n\nexport { requireKey as __require };","start":1667202707973,"end":1667202707978,"order":"normal"}]}
