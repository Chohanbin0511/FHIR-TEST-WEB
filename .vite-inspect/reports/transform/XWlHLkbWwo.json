{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\n\nvar pkcs1 = require('./pkcs1');\nvar pkcs8 = require('./pkcs8');\nvar sshpriv = require('./ssh-private');\nvar rfc4253 = require('./rfc4253');\n\nvar errors = require('../errors');\n\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\n\nvar OID_TO_CIPHER = {\n\t'1.2.840.113549.3.7': '3des-cbc',\n\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n};\nvar CIPHER_TO_OID = {};\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\n\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n});\n\nvar OID_TO_HASH = {\n\t'1.2.840.113549.2.7': 'sha1',\n\t'1.2.840.113549.2.9': 'sha256',\n\t'1.2.840.113549.2.11': 'sha512'\n};\nvar HASH_TO_OID = {};\nObject.keys(OID_TO_HASH).forEach(function (k) {\n\tHASH_TO_OID[OID_TO_HASH[k]] = k;\n});\n\n/*\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n * we just take the public component of it and use that.\n */\nfunction read(buf, options, forceType) {\n\tvar input = buf;\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\tvar m;\n\tvar si = -1;\n\twhile (!m && si < lines.length) {\n\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m, 'invalid PEM header');\n\n\tvar m2;\n\tvar ei = lines.length;\n\twhile (!m2 && ei > 0) {\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t}\n\tassert.ok(m2, 'invalid PEM footer');\n\n\t/* Begin and end banners must match key type */\n\tassert.equal(m[2], m2[2]);\n\tvar type = m[2].toLowerCase();\n\n\tvar alg;\n\tif (m[1]) {\n\t\t/* They also must match algorithms, if given */\n\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n\t\talg = m[1].trim();\n\t}\n\n\tlines = lines.slice(si, ei + 1);\n\n\tvar headers = {};\n\twhile (true) {\n\t\tlines = lines.slice(1);\n\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\tif (!m)\n\t\t\tbreak;\n\t\theaders[m[1].toLowerCase()] = m[2];\n\t}\n\n\t/* Chop off the first and last lines */\n\tlines = lines.slice(0, -1).join('');\n\tbuf = Buffer.from(lines, 'base64');\n\n\tvar cipher, key, iv;\n\tif (headers['proc-type']) {\n\t\tvar parts = headers['proc-type'].split(',');\n\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t}\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t    options.filename, 'PEM'));\n\t\t\t} else {\n\t\t\t\tparts = headers['dek-info'].split(',');\n\t\t\t\tassert.ok(parts.length === 2);\n\t\t\t\tcipher = parts[0].toLowerCase();\n\t\t\t\tiv = Buffer.from(parts[1], 'hex');\n\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\n\t\t\t\t    options.passphrase, 1).key;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (alg && alg.toLowerCase() === 'encrypted') {\n\t\tvar eder = new asn1.BerReader(buf);\n\t\tvar pbesEnd;\n\t\teder.readSequence();\n\n\t\teder.readSequence();\n\t\tpbesEnd = eder.offset + eder.length;\n\n\t\tvar method = eder.readOID();\n\t\tif (method !== OID_PBES2) {\n\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\n\t\t\t    'scheme: ' + method));\n\t\t}\n\n\t\teder.readSequence();\t/* PBES2-params */\n\n\t\teder.readSequence();\t/* keyDerivationFunc */\n\t\tvar kdfEnd = eder.offset + eder.length;\n\t\tvar kdfOid = eder.readOID();\n\t\tif (kdfOid !== OID_PBKDF2)\n\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\n\t\teder.readSequence();\n\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\n\t\tvar iterations = eder.readInt();\n\t\tvar hashAlg = 'sha1';\n\t\tif (eder.offset < kdfEnd) {\n\t\t\teder.readSequence();\n\t\t\tvar hashAlgOid = eder.readOID();\n\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\n\t\t\tif (hashAlg === undefined) {\n\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\n\t\t\t\t    hashAlgOid));\n\t\t\t}\n\t\t}\n\t\teder._offset = kdfEnd;\n\n\t\teder.readSequence();\t/* encryptionScheme */\n\t\tvar cipherOid = eder.readOID();\n\t\tcipher = OID_TO_CIPHER[cipherOid];\n\t\tif (cipher === undefined) {\n\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\n\t\t\t    cipherOid));\n\t\t}\n\t\tiv = eder.readString(asn1.Ber.OctetString, true);\n\n\t\teder._offset = pbesEnd;\n\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\n\n\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\toptions.passphrase = Buffer.from(\n\t\t\t    options.passphrase, 'utf-8');\n\t\t}\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t    options.filename, 'PEM'));\n\t\t}\n\n\t\tvar cinfo = utils.opensshCipherInfo(cipher);\n\n\t\tcipher = cinfo.opensslName;\n\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\n\t\t    options.passphrase);\n\t\talg = undefined;\n\t}\n\n\tif (cipher && key && iv) {\n\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\n\t\tvar chunk, chunks = [];\n\t\tcipherStream.once('error', function (e) {\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t}\n\t\t\tthrow (e);\n\t\t});\n\t\tcipherStream.write(buf);\n\t\tcipherStream.end();\n\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\tchunks.push(chunk);\n\t\tbuf = Buffer.concat(chunks);\n\t}\n\n\t/* The new OpenSSH internal format abuses PEM headers */\n\tif (alg && alg.toLowerCase() === 'openssh')\n\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\n\tif (alg && alg.toLowerCase() === 'ssh2')\n\t\treturn (rfc4253.readType(type, buf, options));\n\n\tvar der = new asn1.BerReader(buf);\n\tder.originalInput = input;\n\n\t/*\n\t * All of the PEM file types start with a sequence tag, so chop it\n\t * off here\n\t */\n\tder.readSequence();\n\n\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\n\tif (alg) {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs1');\n\t\treturn (pkcs1.readPkcs1(alg, type, der));\n\t} else {\n\t\tif (forceType)\n\t\t\tassert.strictEqual(forceType, 'pkcs8');\n\t\treturn (pkcs8.readPkcs8(alg, type, der));\n\t}\n}\n\nfunction write(key, options, type) {\n\tassert.object(key);\n\n\tvar alg = {\n\t    'ecdsa': 'EC',\n\t    'rsa': 'RSA',\n\t    'dsa': 'DSA',\n\t    'ed25519': 'EdDSA'\n\t}[key.type];\n\tvar header;\n\n\tvar der = new asn1.BerWriter();\n\n\tif (PrivateKey.isPrivateKey(key)) {\n\t\tif (type && type === 'pkcs8') {\n\t\t\theader = 'PRIVATE KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs1');\n\t\t\theader = alg + ' PRIVATE KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t}\n\n\t} else if (Key.isKey(key)) {\n\t\tif (type && type === 'pkcs1') {\n\t\t\theader = alg + ' PUBLIC KEY';\n\t\t\tpkcs1.writePkcs1(der, key);\n\t\t} else {\n\t\t\tif (type)\n\t\t\t\tassert.strictEqual(type, 'pkcs8');\n\t\t\theader = 'PUBLIC KEY';\n\t\t\tpkcs8.writePkcs8(der, key);\n\t\t}\n\n\t} else {\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t}\n\n\tvar tmp = der.buffer.toString('base64');\n\tvar len = tmp.length + (tmp.length / 64) +\n\t    18 + 16 + header.length*2 + 10;\n\tvar buf = Buffer.alloc(len);\n\tvar o = 0;\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\tfor (var i = 0; i < tmp.length; ) {\n\t\tvar limit = i + 64;\n\t\tif (limit > tmp.length)\n\t\t\tlimit = tmp.length;\n\t\to += buf.write(tmp.slice(i, limit), o);\n\t\tbuf[o++] = 10;\n\t\ti = limit;\n\t}\n\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\treturn (buf.slice(0, o));\n}\n","start":1667202983825,"end":1667202983954},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\n\nvar pem;\nvar hasRequiredPem;\n\nfunction requirePem () {\n\tif (hasRequiredPem) return pem;\n\thasRequiredPem = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tpem = {\n\t\tread: read,\n\t\twrite: write\n\t};\n\n\tvar assert = require$$0();\n\tvar asn1 = require$$1();\n\tvar crypto = require$$2;\n\tvar Buffer = require$$3().Buffer;\n\tvar algs = require$$4();\n\tvar utils = require$$5();\n\tvar Key = require$$6();\n\tvar PrivateKey = require$$7();\n\n\tvar pkcs1 = require$$8();\n\tvar pkcs8 = require$$9();\n\tvar sshpriv = require$$10();\n\tvar rfc4253 = require$$11();\n\n\tvar errors = require$$12();\n\n\tvar OID_PBES2 = '1.2.840.113549.1.5.13';\n\tvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\n\n\tvar OID_TO_CIPHER = {\n\t\t'1.2.840.113549.3.7': '3des-cbc',\n\t\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\n\t\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\n\t};\n\tvar CIPHER_TO_OID = {};\n\tObject.keys(OID_TO_CIPHER).forEach(function (k) {\n\t\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\n\t});\n\n\tvar OID_TO_HASH = {\n\t\t'1.2.840.113549.2.7': 'sha1',\n\t\t'1.2.840.113549.2.9': 'sha256',\n\t\t'1.2.840.113549.2.11': 'sha512'\n\t};\n\tvar HASH_TO_OID = {};\n\tObject.keys(OID_TO_HASH).forEach(function (k) {\n\t\tHASH_TO_OID[OID_TO_HASH[k]] = k;\n\t});\n\n\t/*\n\t * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\n\t * we just take the public component of it and use that.\n\t */\n\tfunction read(buf, options, forceType) {\n\t\tvar input = buf;\n\t\tif (typeof (buf) !== 'string') {\n\t\t\tassert.buffer(buf, 'buf');\n\t\t\tbuf = buf.toString('ascii');\n\t\t}\n\n\t\tvar lines = buf.trim().split(/[\\r\\n]+/g);\n\n\t\tvar m;\n\t\tvar si = -1;\n\t\twhile (!m && si < lines.length) {\n\t\t\tm = lines[++si].match(/*JSSTYLED*/\n\t\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t\t}\n\t\tassert.ok(m, 'invalid PEM header');\n\n\t\tvar m2;\n\t\tvar ei = lines.length;\n\t\twhile (!m2 && ei > 0) {\n\t\t\tm2 = lines[--ei].match(/*JSSTYLED*/\n\t\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\n\t\t}\n\t\tassert.ok(m2, 'invalid PEM footer');\n\n\t\t/* Begin and end banners must match key type */\n\t\tassert.equal(m[2], m2[2]);\n\t\tvar type = m[2].toLowerCase();\n\n\t\tvar alg;\n\t\tif (m[1]) {\n\t\t\t/* They also must match algorithms, if given */\n\t\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\n\t\t\talg = m[1].trim();\n\t\t}\n\n\t\tlines = lines.slice(si, ei + 1);\n\n\t\tvar headers = {};\n\t\twhile (true) {\n\t\t\tlines = lines.slice(1);\n\t\t\tm = lines[0].match(/*JSSTYLED*/\n\t\t\t    /^([A-Za-z0-9-]+): (.+)$/);\n\t\t\tif (!m)\n\t\t\t\tbreak;\n\t\t\theaders[m[1].toLowerCase()] = m[2];\n\t\t}\n\n\t\t/* Chop off the first and last lines */\n\t\tlines = lines.slice(0, -1).join('');\n\t\tbuf = Buffer.from(lines, 'base64');\n\n\t\tvar cipher, key, iv;\n\t\tif (headers['proc-type']) {\n\t\t\tvar parts = headers['proc-type'].split(',');\n\t\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\n\t\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t\t}\n\t\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t\t    options.filename, 'PEM'));\n\t\t\t\t} else {\n\t\t\t\t\tparts = headers['dek-info'].split(',');\n\t\t\t\t\tassert.ok(parts.length === 2);\n\t\t\t\t\tcipher = parts[0].toLowerCase();\n\t\t\t\t\tiv = Buffer.from(parts[1], 'hex');\n\t\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\n\t\t\t\t\t    options.passphrase, 1).key;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (alg && alg.toLowerCase() === 'encrypted') {\n\t\t\tvar eder = new asn1.BerReader(buf);\n\t\t\tvar pbesEnd;\n\t\t\teder.readSequence();\n\n\t\t\teder.readSequence();\n\t\t\tpbesEnd = eder.offset + eder.length;\n\n\t\t\tvar method = eder.readOID();\n\t\t\tif (method !== OID_PBES2) {\n\t\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\n\t\t\t\t    'scheme: ' + method));\n\t\t\t}\n\n\t\t\teder.readSequence();\t/* PBES2-params */\n\n\t\t\teder.readSequence();\t/* keyDerivationFunc */\n\t\t\tvar kdfEnd = eder.offset + eder.length;\n\t\t\tvar kdfOid = eder.readOID();\n\t\t\tif (kdfOid !== OID_PBKDF2)\n\t\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\n\t\t\teder.readSequence();\n\t\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\n\t\t\tvar iterations = eder.readInt();\n\t\t\tvar hashAlg = 'sha1';\n\t\t\tif (eder.offset < kdfEnd) {\n\t\t\t\teder.readSequence();\n\t\t\t\tvar hashAlgOid = eder.readOID();\n\t\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\n\t\t\t\tif (hashAlg === undefined) {\n\t\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\n\t\t\t\t\t    hashAlgOid));\n\t\t\t\t}\n\t\t\t}\n\t\t\teder._offset = kdfEnd;\n\n\t\t\teder.readSequence();\t/* encryptionScheme */\n\t\t\tvar cipherOid = eder.readOID();\n\t\t\tcipher = OID_TO_CIPHER[cipherOid];\n\t\t\tif (cipher === undefined) {\n\t\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\n\t\t\t\t    cipherOid));\n\t\t\t}\n\t\t\tiv = eder.readString(asn1.Ber.OctetString, true);\n\n\t\t\teder._offset = pbesEnd;\n\t\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\n\n\t\t\tif (typeof (options.passphrase) === 'string') {\n\t\t\t\toptions.passphrase = Buffer.from(\n\t\t\t\t    options.passphrase, 'utf-8');\n\t\t\t}\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t    options.filename, 'PEM'));\n\t\t\t}\n\n\t\t\tvar cinfo = utils.opensshCipherInfo(cipher);\n\n\t\t\tcipher = cinfo.opensslName;\n\t\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\n\t\t\t    options.passphrase);\n\t\t\talg = undefined;\n\t\t}\n\n\t\tif (cipher && key && iv) {\n\t\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\n\t\t\tvar chunk, chunks = [];\n\t\t\tcipherStream.once('error', function (e) {\n\t\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\n\t\t\t\t\tthrow (new Error('Incorrect passphrase ' +\n\t\t\t\t\t    'supplied, could not decrypt key'));\n\t\t\t\t}\n\t\t\t\tthrow (e);\n\t\t\t});\n\t\t\tcipherStream.write(buf);\n\t\t\tcipherStream.end();\n\t\t\twhile ((chunk = cipherStream.read()) !== null)\n\t\t\t\tchunks.push(chunk);\n\t\t\tbuf = Buffer.concat(chunks);\n\t\t}\n\n\t\t/* The new OpenSSH internal format abuses PEM headers */\n\t\tif (alg && alg.toLowerCase() === 'openssh')\n\t\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\n\t\tif (alg && alg.toLowerCase() === 'ssh2')\n\t\t\treturn (rfc4253.readType(type, buf, options));\n\n\t\tvar der = new asn1.BerReader(buf);\n\t\tder.originalInput = input;\n\n\t\t/*\n\t\t * All of the PEM file types start with a sequence tag, so chop it\n\t\t * off here\n\t\t */\n\t\tder.readSequence();\n\n\t\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\n\t\tif (alg) {\n\t\t\tif (forceType)\n\t\t\t\tassert.strictEqual(forceType, 'pkcs1');\n\t\t\treturn (pkcs1.readPkcs1(alg, type, der));\n\t\t} else {\n\t\t\tif (forceType)\n\t\t\t\tassert.strictEqual(forceType, 'pkcs8');\n\t\t\treturn (pkcs8.readPkcs8(alg, type, der));\n\t\t}\n\t}\n\n\tfunction write(key, options, type) {\n\t\tassert.object(key);\n\n\t\tvar alg = {\n\t\t    'ecdsa': 'EC',\n\t\t    'rsa': 'RSA',\n\t\t    'dsa': 'DSA',\n\t\t    'ed25519': 'EdDSA'\n\t\t}[key.type];\n\t\tvar header;\n\n\t\tvar der = new asn1.BerWriter();\n\n\t\tif (PrivateKey.isPrivateKey(key)) {\n\t\t\tif (type && type === 'pkcs8') {\n\t\t\t\theader = 'PRIVATE KEY';\n\t\t\t\tpkcs8.writePkcs8(der, key);\n\t\t\t} else {\n\t\t\t\tif (type)\n\t\t\t\t\tassert.strictEqual(type, 'pkcs1');\n\t\t\t\theader = alg + ' PRIVATE KEY';\n\t\t\t\tpkcs1.writePkcs1(der, key);\n\t\t\t}\n\n\t\t} else if (Key.isKey(key)) {\n\t\t\tif (type && type === 'pkcs1') {\n\t\t\t\theader = alg + ' PUBLIC KEY';\n\t\t\t\tpkcs1.writePkcs1(der, key);\n\t\t\t} else {\n\t\t\t\tif (type)\n\t\t\t\t\tassert.strictEqual(type, 'pkcs8');\n\t\t\t\theader = 'PUBLIC KEY';\n\t\t\t\tpkcs8.writePkcs8(der, key);\n\t\t\t}\n\n\t\t} else {\n\t\t\tthrow (new Error('key is not a Key or PrivateKey'));\n\t\t}\n\n\t\tvar tmp = der.buffer.toString('base64');\n\t\tvar len = tmp.length + (tmp.length / 64) +\n\t\t    18 + 16 + header.length*2 + 10;\n\t\tvar buf = Buffer.alloc(len);\n\t\tvar o = 0;\n\t\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\n\t\tfor (var i = 0; i < tmp.length; ) {\n\t\t\tvar limit = i + 64;\n\t\t\tif (limit > tmp.length)\n\t\t\t\tlimit = tmp.length;\n\t\t\to += buf.write(tmp.slice(i, limit), o);\n\t\t\tbuf[o++] = 10;\n\t\t\ti = limit;\n\t\t}\n\t\to += buf.write('-----END ' + header + '-----\\n', o);\n\n\t\treturn (buf.slice(0, o));\n\t}\n\treturn pem;\n}\n\nexport { requirePem as __require };","start":1667202983954,"end":1667202985074,"order":"normal"}]}
