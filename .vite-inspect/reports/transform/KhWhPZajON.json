{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/forever-agent/index.js","transforms":[{"name":"vite:load-fallback","result":"module.exports = ForeverAgent\nForeverAgent.SSL = ForeverAgentSSL\n\nvar util = require('util')\n  , Agent = require('http').Agent\n  , net = require('net')\n  , tls = require('tls')\n  , AgentSSL = require('https').Agent\n  \nfunction getConnectionName(host, port) {  \n  var name = ''\n  if (typeof host === 'string') {\n    name = host + ':' + port\n  } else {\n    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\n    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')\n  }\n  return name\n}    \n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = getConnectionName(host, port)\n\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      var onIdleError = function() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy()\n    }\n  })\n\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\n\nForeverAgent.prototype.createConnection = net.createConnection\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = getConnectionName(host, port)\n  \n  if (typeof host !== 'string') {\n    var options = host\n    port = options.port\n    host = options.host\n  }\n\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s)\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1)\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name]\n    delete this.requests[name]\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free')\n  }\n}\n\nfunction ForeverAgentSSL (options) {\n  ForeverAgent.call(this, options)\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent)\n\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\nfunction createConnectionSSL (port, host, options) {\n  if (typeof port === 'object') {\n    options = port;\n  } else if (typeof host === 'object') {\n    options = host;\n  } else if (typeof options === 'object') {\n    options = options;\n  } else {\n    options = {};\n  }\n\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n\n  return tls.connect(options);\n}\n","start":1667202981867,"end":1667202982064},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$4 from \"\\u0000__vite-browser-external?commonjs-proxy\";\n\nvar foreverAgent;\nvar hasRequiredForeverAgent;\n\nfunction requireForeverAgent () {\n\tif (hasRequiredForeverAgent) return foreverAgent;\n\thasRequiredForeverAgent = 1;\n\tforeverAgent = ForeverAgent\n\tForeverAgent.SSL = ForeverAgentSSL\n\n\tvar util = require$$0()\n\t  , Agent = require$$1.Agent\n\t  , net = require$$2\n\t  , tls = require$$3\n\t  , AgentSSL = require$$4.Agent\n\t  \n\tfunction getConnectionName(host, port) {  \n\t  var name = ''\n\t  if (typeof host === 'string') {\n\t    name = host + ':' + port\n\t  } else {\n\t    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\n\t    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')\n\t  }\n\t  return name\n\t}    \n\n\tfunction ForeverAgent(options) {\n\t  var self = this\n\t  self.options = options || {}\n\t  self.requests = {}\n\t  self.sockets = {}\n\t  self.freeSockets = {}\n\t  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n\t  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n\t  self.on('free', function(socket, host, port) {\n\t    var name = getConnectionName(host, port)\n\n\t    if (self.requests[name] && self.requests[name].length) {\n\t      self.requests[name].shift().onSocket(socket)\n\t    } else if (self.sockets[name].length < self.minSockets) {\n\t      if (!self.freeSockets[name]) self.freeSockets[name] = []\n\t      self.freeSockets[name].push(socket)\n\t      \n\t      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n\t      var onIdleError = function() {\n\t        socket.destroy()\n\t      }\n\t      socket._onIdleError = onIdleError\n\t      socket.on('error', onIdleError)\n\t    } else {\n\t      // If there are no pending requests just destroy the\n\t      // socket and it will get removed from the pool. This\n\t      // gets us out of timeout issues and allows us to\n\t      // default to Connection:keep-alive.\n\t      socket.destroy()\n\t    }\n\t  })\n\n\t}\n\tutil.inherits(ForeverAgent, Agent)\n\n\tForeverAgent.defaultMinSockets = 5\n\n\n\tForeverAgent.prototype.createConnection = net.createConnection\n\tForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\n\tForeverAgent.prototype.addRequest = function(req, host, port) {\n\t  var name = getConnectionName(host, port)\n\t  \n\t  if (typeof host !== 'string') {\n\t    var options = host\n\t    port = options.port\n\t    host = options.host\n\t  }\n\n\t  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n\t    var idleSocket = this.freeSockets[name].pop()\n\t    idleSocket.removeListener('error', idleSocket._onIdleError)\n\t    delete idleSocket._onIdleError\n\t    req._reusedSocket = true\n\t    req.onSocket(idleSocket)\n\t  } else {\n\t    this.addRequestNoreuse(req, host, port)\n\t  }\n\t}\n\n\tForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n\t  if (this.sockets[name]) {\n\t    var index = this.sockets[name].indexOf(s)\n\t    if (index !== -1) {\n\t      this.sockets[name].splice(index, 1)\n\t    }\n\t  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n\t    // don't leak\n\t    delete this.sockets[name]\n\t    delete this.requests[name]\n\t  }\n\t  \n\t  if (this.freeSockets[name]) {\n\t    var index = this.freeSockets[name].indexOf(s)\n\t    if (index !== -1) {\n\t      this.freeSockets[name].splice(index, 1)\n\t      if (this.freeSockets[name].length === 0) {\n\t        delete this.freeSockets[name]\n\t      }\n\t    }\n\t  }\n\n\t  if (this.requests[name] && this.requests[name].length) {\n\t    // If we have pending requests and a socket gets closed a new one\n\t    // needs to be created to take over in the pool for the one that closed.\n\t    this.createSocket(name, host, port).emit('free')\n\t  }\n\t}\n\n\tfunction ForeverAgentSSL (options) {\n\t  ForeverAgent.call(this, options)\n\t}\n\tutil.inherits(ForeverAgentSSL, ForeverAgent)\n\n\tForeverAgentSSL.prototype.createConnection = createConnectionSSL\n\tForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\n\tfunction createConnectionSSL (port, host, options) {\n\t  if (typeof port === 'object') {\n\t    options = port;\n\t  } else if (typeof host === 'object') {\n\t    options = host;\n\t  } else if (typeof options === 'object') {\n\t    options = options;\n\t  } else {\n\t    options = {};\n\t  }\n\n\t  if (typeof port === 'number') {\n\t    options.port = port;\n\t  }\n\n\t  if (typeof host === 'string') {\n\t    options.host = host;\n\t  }\n\n\t  return tls.connect(options);\n\t}\n\treturn foreverAgent;\n}\n\nexport { requireForeverAgent as __require };","start":1667202982064,"end":1667202984819,"order":"normal"}]}
