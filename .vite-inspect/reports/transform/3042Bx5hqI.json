{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/base64-js/index.js","transforms":[{"name":"vite:load-fallback","result":"'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","start":1667202982697,"end":1667202983116},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as base64Js } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/base64-js/index.js?commonjs-exports\"\n\nvar hasRequiredBase64Js;\n\nfunction requireBase64Js () {\n\tif (hasRequiredBase64Js) return base64Js;\n\thasRequiredBase64Js = 1;\n\t'use strict'\n\n\tbase64Js.byteLength = byteLength\n\tbase64Js.toByteArray = toByteArray\n\tbase64Js.fromByteArray = fromByteArray\n\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\n\t// Support decoding URL-safe base64 strings, as Node.js does.\n\t// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\n\tfunction getLens (b64) {\n\t  var len = b64.length\n\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\n\t  // Trim off extra bytes after placeholder bytes are found\n\t  // See: https://github.com/beatgammit/base64-js/issues/42\n\t  var validLen = b64.indexOf('=')\n\t  if (validLen === -1) validLen = len\n\n\t  var placeHoldersLen = validLen === len\n\t    ? 0\n\t    : 4 - (validLen % 4)\n\n\t  return [validLen, placeHoldersLen]\n\t}\n\n\t// base64 is 4/3 + up to two characters of the original data\n\tfunction byteLength (b64) {\n\t  var lens = getLens(b64)\n\t  var validLen = lens[0]\n\t  var placeHoldersLen = lens[1]\n\t  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n\t}\n\n\tfunction _byteLength (b64, validLen, placeHoldersLen) {\n\t  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n\t}\n\n\tfunction toByteArray (b64) {\n\t  var tmp\n\t  var lens = getLens(b64)\n\t  var validLen = lens[0]\n\t  var placeHoldersLen = lens[1]\n\n\t  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n\t  var curByte = 0\n\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  var len = placeHoldersLen > 0\n\t    ? validLen - 4\n\t    : validLen\n\n\t  var i\n\t  for (i = 0; i < len; i += 4) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 18) |\n\t      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n\t      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n\t      revLookup[b64.charCodeAt(i + 3)]\n\t    arr[curByte++] = (tmp >> 16) & 0xFF\n\t    arr[curByte++] = (tmp >> 8) & 0xFF\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\n\t  if (placeHoldersLen === 2) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 2) |\n\t      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\n\t  if (placeHoldersLen === 1) {\n\t    tmp =\n\t      (revLookup[b64.charCodeAt(i)] << 10) |\n\t      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n\t      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[curByte++] = (tmp >> 8) & 0xFF\n\t    arr[curByte++] = tmp & 0xFF\n\t  }\n\n\t  return arr\n\t}\n\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] +\n\t    lookup[num >> 12 & 0x3F] +\n\t    lookup[num >> 6 & 0x3F] +\n\t    lookup[num & 0x3F]\n\t}\n\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp =\n\t      ((uint8[i] << 16) & 0xFF0000) +\n\t      ((uint8[i + 1] << 8) & 0xFF00) +\n\t      (uint8[i + 2] & 0xFF)\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    parts.push(\n\t      lookup[tmp >> 2] +\n\t      lookup[(tmp << 4) & 0x3F] +\n\t      '=='\n\t    )\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n\t    parts.push(\n\t      lookup[tmp >> 10] +\n\t      lookup[(tmp >> 4) & 0x3F] +\n\t      lookup[(tmp << 2) & 0x3F] +\n\t      '='\n\t    )\n\t  }\n\n\t  return parts.join('')\n\t}\n\treturn base64Js;\n}\n\nexport { requireBase64Js as __require };","start":1667202983117,"end":1667202983119,"order":"normal"}]}
