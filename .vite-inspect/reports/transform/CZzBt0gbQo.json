{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/request/lib/oauth.js","transforms":[{"name":"vite:load-fallback","result":"'use strict'\n\nvar url = require('url')\nvar qs = require('qs')\nvar caseless = require('caseless')\nvar uuid = require('uuid/v4')\nvar oauth = require('oauth-sign')\nvar crypto = require('crypto')\nvar Buffer = require('safe-buffer').Buffer\n\nfunction OAuth (request) {\n  this.request = request\n  this.params = null\n}\n\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n  var oa = {}\n  for (var i in _oauth) {\n    oa['oauth_' + i] = _oauth[i]\n  }\n  if (!oa.oauth_version) {\n    oa.oauth_version = '1.0'\n  }\n  if (!oa.oauth_timestamp) {\n    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()\n  }\n  if (!oa.oauth_nonce) {\n    oa.oauth_nonce = uuid().replace(/-/g, '')\n  }\n  if (!oa.oauth_signature_method) {\n    oa.oauth_signature_method = 'HMAC-SHA1'\n  }\n\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase\n  delete oa.oauth_consumer_secret\n  delete oa.oauth_private_key\n\n  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase\n  delete oa.oauth_token_secret\n\n  var realm = oa.oauth_realm\n  delete oa.oauth_realm\n  delete oa.oauth_transport_method\n\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n  oa.oauth_signature = oauth.sign(\n    oa.oauth_signature_method,\n    method,\n    baseurl,\n    params,\n    consumer_secret_or_private_key, // eslint-disable-line camelcase\n    token_secret // eslint-disable-line camelcase\n  )\n\n  if (realm) {\n    oa.realm = realm\n  }\n\n  return oa\n}\n\nOAuth.prototype.buildBodyHash = function (_oauth, body) {\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n      ' signature_method not supported with body_hash signing.'))\n  }\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(body || '')\n  var sha1 = shasum.digest('hex')\n\n  return Buffer.from(sha1, 'hex').toString('base64')\n}\n\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\n  wrap = wrap || ''\n\n  var params = Object.keys(oa).filter(function (i) {\n    return i !== 'realm' && i !== 'oauth_signature'\n  }).sort()\n\n  if (oa.realm) {\n    params.splice(0, 0, 'realm')\n  }\n  params.push('oauth_signature')\n\n  return params.map(function (i) {\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n  }).join(sep)\n}\n\nOAuth.prototype.onRequest = function (_oauth) {\n  var self = this\n  self.params = _oauth\n\n  var uri = self.request.uri || {}\n  var method = self.request.method || ''\n  var headers = caseless(self.request.headers)\n  var body = self.request.body || ''\n  var qsLib = self.request.qsLib || qs\n\n  var form\n  var query\n  var contentType = headers.get('content-type') || ''\n  var formContentType = 'application/x-www-form-urlencoded'\n  var transport = _oauth.transport_method || 'header'\n\n  if (contentType.slice(0, formContentType.length) === formContentType) {\n    contentType = formContentType\n    form = body\n  }\n  if (uri.query) {\n    query = uri.query\n  }\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n      'and content-type ' + formContentType))\n  }\n\n  if (!form && typeof _oauth.body_hash === 'boolean') {\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n  }\n\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n  switch (transport) {\n    case 'header':\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n      break\n\n    case 'query':\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n      self.request.uri = url.parse(href)\n      self.request.path = self.request.uri.path\n      break\n\n    case 'body':\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n      break\n\n    default:\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\n  }\n}\n\nexports.OAuth = OAuth\n","start":1667202981908,"end":1667202982131},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as oauth_1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/oauth.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/qs/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/caseless/index.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/uuid/v4.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/oauth-sign/index.js?commonjs-wrapped\";\nimport require$$5 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safe-buffer/index.js?commonjs-wrapped\";\n\nvar hasRequiredOauth;\n\nfunction requireOauth () {\n\tif (hasRequiredOauth) return oauth_1;\n\thasRequiredOauth = 1;\n\t'use strict'\n\n\tvar url = require$$0\n\tvar qs = require$$1()\n\tvar caseless = require$$2()\n\tvar uuid = require$$3()\n\tvar oauth = require$$4()\n\tvar crypto = require$$5\n\tvar Buffer = require$$6().Buffer\n\n\tfunction OAuth (request) {\n\t  this.request = request\n\t  this.params = null\n\t}\n\n\tOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n\t  var oa = {}\n\t  for (var i in _oauth) {\n\t    oa['oauth_' + i] = _oauth[i]\n\t  }\n\t  if (!oa.oauth_version) {\n\t    oa.oauth_version = '1.0'\n\t  }\n\t  if (!oa.oauth_timestamp) {\n\t    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()\n\t  }\n\t  if (!oa.oauth_nonce) {\n\t    oa.oauth_nonce = uuid().replace(/-/g, '')\n\t  }\n\t  if (!oa.oauth_signature_method) {\n\t    oa.oauth_signature_method = 'HMAC-SHA1'\n\t  }\n\n\t  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase\n\t  delete oa.oauth_consumer_secret\n\t  delete oa.oauth_private_key\n\n\t  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase\n\t  delete oa.oauth_token_secret\n\n\t  var realm = oa.oauth_realm\n\t  delete oa.oauth_realm\n\t  delete oa.oauth_transport_method\n\n\t  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n\t  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n\t  oa.oauth_signature = oauth.sign(\n\t    oa.oauth_signature_method,\n\t    method,\n\t    baseurl,\n\t    params,\n\t    consumer_secret_or_private_key, // eslint-disable-line camelcase\n\t    token_secret // eslint-disable-line camelcase\n\t  )\n\n\t  if (realm) {\n\t    oa.realm = realm\n\t  }\n\n\t  return oa\n\t}\n\n\tOAuth.prototype.buildBodyHash = function (_oauth, body) {\n\t  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n\t    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n\t      ' signature_method not supported with body_hash signing.'))\n\t  }\n\n\t  var shasum = crypto.createHash('sha1')\n\t  shasum.update(body || '')\n\t  var sha1 = shasum.digest('hex')\n\n\t  return Buffer.from(sha1, 'hex').toString('base64')\n\t}\n\n\tOAuth.prototype.concatParams = function (oa, sep, wrap) {\n\t  wrap = wrap || ''\n\n\t  var params = Object.keys(oa).filter(function (i) {\n\t    return i !== 'realm' && i !== 'oauth_signature'\n\t  }).sort()\n\n\t  if (oa.realm) {\n\t    params.splice(0, 0, 'realm')\n\t  }\n\t  params.push('oauth_signature')\n\n\t  return params.map(function (i) {\n\t    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n\t  }).join(sep)\n\t}\n\n\tOAuth.prototype.onRequest = function (_oauth) {\n\t  var self = this\n\t  self.params = _oauth\n\n\t  var uri = self.request.uri || {}\n\t  var method = self.request.method || ''\n\t  var headers = caseless(self.request.headers)\n\t  var body = self.request.body || ''\n\t  var qsLib = self.request.qsLib || qs\n\n\t  var form\n\t  var query\n\t  var contentType = headers.get('content-type') || ''\n\t  var formContentType = 'application/x-www-form-urlencoded'\n\t  var transport = _oauth.transport_method || 'header'\n\n\t  if (contentType.slice(0, formContentType.length) === formContentType) {\n\t    contentType = formContentType\n\t    form = body\n\t  }\n\t  if (uri.query) {\n\t    query = uri.query\n\t  }\n\t  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n\t    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n\t      'and content-type ' + formContentType))\n\t  }\n\n\t  if (!form && typeof _oauth.body_hash === 'boolean') {\n\t    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n\t  }\n\n\t  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n\t  switch (transport) {\n\t    case 'header':\n\t      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n\t      break\n\n\t    case 'query':\n\t      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n\t      self.request.uri = url.parse(href)\n\t      self.request.path = self.request.uri.path\n\t      break\n\n\t    case 'body':\n\t      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n\t      break\n\n\t    default:\n\t      self.request.emit('error', new Error('oauth: transport_method invalid'))\n\t  }\n\t}\n\n\toauth_1.OAuth = OAuth\n\treturn oauth_1;\n}\n\nexport { requireOauth as __require };","start":1667202982132,"end":1667202983710,"order":"normal"}]}
