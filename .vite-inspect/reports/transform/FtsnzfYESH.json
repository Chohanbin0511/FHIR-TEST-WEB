{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/middlewares/search.js","transforms":[{"name":"vite:load-fallback","result":"(function() {\n  var utils = require('../utils');\n\n  var type = utils.type;\n\n  var assertArray = utils.assertArray;\n\n  var assertObject = utils.assertObject;\n\n  var reduceMap = utils.reduceMap;\n\n  var identity = utils.identity;\n\n  var OPERATORS = {\n    $gt: 'gt',\n    $lt: 'lt',\n    $lte: 'lte',\n    $gte: 'gte',\n    $ge: 'ge',\n    $le: 'le'\n  };\n\n  var MODIFIERS = {\n    $asc: ':asc',\n    $desc: ':desc',\n    $exact: ':exact',\n    $missing: ':missing',\n    $null: ':missing',\n    $text: ':text'\n  };\n\n  var isOperator = function(v) {\n    return v.indexOf('$') === 0;\n  };\n\n  var expandParam = function(k, v) {\n    return reduceMap(v, function(acc, arg) {\n      var kk, o, res, vv;\n      kk = arg[0], vv = arg[1];\n      return acc.concat(kk === '$and' ? assertArray(vv).reduce((function(a, vvv) {\n        return a.concat(linearizeOne(k, vvv));\n      }), []) : kk === '$type' ? [] : isOperator(kk) ? (o = {\n        param: k\n      }, kk === '$or' ? o.value = vv : (OPERATORS[kk] ? o.operator = OPERATORS[kk] : void 0, MODIFIERS[kk] ? o.modifier = MODIFIERS[kk] : void 0, type(vv) === 'object' && vv.$or ? o.value = vv.$or : o.value = [vv]), [o]) : (v.$type ? res = \":\" + v.$type : void 0, linearizeOne(\"\" + k + (res || '') + \".\" + kk, vv)));\n    });\n  };\n\n  var handleSort = function(xs) {\n    var i, len, results, x;\n    assertArray(xs);\n    results = [];\n    for (i = 0, len = xs.length; i < len; i++) {\n      x = xs[i];\n      switch (type(x)) {\n      case 'array':\n        results.push({\n          param: '_sort',\n          value: x[0],\n          modifier: \":\" + x[1]\n        });\n        break;\n      case 'string':\n        results.push({\n          param: '_sort',\n          value: x\n        });\n        break;\n      default:\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  var handleInclude = function(includes, key) {\n    return reduceMap(includes, function(acc, arg) {\n      var k, v;\n      k = arg[0], v = arg[1];\n      return acc.concat((function() {\n        switch (type(v)) {\n        case 'array':\n          return v.map(function(x) {\n            return {\n              param: key === '$include' ? '_include' : '_revinclude',\n              value: k + \":\" + x\n            };\n          });\n        case 'string':\n          return [\n            {\n              param: key === '$include' ? '_include' : '_revinclude',\n              value: k + \":\" + v\n            }\n          ];\n        }\n      })());\n    });\n  };\n  var handleHas = function(includes, key) {\n    return reduceMap(includes, function(acc, arg) {\n      var k, v;\n      k = arg[0], v = arg[1];\n      return acc.concat((function() {\n        switch (type(v)) {\n        case 'array':\n          return v.map(function(x) {\n            return {\n              param: '_has',\n              value: k + \"=\" + x\n            };\n          });\n        case 'string':\n          return [\n            {\n              param: '_has',\n              value: k + \"=\" + v\n            }\n          ];\n        }\n      })());\n    });\n  };\n  var linearizeOne = function(k, v) {\n    if (k === '$sort') {\n      return handleSort(v);\n    } else if (k === '$has') {\n      return handleHas(v, k);\n    } else if (k === '$include' || k === '$revInclude') {\n      return handleInclude(v, k);\n    } else {\n      switch (type(v)) {\n      case 'object':\n        return expandParam(k, v);\n      case 'string':\n        return [\n          {\n            param: k,\n            value: [v]\n          }\n        ];\n      case 'number':\n        return [\n          {\n            param: k,\n            value: [v]\n          }\n        ];\n      case 'array':\n        return [\n          {\n            param: k,\n            value: [v.join(\"|\")]\n          }\n        ];\n      default:\n        throw \"could not linearizeParams \" + (type(v));\n      }\n    }\n  };\n\n  var linearizeParams = function(query) {\n    return reduceMap(query, function(acc, arg) {\n      var k, v;\n      k = arg[0], v = arg[1];\n      return acc.concat(linearizeOne(k, v));\n    });\n  };\n\n  var buildSearchParams = function(query) {\n    var p, ps, value;\n    var excludeEncode = ['_include', '_revinclude', '_has']\n    ps = (function() {\n      var i, len, ref, results;\n      ref = linearizeParams(query);\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        p = ref[i];\n        if (excludeEncode.indexOf(p.param) === -1)\n          value = encodeURIComponent(p.value);\n        else\n          value = p.value\n        results.push([p.param, p.modifier, (p.param == '_has') ? ':' : '=', p.operator, value].filter(identity).join(''));\n      }\n      return results;\n    })();\n    return ps.join(\"&\");\n  };\n\n  exports._query = linearizeParams;\n\n  exports.query = buildSearchParams;\n\n  var mw = require('./core');\n\n  exports.$SearchParams = mw.$$Attr('url', function(args){\n    var url = args.url;\n    if(args.query){\n      var queryStr = buildSearchParams(args.query);\n      return url + \"?\" + queryStr;\n    }\n    return url;\n  });\n\n\n  exports.$Paging = function(h){\n    return function(args){\n      var params = args.params || {};\n      if(args.since){params._since = args.since;}\n      if(args.count){params._count = args.count;}\n      args.params = params;\n      return h(args);\n    };\n  };\n\n\n}).call(this);\n","start":1667202704261,"end":1667202704341},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as search } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/middlewares/search.js?commonjs-exports\"\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/utils.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/middlewares/core.js?commonjs-wrapped\";\n\nvar hasRequiredSearch;\n\nfunction requireSearch () {\n\tif (hasRequiredSearch) return search;\n\thasRequiredSearch = 1;\n\t(function() {\n\t  var utils = require$$0();\n\n\t  var type = utils.type;\n\n\t  var assertArray = utils.assertArray;\n\n\t  var assertObject = utils.assertObject;\n\n\t  var reduceMap = utils.reduceMap;\n\n\t  var identity = utils.identity;\n\n\t  var OPERATORS = {\n\t    $gt: 'gt',\n\t    $lt: 'lt',\n\t    $lte: 'lte',\n\t    $gte: 'gte',\n\t    $ge: 'ge',\n\t    $le: 'le'\n\t  };\n\n\t  var MODIFIERS = {\n\t    $asc: ':asc',\n\t    $desc: ':desc',\n\t    $exact: ':exact',\n\t    $missing: ':missing',\n\t    $null: ':missing',\n\t    $text: ':text'\n\t  };\n\n\t  var isOperator = function(v) {\n\t    return v.indexOf('$') === 0;\n\t  };\n\n\t  var expandParam = function(k, v) {\n\t    return reduceMap(v, function(acc, arg) {\n\t      var kk, o, res, vv;\n\t      kk = arg[0], vv = arg[1];\n\t      return acc.concat(kk === '$and' ? assertArray(vv).reduce((function(a, vvv) {\n\t        return a.concat(linearizeOne(k, vvv));\n\t      }), []) : kk === '$type' ? [] : isOperator(kk) ? (o = {\n\t        param: k\n\t      }, kk === '$or' ? o.value = vv : (OPERATORS[kk] ? o.operator = OPERATORS[kk] : void 0, MODIFIERS[kk] ? o.modifier = MODIFIERS[kk] : void 0, type(vv) === 'object' && vv.$or ? o.value = vv.$or : o.value = [vv]), [o]) : (v.$type ? res = \":\" + v.$type : void 0, linearizeOne(\"\" + k + (res || '') + \".\" + kk, vv)));\n\t    });\n\t  };\n\n\t  var handleSort = function(xs) {\n\t    var i, len, results, x;\n\t    assertArray(xs);\n\t    results = [];\n\t    for (i = 0, len = xs.length; i < len; i++) {\n\t      x = xs[i];\n\t      switch (type(x)) {\n\t      case 'array':\n\t        results.push({\n\t          param: '_sort',\n\t          value: x[0],\n\t          modifier: \":\" + x[1]\n\t        });\n\t        break;\n\t      case 'string':\n\t        results.push({\n\t          param: '_sort',\n\t          value: x\n\t        });\n\t        break;\n\t      default:\n\t        results.push(void 0);\n\t      }\n\t    }\n\t    return results;\n\t  };\n\n\t  var handleInclude = function(includes, key) {\n\t    return reduceMap(includes, function(acc, arg) {\n\t      var k, v;\n\t      k = arg[0], v = arg[1];\n\t      return acc.concat((function() {\n\t        switch (type(v)) {\n\t        case 'array':\n\t          return v.map(function(x) {\n\t            return {\n\t              param: key === '$include' ? '_include' : '_revinclude',\n\t              value: k + \":\" + x\n\t            };\n\t          });\n\t        case 'string':\n\t          return [\n\t            {\n\t              param: key === '$include' ? '_include' : '_revinclude',\n\t              value: k + \":\" + v\n\t            }\n\t          ];\n\t        }\n\t      })());\n\t    });\n\t  };\n\t  var handleHas = function(includes, key) {\n\t    return reduceMap(includes, function(acc, arg) {\n\t      var k, v;\n\t      k = arg[0], v = arg[1];\n\t      return acc.concat((function() {\n\t        switch (type(v)) {\n\t        case 'array':\n\t          return v.map(function(x) {\n\t            return {\n\t              param: '_has',\n\t              value: k + \"=\" + x\n\t            };\n\t          });\n\t        case 'string':\n\t          return [\n\t            {\n\t              param: '_has',\n\t              value: k + \"=\" + v\n\t            }\n\t          ];\n\t        }\n\t      })());\n\t    });\n\t  };\n\t  var linearizeOne = function(k, v) {\n\t    if (k === '$sort') {\n\t      return handleSort(v);\n\t    } else if (k === '$has') {\n\t      return handleHas(v, k);\n\t    } else if (k === '$include' || k === '$revInclude') {\n\t      return handleInclude(v, k);\n\t    } else {\n\t      switch (type(v)) {\n\t      case 'object':\n\t        return expandParam(k, v);\n\t      case 'string':\n\t        return [\n\t          {\n\t            param: k,\n\t            value: [v]\n\t          }\n\t        ];\n\t      case 'number':\n\t        return [\n\t          {\n\t            param: k,\n\t            value: [v]\n\t          }\n\t        ];\n\t      case 'array':\n\t        return [\n\t          {\n\t            param: k,\n\t            value: [v.join(\"|\")]\n\t          }\n\t        ];\n\t      default:\n\t        throw \"could not linearizeParams \" + (type(v));\n\t      }\n\t    }\n\t  };\n\n\t  var linearizeParams = function(query) {\n\t    return reduceMap(query, function(acc, arg) {\n\t      var k, v;\n\t      k = arg[0], v = arg[1];\n\t      return acc.concat(linearizeOne(k, v));\n\t    });\n\t  };\n\n\t  var buildSearchParams = function(query) {\n\t    var p, ps, value;\n\t    var excludeEncode = ['_include', '_revinclude', '_has']\n\t    ps = (function() {\n\t      var i, len, ref, results;\n\t      ref = linearizeParams(query);\n\t      results = [];\n\t      for (i = 0, len = ref.length; i < len; i++) {\n\t        p = ref[i];\n\t        if (excludeEncode.indexOf(p.param) === -1)\n\t          value = encodeURIComponent(p.value);\n\t        else\n\t          value = p.value\n\t        results.push([p.param, p.modifier, (p.param == '_has') ? ':' : '=', p.operator, value].filter(identity).join(''));\n\t      }\n\t      return results;\n\t    })();\n\t    return ps.join(\"&\");\n\t  };\n\n\t  search._query = linearizeParams;\n\n\t  search.query = buildSearchParams;\n\n\t  var mw = require$$1();\n\n\t  search.$SearchParams = mw.$$Attr('url', function(args){\n\t    var url = args.url;\n\t    if(args.query){\n\t      var queryStr = buildSearchParams(args.query);\n\t      return url + \"?\" + queryStr;\n\t    }\n\t    return url;\n\t  });\n\n\n\t  search.$Paging = function(h){\n\t    return function(args){\n\t      var params = args.params || {};\n\t      if(args.since){params._since = args.since;}\n\t      if(args.count){params._count = args.count;}\n\t      args.params = params;\n\t      return h(args);\n\t    };\n\t  };\n\n\n\t}).call(commonjsHelpers.commonjsGlobal);\n\treturn search;\n}\n\nexport { requireSearch as __require };","start":1667202704342,"end":1667202704699,"order":"normal"}]}
