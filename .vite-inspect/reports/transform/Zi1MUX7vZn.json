{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\treadPkcs1: readPkcs1,\n\twrite: write,\n\twritePkcs1: writePkcs1\n};\n\nvar assert = require('assert-plus');\nvar asn1 = require('asn1');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar utils = require('../utils');\n\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar pem = require('./pem');\n\nvar pkcs8 = require('./pkcs8');\nvar readECDSACurve = pkcs8.readECDSACurve;\n\nfunction read(buf, options) {\n\treturn (pem.read(buf, options, 'pkcs1'));\n}\n\nfunction write(key, options) {\n\treturn (pem.write(key, options, 'pkcs1'));\n}\n\n/* Helper to read in a single mpint */\nfunction readMPInt(der, nm) {\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t    nm + ' is not an Integer');\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n}\n\nfunction readPkcs1(alg, type, der) {\n\tswitch (alg) {\n\tcase 'RSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1RSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1RSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'DSA':\n\t\tif (type === 'public')\n\t\t\treturn (readPkcs1DSAPublic(der));\n\t\telse if (type === 'private')\n\t\t\treturn (readPkcs1DSAPrivate(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EC':\n\tcase 'ECDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1ECDSAPrivate(der));\n\t\telse if (type === 'public')\n\t\t\treturn (readPkcs1ECDSAPublic(der));\n\t\tthrow (new Error('Unknown key type: ' + type));\n\tcase 'EDDSA':\n\tcase 'EdDSA':\n\t\tif (type === 'private')\n\t\t\treturn (readPkcs1EdDSAPrivate(der));\n\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + alg));\n\t}\n}\n\nfunction readPkcs1RSAPublic(der) {\n\t// modulus and exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'exponent');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'n', data: n }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1RSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version[0], 0);\n\n\t// modulus then public exponent\n\tvar n = readMPInt(der, 'modulus');\n\tvar e = readMPInt(der, 'public exponent');\n\tvar d = readMPInt(der, 'private exponent');\n\tvar p = readMPInt(der, 'prime1');\n\tvar q = readMPInt(der, 'prime2');\n\tvar dmodp = readMPInt(der, 'exponent1');\n\tvar dmodq = readMPInt(der, 'exponent2');\n\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'rsa',\n\t\tparts: [\n\t\t\t{ name: 'n', data: n },\n\t\t\t{ name: 'e', data: e },\n\t\t\t{ name: 'd', data: d },\n\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 0);\n\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\tvar y = readMPInt(der, 'y');\n\tvar x = readMPInt(der, 'x');\n\n\t// now, make the key\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g },\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'x', data: x }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1EdDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar k = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n\n\tder.readSequence(0xa1);\n\tvar A = utils.readBitString(der);\n\n\tvar key = {\n\t\ttype: 'ed25519',\n\t\tparts: [\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t{ name: 'k', data: k }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction readPkcs1DSAPublic(der) {\n\tvar y = readMPInt(der, 'y');\n\tvar p = readMPInt(der, 'p');\n\tvar q = readMPInt(der, 'q');\n\tvar g = readMPInt(der, 'g');\n\n\tvar key = {\n\t\ttype: 'dsa',\n\t\tparts: [\n\t\t\t{ name: 'y', data: y },\n\t\t\t{ name: 'p', data: p },\n\t\t\t{ name: 'q', data: q },\n\t\t\t{ name: 'g', data: g }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPublic(der) {\n\tder.readSequence();\n\n\tvar oid = der.readOID();\n\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n\n\tvar curveOid = der.readOID();\n\n\tvar curve;\n\tvar curves = Object.keys(algs.curves);\n\tfor (var j = 0; j < curves.length; ++j) {\n\t\tvar c = curves[j];\n\t\tvar cd = algs.curves[c];\n\t\tif (cd.pkcs8oid === curveOid) {\n\t\t\tcurve = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert.string(curve, 'a known ECDSA named curve');\n\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q }\n\t\t]\n\t};\n\n\treturn (new Key(key));\n}\n\nfunction readPkcs1ECDSAPrivate(der) {\n\tvar version = readMPInt(der, 'version');\n\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t// private key\n\tvar d = der.readString(asn1.Ber.OctetString, true);\n\n\tder.readSequence(0xa0);\n\tvar curve = readECDSACurve(der);\n\tassert.string(curve, 'a known elliptic curve');\n\n\tder.readSequence(0xa1);\n\tvar Q = der.readString(asn1.Ber.BitString, true);\n\tQ = utils.ecNormalize(Q);\n\n\tvar key = {\n\t\ttype: 'ecdsa',\n\t\tparts: [\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t{ name: 'Q', data: Q },\n\t\t\t{ name: 'd', data: d }\n\t\t]\n\t};\n\n\treturn (new PrivateKey(key));\n}\n\nfunction writePkcs1(der, key) {\n\tder.startSequence();\n\n\tswitch (key.type) {\n\tcase 'rsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1RSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1RSAPublic(der, key);\n\t\tbreak;\n\tcase 'dsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1DSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1DSAPublic(der, key);\n\t\tbreak;\n\tcase 'ecdsa':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1ECDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1ECDSAPublic(der, key);\n\t\tbreak;\n\tcase 'ed25519':\n\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\twritePkcs1EdDSAPrivate(der, key);\n\t\telse\n\t\t\twritePkcs1EdDSAPublic(der, key);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error('Unknown key algo: ' + key.type));\n\t}\n\n\tder.endSequence();\n}\n\nfunction writePkcs1RSAPublic(der, key) {\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1RSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tif (!key.part.dmodp || !key.part.dmodq)\n\t\tutils.addRSAMissing(key);\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPrivate(der, key) {\n\tvar ver = Buffer.from([0]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPublic(der, key) {\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1ECDSAPublic(der, key) {\n\tder.startSequence();\n\n\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\n\tder.endSequence();\n\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs1ECDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tvar curve = key.part.curve.data.toString();\n\tvar curveOid = algs.curves[curve].pkcs8oid;\n\tassert.string(curveOid, 'a known ECDSA named curve');\n\tder.writeOID(curveOid);\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\tder.writeBuffer(Q, asn1.Ber.BitString);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPrivate(der, key) {\n\tvar ver = Buffer.from([1]);\n\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n\n\tder.startSequence(0xa0);\n\tder.writeOID('1.3.101.112');\n\tder.endSequence();\n\n\tder.startSequence(0xa1);\n\tutils.writeBitString(der, key.part.A.data);\n\tder.endSequence();\n}\n\nfunction writePkcs1EdDSAPublic(der, key) {\n\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\n}\n","start":1667202706603,"end":1667202706764},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\n\nvar pkcs1;\nvar hasRequiredPkcs1;\n\nfunction requirePkcs1 () {\n\tif (hasRequiredPkcs1) return pkcs1;\n\thasRequiredPkcs1 = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tpkcs1 = {\n\t\tread: read,\n\t\treadPkcs1: readPkcs1,\n\t\twrite: write,\n\t\twritePkcs1: writePkcs1\n\t};\n\n\tvar assert = require$$0();\n\tvar asn1 = require$$1();\n\tvar Buffer = require$$2().Buffer;\n\tvar algs = require$$3();\n\tvar utils = require$$4();\n\n\tvar Key = require$$5();\n\tvar PrivateKey = require$$6();\n\tvar pem = require$$7();\n\n\tvar pkcs8 = require$$8();\n\tvar readECDSACurve = pkcs8.readECDSACurve;\n\n\tfunction read(buf, options) {\n\t\treturn (pem.read(buf, options, 'pkcs1'));\n\t}\n\n\tfunction write(key, options) {\n\t\treturn (pem.write(key, options, 'pkcs1'));\n\t}\n\n\t/* Helper to read in a single mpint */\n\tfunction readMPInt(der, nm) {\n\t\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t\t    nm + ' is not an Integer');\n\t\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n\t}\n\n\tfunction readPkcs1(alg, type, der) {\n\t\tswitch (alg) {\n\t\tcase 'RSA':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs1RSAPublic(der));\n\t\t\telse if (type === 'private')\n\t\t\t\treturn (readPkcs1RSAPrivate(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'DSA':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs1DSAPublic(der));\n\t\t\telse if (type === 'private')\n\t\t\t\treturn (readPkcs1DSAPrivate(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'EC':\n\t\tcase 'ECDSA':\n\t\t\tif (type === 'private')\n\t\t\t\treturn (readPkcs1ECDSAPrivate(der));\n\t\t\telse if (type === 'public')\n\t\t\t\treturn (readPkcs1ECDSAPublic(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'EDDSA':\n\t\tcase 'EdDSA':\n\t\t\tif (type === 'private')\n\t\t\t\treturn (readPkcs1EdDSAPrivate(der));\n\t\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown key algo: ' + alg));\n\t\t}\n\t}\n\n\tfunction readPkcs1RSAPublic(der) {\n\t\t// modulus and exponent\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'exponent');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'n', data: n }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1RSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version[0], 0);\n\n\t\t// modulus then public exponent\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'public exponent');\n\t\tvar d = readMPInt(der, 'private exponent');\n\t\tvar p = readMPInt(der, 'prime1');\n\t\tvar q = readMPInt(der, 'prime2');\n\t\tvar dmodp = readMPInt(der, 'exponent1');\n\t\tvar dmodq = readMPInt(der, 'exponent2');\n\t\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'n', data: n },\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'd', data: d },\n\t\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1DSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 0);\n\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\t\tvar y = readMPInt(der, 'y');\n\t\tvar x = readMPInt(der, 'x');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g },\n\t\t\t\t{ name: 'y', data: y },\n\t\t\t\t{ name: 'x', data: x }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1EdDSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t\t// private key\n\t\tvar k = der.readString(asn1.Ber.OctetString, true);\n\n\t\tder.readSequence(0xa0);\n\t\tvar oid = der.readOID();\n\t\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n\n\t\tder.readSequence(0xa1);\n\t\tvar A = utils.readBitString(der);\n\n\t\tvar key = {\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t\t{ name: 'k', data: k }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1DSAPublic(der) {\n\t\tvar y = readMPInt(der, 'y');\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'y', data: y },\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1ECDSAPublic(der) {\n\t\tder.readSequence();\n\n\t\tvar oid = der.readOID();\n\t\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n\n\t\tvar curveOid = der.readOID();\n\n\t\tvar curve;\n\t\tvar curves = Object.keys(algs.curves);\n\t\tfor (var j = 0; j < curves.length; ++j) {\n\t\t\tvar c = curves[j];\n\t\t\tvar cd = algs.curves[c];\n\t\t\tif (cd.pkcs8oid === curveOid) {\n\t\t\t\tcurve = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert.string(curve, 'a known ECDSA named curve');\n\n\t\tvar Q = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{ name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1ECDSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t\t// private key\n\t\tvar d = der.readString(asn1.Ber.OctetString, true);\n\n\t\tder.readSequence(0xa0);\n\t\tvar curve = readECDSACurve(der);\n\t\tassert.string(curve, 'a known elliptic curve');\n\n\t\tder.readSequence(0xa1);\n\t\tvar Q = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{ name: 'Q', data: Q },\n\t\t\t\t{ name: 'd', data: d }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction writePkcs1(der, key) {\n\t\tder.startSequence();\n\n\t\tswitch (key.type) {\n\t\tcase 'rsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1RSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1RSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'dsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1DSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1DSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'ecdsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1ECDSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1ECDSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'ed25519':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1EdDSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1EdDSAPublic(der, key);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown key algo: ' + key.type));\n\t\t}\n\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1RSAPublic(der, key) {\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1RSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([0]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tif (!key.part.dmodp || !key.part.dmodq)\n\t\t\tutils.addRSAMissing(key);\n\t\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1DSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([0]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1DSAPublic(der, key) {\n\t\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1ECDSAPublic(der, key) {\n\t\tder.startSequence();\n\n\t\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\n\t\tvar curve = key.part.curve.data.toString();\n\t\tvar curveOid = algs.curves[curve].pkcs8oid;\n\t\tassert.string(curveOid, 'a known ECDSA named curve');\n\t\tder.writeOID(curveOid);\n\n\t\tder.endSequence();\n\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t}\n\n\tfunction writePkcs1ECDSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([1]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\t\tder.startSequence(0xa0);\n\t\tvar curve = key.part.curve.data.toString();\n\t\tvar curveOid = algs.curves[curve].pkcs8oid;\n\t\tassert.string(curveOid, 'a known ECDSA named curve');\n\t\tder.writeOID(curveOid);\n\t\tder.endSequence();\n\n\t\tder.startSequence(0xa1);\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1EdDSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([1]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n\n\t\tder.startSequence(0xa0);\n\t\tder.writeOID('1.3.101.112');\n\t\tder.endSequence();\n\n\t\tder.startSequence(0xa1);\n\t\tutils.writeBitString(der, key.part.A.data);\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1EdDSAPublic(der, key) {\n\t\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\n\t}\n\treturn pkcs1;\n}\n\nexport { requirePkcs1 as __require };","start":1667202706765,"end":1667202707660,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\n\nvar pkcs1;\nvar hasRequiredPkcs1;\n\nfunction requirePkcs1 () {\n\tif (hasRequiredPkcs1) return pkcs1;\n\thasRequiredPkcs1 = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tpkcs1 = {\n\t\tread: read,\n\t\treadPkcs1: readPkcs1,\n\t\twrite: write,\n\t\twritePkcs1: writePkcs1\n\t};\n\n\tvar assert = require$$0();\n\tvar asn1 = require$$1();\n\tvar Buffer = require$$2().Buffer;\n\tvar algs = require$$3();\n\tvar utils = require$$4();\n\n\tvar Key = require$$5();\n\tvar PrivateKey = require$$6();\n\tvar pem = require$$7();\n\n\tvar pkcs8 = require$$8();\n\tvar readECDSACurve = pkcs8.readECDSACurve;\n\n\tfunction read(buf, options) {\n\t\treturn (pem.read(buf, options, 'pkcs1'));\n\t}\n\n\tfunction write(key, options) {\n\t\treturn (pem.write(key, options, 'pkcs1'));\n\t}\n\n\t/* Helper to read in a single mpint */\n\tfunction readMPInt(der, nm) {\n\t\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\n\t\t    nm + ' is not an Integer');\n\t\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\n\t}\n\n\tfunction readPkcs1(alg, type, der) {\n\t\tswitch (alg) {\n\t\tcase 'RSA':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs1RSAPublic(der));\n\t\t\telse if (type === 'private')\n\t\t\t\treturn (readPkcs1RSAPrivate(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'DSA':\n\t\t\tif (type === 'public')\n\t\t\t\treturn (readPkcs1DSAPublic(der));\n\t\t\telse if (type === 'private')\n\t\t\t\treturn (readPkcs1DSAPrivate(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'EC':\n\t\tcase 'ECDSA':\n\t\t\tif (type === 'private')\n\t\t\t\treturn (readPkcs1ECDSAPrivate(der));\n\t\t\telse if (type === 'public')\n\t\t\t\treturn (readPkcs1ECDSAPublic(der));\n\t\t\tthrow (new Error('Unknown key type: ' + type));\n\t\tcase 'EDDSA':\n\t\tcase 'EdDSA':\n\t\t\tif (type === 'private')\n\t\t\t\treturn (readPkcs1EdDSAPrivate(der));\n\t\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown key algo: ' + alg));\n\t\t}\n\t}\n\n\tfunction readPkcs1RSAPublic(der) {\n\t\t// modulus and exponent\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'exponent');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'n', data: n }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1RSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version[0], 0);\n\n\t\t// modulus then public exponent\n\t\tvar n = readMPInt(der, 'modulus');\n\t\tvar e = readMPInt(der, 'public exponent');\n\t\tvar d = readMPInt(der, 'private exponent');\n\t\tvar p = readMPInt(der, 'prime1');\n\t\tvar q = readMPInt(der, 'prime2');\n\t\tvar dmodp = readMPInt(der, 'exponent1');\n\t\tvar dmodq = readMPInt(der, 'exponent2');\n\t\tvar iqmp = readMPInt(der, 'iqmp');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'rsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'n', data: n },\n\t\t\t\t{ name: 'e', data: e },\n\t\t\t\t{ name: 'd', data: d },\n\t\t\t\t{ name: 'iqmp', data: iqmp },\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'dmodp', data: dmodp },\n\t\t\t\t{ name: 'dmodq', data: dmodq }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1DSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 0);\n\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\t\tvar y = readMPInt(der, 'y');\n\t\tvar x = readMPInt(der, 'x');\n\n\t\t// now, make the key\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g },\n\t\t\t\t{ name: 'y', data: y },\n\t\t\t\t{ name: 'x', data: x }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1EdDSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t\t// private key\n\t\tvar k = der.readString(asn1.Ber.OctetString, true);\n\n\t\tder.readSequence(0xa0);\n\t\tvar oid = der.readOID();\n\t\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n\n\t\tder.readSequence(0xa1);\n\t\tvar A = utils.readBitString(der);\n\n\t\tvar key = {\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\n\t\t\t\t{ name: 'k', data: k }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction readPkcs1DSAPublic(der) {\n\t\tvar y = readMPInt(der, 'y');\n\t\tvar p = readMPInt(der, 'p');\n\t\tvar q = readMPInt(der, 'q');\n\t\tvar g = readMPInt(der, 'g');\n\n\t\tvar key = {\n\t\t\ttype: 'dsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'y', data: y },\n\t\t\t\t{ name: 'p', data: p },\n\t\t\t\t{ name: 'q', data: q },\n\t\t\t\t{ name: 'g', data: g }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1ECDSAPublic(der) {\n\t\tder.readSequence();\n\n\t\tvar oid = der.readOID();\n\t\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n\n\t\tvar curveOid = der.readOID();\n\n\t\tvar curve;\n\t\tvar curves = Object.keys(algs.curves);\n\t\tfor (var j = 0; j < curves.length; ++j) {\n\t\t\tvar c = curves[j];\n\t\t\tvar cd = algs.curves[c];\n\t\t\tif (cd.pkcs8oid === curveOid) {\n\t\t\t\tcurve = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert.string(curve, 'a known ECDSA named curve');\n\n\t\tvar Q = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{ name: 'Q', data: Q }\n\t\t\t]\n\t\t};\n\n\t\treturn (new Key(key));\n\t}\n\n\tfunction readPkcs1ECDSAPrivate(der) {\n\t\tvar version = readMPInt(der, 'version');\n\t\tassert.strictEqual(version.readUInt8(0), 1);\n\n\t\t// private key\n\t\tvar d = der.readString(asn1.Ber.OctetString, true);\n\n\t\tder.readSequence(0xa0);\n\t\tvar curve = readECDSACurve(der);\n\t\tassert.string(curve, 'a known elliptic curve');\n\n\t\tder.readSequence(0xa1);\n\t\tvar Q = der.readString(asn1.Ber.BitString, true);\n\t\tQ = utils.ecNormalize(Q);\n\n\t\tvar key = {\n\t\t\ttype: 'ecdsa',\n\t\t\tparts: [\n\t\t\t\t{ name: 'curve', data: Buffer.from(curve) },\n\t\t\t\t{ name: 'Q', data: Q },\n\t\t\t\t{ name: 'd', data: d }\n\t\t\t]\n\t\t};\n\n\t\treturn (new PrivateKey(key));\n\t}\n\n\tfunction writePkcs1(der, key) {\n\t\tder.startSequence();\n\n\t\tswitch (key.type) {\n\t\tcase 'rsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1RSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1RSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'dsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1DSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1DSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'ecdsa':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1ECDSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1ECDSAPublic(der, key);\n\t\t\tbreak;\n\t\tcase 'ed25519':\n\t\t\tif (PrivateKey.isPrivateKey(key))\n\t\t\t\twritePkcs1EdDSAPrivate(der, key);\n\t\t\telse\n\t\t\t\twritePkcs1EdDSAPublic(der, key);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unknown key algo: ' + key.type));\n\t\t}\n\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1RSAPublic(der, key) {\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1RSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([0]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tif (!key.part.dmodp || !key.part.dmodq)\n\t\t\tutils.addRSAMissing(key);\n\t\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1DSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([0]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1DSAPublic(der, key) {\n\t\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n\t\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n\t}\n\n\tfunction writePkcs1ECDSAPublic(der, key) {\n\t\tder.startSequence();\n\n\t\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\n\t\tvar curve = key.part.curve.data.toString();\n\t\tvar curveOid = algs.curves[curve].pkcs8oid;\n\t\tassert.string(curveOid, 'a known ECDSA named curve');\n\t\tder.writeOID(curveOid);\n\n\t\tder.endSequence();\n\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t}\n\n\tfunction writePkcs1ECDSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([1]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n\n\t\tder.startSequence(0xa0);\n\t\tvar curve = key.part.curve.data.toString();\n\t\tvar curveOid = algs.curves[curve].pkcs8oid;\n\t\tassert.string(curveOid, 'a known ECDSA named curve');\n\t\tder.writeOID(curveOid);\n\t\tder.endSequence();\n\n\t\tder.startSequence(0xa1);\n\t\tvar Q = utils.ecNormalize(key.part.Q.data, true);\n\t\tder.writeBuffer(Q, asn1.Ber.BitString);\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1EdDSAPrivate(der, key) {\n\t\tvar ver = Buffer.from([1]);\n\t\tder.writeBuffer(ver, asn1.Ber.Integer);\n\n\t\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n\n\t\tder.startSequence(0xa0);\n\t\tder.writeOID('1.3.101.112');\n\t\tder.endSequence();\n\n\t\tder.startSequence(0xa1);\n\t\tutils.writeBitString(der, key.part.A.data);\n\t\tder.endSequence();\n\t}\n\n\tfunction writePkcs1EdDSAPublic(der, key) {\n\t\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\n\t}\n\treturn pkcs1;\n}\n\nexport { requirePkcs1 as __require };","start":1667202707688,"end":1667202707709,"order":"normal"}]}
