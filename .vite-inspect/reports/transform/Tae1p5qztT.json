{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/psl/index.js","transforms":[{"name":"vite:load-fallback","result":"/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */\n'use strict';\n\n\nvar Punycode = require('punycode');\n\n\nvar internals = {};\n\n\n//\n// Read rules from file.\n//\ninternals.rules = require('./data/rules.json').map(function (rule) {\n\n  return {\n    rule: rule,\n    suffix: rule.replace(/^(\\*\\.|\\!)/, ''),\n    punySuffix: -1,\n    wildcard: rule.charAt(0) === '*',\n    exception: rule.charAt(0) === '!'\n  };\n});\n\n\n//\n// Check is given string ends with `suffix`.\n//\ninternals.endsWith = function (str, suffix) {\n\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n};\n\n\n//\n// Find rule for a given domain.\n//\ninternals.findRule = function (domain) {\n\n  var punyDomain = Punycode.toASCII(domain);\n  return internals.rules.reduce(function (memo, rule) {\n\n    if (rule.punySuffix === -1){\n      rule.punySuffix = Punycode.toASCII(rule.suffix);\n    }\n    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {\n      return memo;\n    }\n    // This has been commented out as it never seems to run. This is because\n    // sub tlds always appear after their parents and we never find a shorter\n    // match.\n    //if (memo) {\n    //  var memoSuffix = Punycode.toASCII(memo.suffix);\n    //  if (memoSuffix.length >= punySuffix.length) {\n    //    return memo;\n    //  }\n    //}\n    return rule;\n  }, null);\n};\n\n\n//\n// Error codes and messages.\n//\nexports.errorCodes = {\n  DOMAIN_TOO_SHORT: 'Domain name too short.',\n  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',\n  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',\n  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',\n  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',\n  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',\n  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'\n};\n\n\n//\n// Validate domain name and throw if not valid.\n//\n// From wikipedia:\n//\n// Hostnames are composed of series of labels concatenated with dots, as are all\n// domain names. Each label must be between 1 and 63 characters long, and the\n// entire hostname (including the delimiting dots) has a maximum of 255 chars.\n//\n// Allowed chars:\n//\n// * `a-z`\n// * `0-9`\n// * `-` but not as a starting or ending character\n// * `.` as a separator for the textual portions of a domain name\n//\n// * http://en.wikipedia.org/wiki/Domain_name\n// * http://en.wikipedia.org/wiki/Hostname\n//\ninternals.validate = function (input) {\n\n  // Before we can validate we need to take care of IDNs with unicode chars.\n  var ascii = Punycode.toASCII(input);\n\n  if (ascii.length < 1) {\n    return 'DOMAIN_TOO_SHORT';\n  }\n  if (ascii.length > 255) {\n    return 'DOMAIN_TOO_LONG';\n  }\n\n  // Check each part's length and allowed chars.\n  var labels = ascii.split('.');\n  var label;\n\n  for (var i = 0; i < labels.length; ++i) {\n    label = labels[i];\n    if (!label.length) {\n      return 'LABEL_TOO_SHORT';\n    }\n    if (label.length > 63) {\n      return 'LABEL_TOO_LONG';\n    }\n    if (label.charAt(0) === '-') {\n      return 'LABEL_STARTS_WITH_DASH';\n    }\n    if (label.charAt(label.length - 1) === '-') {\n      return 'LABEL_ENDS_WITH_DASH';\n    }\n    if (!/^[a-z0-9\\-]+$/.test(label)) {\n      return 'LABEL_INVALID_CHARS';\n    }\n  }\n};\n\n\n//\n// Public API\n//\n\n\n//\n// Parse domain.\n//\nexports.parse = function (input) {\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Domain name must be a string.');\n  }\n\n  // Force domain to lowercase.\n  var domain = input.slice(0).toLowerCase();\n\n  // Handle FQDN.\n  // TODO: Simply remove trailing dot?\n  if (domain.charAt(domain.length - 1) === '.') {\n    domain = domain.slice(0, domain.length - 1);\n  }\n\n  // Validate and sanitise input.\n  var error = internals.validate(domain);\n  if (error) {\n    return {\n      input: input,\n      error: {\n        message: exports.errorCodes[error],\n        code: error\n      }\n    };\n  }\n\n  var parsed = {\n    input: input,\n    tld: null,\n    sld: null,\n    domain: null,\n    subdomain: null,\n    listed: false\n  };\n\n  var domainParts = domain.split('.');\n\n  // Non-Internet TLD\n  if (domainParts[domainParts.length - 1] === 'local') {\n    return parsed;\n  }\n\n  var handlePunycode = function () {\n\n    if (!/xn--/.test(domain)) {\n      return parsed;\n    }\n    if (parsed.domain) {\n      parsed.domain = Punycode.toASCII(parsed.domain);\n    }\n    if (parsed.subdomain) {\n      parsed.subdomain = Punycode.toASCII(parsed.subdomain);\n    }\n    return parsed;\n  };\n\n  var rule = internals.findRule(domain);\n\n  // Unlisted tld.\n  if (!rule) {\n    if (domainParts.length < 2) {\n      return parsed;\n    }\n    parsed.tld = domainParts.pop();\n    parsed.sld = domainParts.pop();\n    parsed.domain = [parsed.sld, parsed.tld].join('.');\n    if (domainParts.length) {\n      parsed.subdomain = domainParts.pop();\n    }\n    return handlePunycode();\n  }\n\n  // At this point we know the public suffix is listed.\n  parsed.listed = true;\n\n  var tldParts = rule.suffix.split('.');\n  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);\n\n  if (rule.exception) {\n    privateParts.push(tldParts.shift());\n  }\n\n  parsed.tld = tldParts.join('.');\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  if (rule.wildcard) {\n    tldParts.unshift(privateParts.pop());\n    parsed.tld = tldParts.join('.');\n  }\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  parsed.sld = privateParts.pop();\n  parsed.domain = [parsed.sld,  parsed.tld].join('.');\n\n  if (privateParts.length) {\n    parsed.subdomain = privateParts.join('.');\n  }\n\n  return handlePunycode();\n};\n\n\n//\n// Get domain.\n//\nexports.get = function (domain) {\n\n  if (!domain) {\n    return null;\n  }\n  return exports.parse(domain).domain || null;\n};\n\n\n//\n// Check whether domain belongs to a known public suffix.\n//\nexports.isValid = function (domain) {\n\n  var parsed = exports.parse(domain);\n  return Boolean(parsed.domain && parsed.listed);\n};\n","start":1667202705507,"end":1667202705596},{"name":"commonjs","result":"/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as psl } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/psl/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/punycode/punycode.es6.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/psl/data/rules.json?commonjs-proxy\";\n\nvar hasRequiredPsl;\n\nfunction requirePsl () {\n\tif (hasRequiredPsl) return psl;\n\thasRequiredPsl = 1;\n\t(function (exports) {\n\t\t'use strict';\n\n\n\t\tvar Punycode = require$$0;\n\n\n\t\tvar internals = {};\n\n\n\t\t//\n\t\t// Read rules from file.\n\t\t//\n\t\tinternals.rules = require$$1.map(function (rule) {\n\n\t\t  return {\n\t\t    rule: rule,\n\t\t    suffix: rule.replace(/^(\\*\\.|\\!)/, ''),\n\t\t    punySuffix: -1,\n\t\t    wildcard: rule.charAt(0) === '*',\n\t\t    exception: rule.charAt(0) === '!'\n\t\t  };\n\t\t});\n\n\n\t\t//\n\t\t// Check is given string ends with `suffix`.\n\t\t//\n\t\tinternals.endsWith = function (str, suffix) {\n\n\t\t  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n\t\t};\n\n\n\t\t//\n\t\t// Find rule for a given domain.\n\t\t//\n\t\tinternals.findRule = function (domain) {\n\n\t\t  var punyDomain = Punycode.toASCII(domain);\n\t\t  return internals.rules.reduce(function (memo, rule) {\n\n\t\t    if (rule.punySuffix === -1){\n\t\t      rule.punySuffix = Punycode.toASCII(rule.suffix);\n\t\t    }\n\t\t    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {\n\t\t      return memo;\n\t\t    }\n\t\t    // This has been commented out as it never seems to run. This is because\n\t\t    // sub tlds always appear after their parents and we never find a shorter\n\t\t    // match.\n\t\t    //if (memo) {\n\t\t    //  var memoSuffix = Punycode.toASCII(memo.suffix);\n\t\t    //  if (memoSuffix.length >= punySuffix.length) {\n\t\t    //    return memo;\n\t\t    //  }\n\t\t    //}\n\t\t    return rule;\n\t\t  }, null);\n\t\t};\n\n\n\t\t//\n\t\t// Error codes and messages.\n\t\t//\n\t\texports.errorCodes = {\n\t\t  DOMAIN_TOO_SHORT: 'Domain name too short.',\n\t\t  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',\n\t\t  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',\n\t\t  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',\n\t\t  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',\n\t\t  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',\n\t\t  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'\n\t\t};\n\n\n\t\t//\n\t\t// Validate domain name and throw if not valid.\n\t\t//\n\t\t// From wikipedia:\n\t\t//\n\t\t// Hostnames are composed of series of labels concatenated with dots, as are all\n\t\t// domain names. Each label must be between 1 and 63 characters long, and the\n\t\t// entire hostname (including the delimiting dots) has a maximum of 255 chars.\n\t\t//\n\t\t// Allowed chars:\n\t\t//\n\t\t// * `a-z`\n\t\t// * `0-9`\n\t\t// * `-` but not as a starting or ending character\n\t\t// * `.` as a separator for the textual portions of a domain name\n\t\t//\n\t\t// * http://en.wikipedia.org/wiki/Domain_name\n\t\t// * http://en.wikipedia.org/wiki/Hostname\n\t\t//\n\t\tinternals.validate = function (input) {\n\n\t\t  // Before we can validate we need to take care of IDNs with unicode chars.\n\t\t  var ascii = Punycode.toASCII(input);\n\n\t\t  if (ascii.length < 1) {\n\t\t    return 'DOMAIN_TOO_SHORT';\n\t\t  }\n\t\t  if (ascii.length > 255) {\n\t\t    return 'DOMAIN_TOO_LONG';\n\t\t  }\n\n\t\t  // Check each part's length and allowed chars.\n\t\t  var labels = ascii.split('.');\n\t\t  var label;\n\n\t\t  for (var i = 0; i < labels.length; ++i) {\n\t\t    label = labels[i];\n\t\t    if (!label.length) {\n\t\t      return 'LABEL_TOO_SHORT';\n\t\t    }\n\t\t    if (label.length > 63) {\n\t\t      return 'LABEL_TOO_LONG';\n\t\t    }\n\t\t    if (label.charAt(0) === '-') {\n\t\t      return 'LABEL_STARTS_WITH_DASH';\n\t\t    }\n\t\t    if (label.charAt(label.length - 1) === '-') {\n\t\t      return 'LABEL_ENDS_WITH_DASH';\n\t\t    }\n\t\t    if (!/^[a-z0-9\\-]+$/.test(label)) {\n\t\t      return 'LABEL_INVALID_CHARS';\n\t\t    }\n\t\t  }\n\t\t};\n\n\n\t\t//\n\t\t// Public API\n\t\t//\n\n\n\t\t//\n\t\t// Parse domain.\n\t\t//\n\t\texports.parse = function (input) {\n\n\t\t  if (typeof input !== 'string') {\n\t\t    throw new TypeError('Domain name must be a string.');\n\t\t  }\n\n\t\t  // Force domain to lowercase.\n\t\t  var domain = input.slice(0).toLowerCase();\n\n\t\t  // Handle FQDN.\n\t\t  // TODO: Simply remove trailing dot?\n\t\t  if (domain.charAt(domain.length - 1) === '.') {\n\t\t    domain = domain.slice(0, domain.length - 1);\n\t\t  }\n\n\t\t  // Validate and sanitise input.\n\t\t  var error = internals.validate(domain);\n\t\t  if (error) {\n\t\t    return {\n\t\t      input: input,\n\t\t      error: {\n\t\t        message: exports.errorCodes[error],\n\t\t        code: error\n\t\t      }\n\t\t    };\n\t\t  }\n\n\t\t  var parsed = {\n\t\t    input: input,\n\t\t    tld: null,\n\t\t    sld: null,\n\t\t    domain: null,\n\t\t    subdomain: null,\n\t\t    listed: false\n\t\t  };\n\n\t\t  var domainParts = domain.split('.');\n\n\t\t  // Non-Internet TLD\n\t\t  if (domainParts[domainParts.length - 1] === 'local') {\n\t\t    return parsed;\n\t\t  }\n\n\t\t  var handlePunycode = function () {\n\n\t\t    if (!/xn--/.test(domain)) {\n\t\t      return parsed;\n\t\t    }\n\t\t    if (parsed.domain) {\n\t\t      parsed.domain = Punycode.toASCII(parsed.domain);\n\t\t    }\n\t\t    if (parsed.subdomain) {\n\t\t      parsed.subdomain = Punycode.toASCII(parsed.subdomain);\n\t\t    }\n\t\t    return parsed;\n\t\t  };\n\n\t\t  var rule = internals.findRule(domain);\n\n\t\t  // Unlisted tld.\n\t\t  if (!rule) {\n\t\t    if (domainParts.length < 2) {\n\t\t      return parsed;\n\t\t    }\n\t\t    parsed.tld = domainParts.pop();\n\t\t    parsed.sld = domainParts.pop();\n\t\t    parsed.domain = [parsed.sld, parsed.tld].join('.');\n\t\t    if (domainParts.length) {\n\t\t      parsed.subdomain = domainParts.pop();\n\t\t    }\n\t\t    return handlePunycode();\n\t\t  }\n\n\t\t  // At this point we know the public suffix is listed.\n\t\t  parsed.listed = true;\n\n\t\t  var tldParts = rule.suffix.split('.');\n\t\t  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);\n\n\t\t  if (rule.exception) {\n\t\t    privateParts.push(tldParts.shift());\n\t\t  }\n\n\t\t  parsed.tld = tldParts.join('.');\n\n\t\t  if (!privateParts.length) {\n\t\t    return handlePunycode();\n\t\t  }\n\n\t\t  if (rule.wildcard) {\n\t\t    tldParts.unshift(privateParts.pop());\n\t\t    parsed.tld = tldParts.join('.');\n\t\t  }\n\n\t\t  if (!privateParts.length) {\n\t\t    return handlePunycode();\n\t\t  }\n\n\t\t  parsed.sld = privateParts.pop();\n\t\t  parsed.domain = [parsed.sld,  parsed.tld].join('.');\n\n\t\t  if (privateParts.length) {\n\t\t    parsed.subdomain = privateParts.join('.');\n\t\t  }\n\n\t\t  return handlePunycode();\n\t\t};\n\n\n\t\t//\n\t\t// Get domain.\n\t\t//\n\t\texports.get = function (domain) {\n\n\t\t  if (!domain) {\n\t\t    return null;\n\t\t  }\n\t\t  return exports.parse(domain).domain || null;\n\t\t};\n\n\n\t\t//\n\t\t// Check whether domain belongs to a known public suffix.\n\t\t//\n\t\texports.isValid = function (domain) {\n\n\t\t  var parsed = exports.parse(domain);\n\t\t  return Boolean(parsed.domain && parsed.listed);\n\t\t};\n} (psl));\n\treturn psl;\n}\n\nexport { requirePsl as __require };","start":1667202705597,"end":1667202706298,"order":"normal"}]}
