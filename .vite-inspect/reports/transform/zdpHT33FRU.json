{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2015 Joyent, Inc.\n\nmodule.exports = Signature;\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('./algs');\nvar crypto = require('crypto');\nvar errs = require('./errors');\nvar utils = require('./utils');\nvar asn1 = require('asn1');\nvar SSHBuffer = require('./ssh-buffer');\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar SignatureParseError = errs.SignatureParseError;\n\nfunction Signature(opts) {\n\tassert.object(opts, 'options');\n\tassert.arrayOfObject(opts.parts, 'options.parts');\n\tassert.string(opts.type, 'options.type');\n\n\tvar partLookup = {};\n\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\tvar part = opts.parts[i];\n\t\tpartLookup[part.name] = part;\n\t}\n\n\tthis.type = opts.type;\n\tthis.hashAlgorithm = opts.hashAlgo;\n\tthis.curve = opts.curve;\n\tthis.parts = opts.parts;\n\tthis.part = partLookup;\n}\n\nSignature.prototype.toBuffer = function (format) {\n\tif (format === undefined)\n\t\tformat = 'asn1';\n\tassert.string(format, 'format');\n\n\tvar buf;\n\tvar stype = 'ssh-' + this.type;\n\n\tswitch (this.type) {\n\tcase 'rsa':\n\t\tswitch (this.hashAlgorithm) {\n\t\tcase 'sha256':\n\t\t\tstype = 'rsa-sha2-256';\n\t\t\tbreak;\n\t\tcase 'sha512':\n\t\t\tstype = 'rsa-sha2-512';\n\t\t\tbreak;\n\t\tcase 'sha1':\n\t\tcase undefined:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('SSH signature ' +\n\t\t\t    'format does not support hash ' +\n\t\t\t    'algorithm ' + this.hashAlgorithm));\n\t\t}\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'ed25519':\n\t\tif (format === 'ssh') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString(stype);\n\t\t\tbuf.writePart(this.part.sig);\n\t\t\treturn (buf.toBuffer());\n\t\t} else {\n\t\t\treturn (this.part.sig.data);\n\t\t}\n\t\tbreak;\n\n\tcase 'dsa':\n\tcase 'ecdsa':\n\t\tvar r, s;\n\t\tif (format === 'asn1') {\n\t\t\tvar der = new asn1.BerWriter();\n\t\t\tder.startSequence();\n\t\t\tr = utils.mpNormalize(this.part.r.data);\n\t\t\ts = utils.mpNormalize(this.part.s.data);\n\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\n\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\n\t\t\tder.endSequence();\n\t\t\treturn (der.buffer);\n\t\t} else if (format === 'ssh' && this.type === 'dsa') {\n\t\t\tbuf = new SSHBuffer({});\n\t\t\tbuf.writeString('ssh-dss');\n\t\t\tr = this.part.r.data;\n\t\t\tif (r.length > 20 && r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\ts = this.part.s.data;\n\t\t\tif (s.length > 20 && s[0] === 0x00)\n\t\t\t\ts = s.slice(1);\n\t\t\tif ((this.hashAlgorithm &&\n\t\t\t    this.hashAlgorithm !== 'sha1') ||\n\t\t\t    r.length + s.length !== 40) {\n\t\t\t\tthrow (new Error('OpenSSH only supports ' +\n\t\t\t\t    'DSA signatures with SHA1 hash'));\n\t\t\t}\n\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\n\t\t\treturn (buf.toBuffer());\n\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\n\t\t\tvar inner = new SSHBuffer({});\n\t\t\tr = this.part.r.data;\n\t\t\tinner.writeBuffer(r);\n\t\t\tinner.writePart(this.part.s);\n\n\t\t\tbuf = new SSHBuffer({});\n\t\t\t/* XXX: find a more proper way to do this? */\n\t\t\tvar curve;\n\t\t\tif (r[0] === 0x00)\n\t\t\t\tr = r.slice(1);\n\t\t\tvar sz = r.length * 8;\n\t\t\tif (sz === 256)\n\t\t\t\tcurve = 'nistp256';\n\t\t\telse if (sz === 384)\n\t\t\t\tcurve = 'nistp384';\n\t\t\telse if (sz === 528)\n\t\t\t\tcurve = 'nistp521';\n\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\n\t\t\tbuf.writeBuffer(inner.toBuffer());\n\t\t\treturn (buf.toBuffer());\n\t\t}\n\t\tthrow (new Error('Invalid signature format'));\n\tdefault:\n\t\tthrow (new Error('Invalid signature data'));\n\t}\n};\n\nSignature.prototype.toString = function (format) {\n\tassert.optionalString(format, 'format');\n\treturn (this.toBuffer(format).toString('base64'));\n};\n\nSignature.parse = function (data, type, format) {\n\tif (typeof (data) === 'string')\n\t\tdata = Buffer.from(data, 'base64');\n\tassert.buffer(data, 'data');\n\tassert.string(format, 'format');\n\tassert.string(type, 'type');\n\n\tvar opts = {};\n\topts.type = type.toLowerCase();\n\topts.parts = [];\n\n\ttry {\n\t\tassert.ok(data.length > 0, 'signature must not be empty');\n\t\tswitch (opts.type) {\n\t\tcase 'rsa':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\t\tcase 'ed25519':\n\t\t\treturn (parseOneNum(data, type, format, opts));\n\n\t\tcase 'dsa':\n\t\tcase 'ecdsa':\n\t\t\tif (format === 'asn1')\n\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\n\t\t\telse if (opts.type === 'dsa')\n\t\t\t\treturn (parseDSA(data, type, format, opts));\n\t\t\telse\n\t\t\t\treturn (parseECDSA(data, type, format, opts));\n\n\t\tdefault:\n\t\t\tthrow (new InvalidAlgorithmError(type));\n\t\t}\n\n\t} catch (e) {\n\t\tif (e instanceof InvalidAlgorithmError)\n\t\t\tthrow (e);\n\t\tthrow (new SignatureParseError(type, format, e));\n\t}\n};\n\nfunction parseOneNum(data, type, format, opts) {\n\tif (format === 'ssh') {\n\t\ttry {\n\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\tvar head = buf.readString();\n\t\t} catch (e) {\n\t\t\t/* fall through */\n\t\t}\n\t\tif (buf !== undefined) {\n\t\t\tvar msg = 'SSH signature does not match expected ' +\n\t\t\t    'type (expected ' + type + ', got ' + head + ')';\n\t\t\tswitch (head) {\n\t\t\tcase 'ssh-rsa':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha1';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-256':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 'rsa-sha2-512':\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tcase 'ssh-ed25519':\n\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('Unknown SSH signature ' +\n\t\t\t\t    'type: ' + head));\n\t\t\t}\n\t\t\tvar sig = buf.readPart();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\tsig.name = 'sig';\n\t\t\topts.parts.push(sig);\n\t\t\treturn (new Signature(opts));\n\t\t}\n\t}\n\topts.parts.push({name: 'sig', data: data});\n\treturn (new Signature(opts));\n}\n\nfunction parseDSAasn1(data, type, format, opts) {\n\tvar der = new asn1.BerReader(data);\n\tder.readSequence();\n\tvar r = der.readString(asn1.Ber.Integer, true);\n\tvar s = der.readString(asn1.Ber.Integer, true);\n\n\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\n\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\n\n\treturn (new Signature(opts));\n}\n\nfunction parseDSA(data, type, format, opts) {\n\tif (data.length != 40) {\n\t\tvar buf = new SSHBuffer({buffer: data});\n\t\tvar d = buf.readBuffer();\n\t\tif (d.toString('ascii') === 'ssh-dss')\n\t\t\td = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\n\t\tdata = d;\n\t}\n\topts.parts.push({name: 'r', data: data.slice(0, 20)});\n\topts.parts.push({name: 's', data: data.slice(20, 40)});\n\treturn (new Signature(opts));\n}\n\nfunction parseECDSA(data, type, format, opts) {\n\tvar buf = new SSHBuffer({buffer: data});\n\n\tvar r, s;\n\tvar inner = buf.readBuffer();\n\tvar stype = inner.toString('ascii');\n\tif (stype.slice(0, 6) === 'ecdsa-') {\n\t\tvar parts = stype.split('-');\n\t\tassert.strictEqual(parts[0], 'ecdsa');\n\t\tassert.strictEqual(parts[1], 'sha2');\n\t\topts.curve = parts[2];\n\t\tswitch (opts.curve) {\n\t\tcase 'nistp256':\n\t\t\topts.hashAlgo = 'sha256';\n\t\t\tbreak;\n\t\tcase 'nistp384':\n\t\t\topts.hashAlgo = 'sha384';\n\t\t\tbreak;\n\t\tcase 'nistp521':\n\t\t\topts.hashAlgo = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\n\t\t\t    opts.curve));\n\t\t}\n\t\tinner = buf.readBuffer();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n\t\tbuf = new SSHBuffer({buffer: inner});\n\t\tr = buf.readPart();\n\t} else {\n\t\tr = {data: inner};\n\t}\n\n\ts = buf.readPart();\n\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\n\tr.name = 'r';\n\ts.name = 's';\n\n\topts.parts.push(r);\n\topts.parts.push(s);\n\treturn (new Signature(opts));\n}\n\nSignature.isSignature = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Signature, ver));\n};\n\n/*\n * API versions for Signature:\n * [1,0] -- initial ver\n * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n *          hashAlgorithm property\n * [2,1] -- first tagged version\n */\nSignature.prototype._sshpkApiVersion = [2, 1];\n\nSignature._oldVersionDetect = function (obj) {\n\tassert.func(obj.toBuffer);\n\tif (obj.hasOwnProperty('hashAlgorithm'))\n\t\treturn ([2, 0]);\n\treturn ([1, 0]);\n};\n","start":1667202706131,"end":1667202706353},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ssh-buffer.js?commonjs-wrapped\";\n\nvar signature;\nvar hasRequiredSignature;\n\nfunction requireSignature () {\n\tif (hasRequiredSignature) return signature;\n\thasRequiredSignature = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tsignature = Signature;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar algs = require$$2();\n\tvar crypto = require$$3;\n\tvar errs = require$$4();\n\tvar utils = require$$5();\n\tvar asn1 = require$$6();\n\tvar SSHBuffer = require$$7();\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar SignatureParseError = errs.SignatureParseError;\n\n\tfunction Signature(opts) {\n\t\tassert.object(opts, 'options');\n\t\tassert.arrayOfObject(opts.parts, 'options.parts');\n\t\tassert.string(opts.type, 'options.type');\n\n\t\tvar partLookup = {};\n\t\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\t\tvar part = opts.parts[i];\n\t\t\tpartLookup[part.name] = part;\n\t\t}\n\n\t\tthis.type = opts.type;\n\t\tthis.hashAlgorithm = opts.hashAlgo;\n\t\tthis.curve = opts.curve;\n\t\tthis.parts = opts.parts;\n\t\tthis.part = partLookup;\n\t}\n\n\tSignature.prototype.toBuffer = function (format) {\n\t\tif (format === undefined)\n\t\t\tformat = 'asn1';\n\t\tassert.string(format, 'format');\n\n\t\tvar buf;\n\t\tvar stype = 'ssh-' + this.type;\n\n\t\tswitch (this.type) {\n\t\tcase 'rsa':\n\t\t\tswitch (this.hashAlgorithm) {\n\t\t\tcase 'sha256':\n\t\t\t\tstype = 'rsa-sha2-256';\n\t\t\t\tbreak;\n\t\t\tcase 'sha512':\n\t\t\t\tstype = 'rsa-sha2-512';\n\t\t\t\tbreak;\n\t\t\tcase 'sha1':\n\t\t\tcase undefined:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('SSH signature ' +\n\t\t\t\t    'format does not support hash ' +\n\t\t\t\t    'algorithm ' + this.hashAlgorithm));\n\t\t\t}\n\t\t\tif (format === 'ssh') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString(stype);\n\t\t\t\tbuf.writePart(this.part.sig);\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else {\n\t\t\t\treturn (this.part.sig.data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'ed25519':\n\t\t\tif (format === 'ssh') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString(stype);\n\t\t\t\tbuf.writePart(this.part.sig);\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else {\n\t\t\t\treturn (this.part.sig.data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'dsa':\n\t\tcase 'ecdsa':\n\t\t\tvar r, s;\n\t\t\tif (format === 'asn1') {\n\t\t\t\tvar der = new asn1.BerWriter();\n\t\t\t\tder.startSequence();\n\t\t\t\tr = utils.mpNormalize(this.part.r.data);\n\t\t\t\ts = utils.mpNormalize(this.part.s.data);\n\t\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\n\t\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\n\t\t\t\tder.endSequence();\n\t\t\t\treturn (der.buffer);\n\t\t\t} else if (format === 'ssh' && this.type === 'dsa') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString('ssh-dss');\n\t\t\t\tr = this.part.r.data;\n\t\t\t\tif (r.length > 20 && r[0] === 0x00)\n\t\t\t\t\tr = r.slice(1);\n\t\t\t\ts = this.part.s.data;\n\t\t\t\tif (s.length > 20 && s[0] === 0x00)\n\t\t\t\t\ts = s.slice(1);\n\t\t\t\tif ((this.hashAlgorithm &&\n\t\t\t\t    this.hashAlgorithm !== 'sha1') ||\n\t\t\t\t    r.length + s.length !== 40) {\n\t\t\t\t\tthrow (new Error('OpenSSH only supports ' +\n\t\t\t\t\t    'DSA signatures with SHA1 hash'));\n\t\t\t\t}\n\t\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\n\t\t\t\tvar inner = new SSHBuffer({});\n\t\t\t\tr = this.part.r.data;\n\t\t\t\tinner.writeBuffer(r);\n\t\t\t\tinner.writePart(this.part.s);\n\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\t/* XXX: find a more proper way to do this? */\n\t\t\t\tvar curve;\n\t\t\t\tif (r[0] === 0x00)\n\t\t\t\t\tr = r.slice(1);\n\t\t\t\tvar sz = r.length * 8;\n\t\t\t\tif (sz === 256)\n\t\t\t\t\tcurve = 'nistp256';\n\t\t\t\telse if (sz === 384)\n\t\t\t\t\tcurve = 'nistp384';\n\t\t\t\telse if (sz === 528)\n\t\t\t\t\tcurve = 'nistp521';\n\t\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\n\t\t\t\tbuf.writeBuffer(inner.toBuffer());\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t}\n\t\t\tthrow (new Error('Invalid signature format'));\n\t\tdefault:\n\t\t\tthrow (new Error('Invalid signature data'));\n\t\t}\n\t};\n\n\tSignature.prototype.toString = function (format) {\n\t\tassert.optionalString(format, 'format');\n\t\treturn (this.toBuffer(format).toString('base64'));\n\t};\n\n\tSignature.parse = function (data, type, format) {\n\t\tif (typeof (data) === 'string')\n\t\t\tdata = Buffer.from(data, 'base64');\n\t\tassert.buffer(data, 'data');\n\t\tassert.string(format, 'format');\n\t\tassert.string(type, 'type');\n\n\t\tvar opts = {};\n\t\topts.type = type.toLowerCase();\n\t\topts.parts = [];\n\n\t\ttry {\n\t\t\tassert.ok(data.length > 0, 'signature must not be empty');\n\t\t\tswitch (opts.type) {\n\t\t\tcase 'rsa':\n\t\t\t\treturn (parseOneNum(data, type, format, opts));\n\t\t\tcase 'ed25519':\n\t\t\t\treturn (parseOneNum(data, type, format, opts));\n\n\t\t\tcase 'dsa':\n\t\t\tcase 'ecdsa':\n\t\t\t\tif (format === 'asn1')\n\t\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\n\t\t\t\telse if (opts.type === 'dsa')\n\t\t\t\t\treturn (parseDSA(data, type, format, opts));\n\t\t\t\telse\n\t\t\t\t\treturn (parseECDSA(data, type, format, opts));\n\n\t\t\tdefault:\n\t\t\t\tthrow (new InvalidAlgorithmError(type));\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\tif (e instanceof InvalidAlgorithmError)\n\t\t\t\tthrow (e);\n\t\t\tthrow (new SignatureParseError(type, format, e));\n\t\t}\n\t};\n\n\tfunction parseOneNum(data, type, format, opts) {\n\t\tif (format === 'ssh') {\n\t\t\ttry {\n\t\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\t\tvar head = buf.readString();\n\t\t\t} catch (e) {\n\t\t\t\t/* fall through */\n\t\t\t}\n\t\t\tif (buf !== undefined) {\n\t\t\t\tvar msg = 'SSH signature does not match expected ' +\n\t\t\t\t    'type (expected ' + type + ', got ' + head + ')';\n\t\t\t\tswitch (head) {\n\t\t\t\tcase 'ssh-rsa':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha1';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rsa-sha2-256':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rsa-sha2-512':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ssh-ed25519':\n\t\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\n\t\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow (new Error('Unknown SSH signature ' +\n\t\t\t\t\t    'type: ' + head));\n\t\t\t\t}\n\t\t\t\tvar sig = buf.readPart();\n\t\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\t\tsig.name = 'sig';\n\t\t\t\topts.parts.push(sig);\n\t\t\t\treturn (new Signature(opts));\n\t\t\t}\n\t\t}\n\t\topts.parts.push({name: 'sig', data: data});\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseDSAasn1(data, type, format, opts) {\n\t\tvar der = new asn1.BerReader(data);\n\t\tder.readSequence();\n\t\tvar r = der.readString(asn1.Ber.Integer, true);\n\t\tvar s = der.readString(asn1.Ber.Integer, true);\n\n\t\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\n\t\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\n\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseDSA(data, type, format, opts) {\n\t\tif (data.length != 40) {\n\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\tvar d = buf.readBuffer();\n\t\t\tif (d.toString('ascii') === 'ssh-dss')\n\t\t\t\td = buf.readBuffer();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\n\t\t\tdata = d;\n\t\t}\n\t\topts.parts.push({name: 'r', data: data.slice(0, 20)});\n\t\topts.parts.push({name: 's', data: data.slice(20, 40)});\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseECDSA(data, type, format, opts) {\n\t\tvar buf = new SSHBuffer({buffer: data});\n\n\t\tvar r, s;\n\t\tvar inner = buf.readBuffer();\n\t\tvar stype = inner.toString('ascii');\n\t\tif (stype.slice(0, 6) === 'ecdsa-') {\n\t\t\tvar parts = stype.split('-');\n\t\t\tassert.strictEqual(parts[0], 'ecdsa');\n\t\t\tassert.strictEqual(parts[1], 'sha2');\n\t\t\topts.curve = parts[2];\n\t\t\tswitch (opts.curve) {\n\t\t\tcase 'nistp256':\n\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 'nistp384':\n\t\t\t\topts.hashAlgo = 'sha384';\n\t\t\t\tbreak;\n\t\t\tcase 'nistp521':\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\n\t\t\t\t    opts.curve));\n\t\t\t}\n\t\t\tinner = buf.readBuffer();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n\t\t\tbuf = new SSHBuffer({buffer: inner});\n\t\t\tr = buf.readPart();\n\t\t} else {\n\t\t\tr = {data: inner};\n\t\t}\n\n\t\ts = buf.readPart();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\n\t\tr.name = 'r';\n\t\ts.name = 's';\n\n\t\topts.parts.push(r);\n\t\topts.parts.push(s);\n\t\treturn (new Signature(opts));\n\t}\n\n\tSignature.isSignature = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, Signature, ver));\n\t};\n\n\t/*\n\t * API versions for Signature:\n\t * [1,0] -- initial ver\n\t * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n\t *          hashAlgorithm property\n\t * [2,1] -- first tagged version\n\t */\n\tSignature.prototype._sshpkApiVersion = [2, 1];\n\n\tSignature._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toBuffer);\n\t\tif (obj.hasOwnProperty('hashAlgorithm'))\n\t\t\treturn ([2, 0]);\n\t\treturn ([1, 0]);\n\t};\n\treturn signature;\n}\n\nexport { requireSignature as __require };","start":1667202706353,"end":1667202707660,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ssh-buffer.js?commonjs-wrapped\";\n\nvar signature;\nvar hasRequiredSignature;\n\nfunction requireSignature () {\n\tif (hasRequiredSignature) return signature;\n\thasRequiredSignature = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tsignature = Signature;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar algs = require$$2();\n\tvar crypto = require$$3;\n\tvar errs = require$$4();\n\tvar utils = require$$5();\n\tvar asn1 = require$$6();\n\tvar SSHBuffer = require$$7();\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar SignatureParseError = errs.SignatureParseError;\n\n\tfunction Signature(opts) {\n\t\tassert.object(opts, 'options');\n\t\tassert.arrayOfObject(opts.parts, 'options.parts');\n\t\tassert.string(opts.type, 'options.type');\n\n\t\tvar partLookup = {};\n\t\tfor (var i = 0; i < opts.parts.length; ++i) {\n\t\t\tvar part = opts.parts[i];\n\t\t\tpartLookup[part.name] = part;\n\t\t}\n\n\t\tthis.type = opts.type;\n\t\tthis.hashAlgorithm = opts.hashAlgo;\n\t\tthis.curve = opts.curve;\n\t\tthis.parts = opts.parts;\n\t\tthis.part = partLookup;\n\t}\n\n\tSignature.prototype.toBuffer = function (format) {\n\t\tif (format === undefined)\n\t\t\tformat = 'asn1';\n\t\tassert.string(format, 'format');\n\n\t\tvar buf;\n\t\tvar stype = 'ssh-' + this.type;\n\n\t\tswitch (this.type) {\n\t\tcase 'rsa':\n\t\t\tswitch (this.hashAlgorithm) {\n\t\t\tcase 'sha256':\n\t\t\t\tstype = 'rsa-sha2-256';\n\t\t\t\tbreak;\n\t\t\tcase 'sha512':\n\t\t\t\tstype = 'rsa-sha2-512';\n\t\t\t\tbreak;\n\t\t\tcase 'sha1':\n\t\t\tcase undefined:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('SSH signature ' +\n\t\t\t\t    'format does not support hash ' +\n\t\t\t\t    'algorithm ' + this.hashAlgorithm));\n\t\t\t}\n\t\t\tif (format === 'ssh') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString(stype);\n\t\t\t\tbuf.writePart(this.part.sig);\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else {\n\t\t\t\treturn (this.part.sig.data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'ed25519':\n\t\t\tif (format === 'ssh') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString(stype);\n\t\t\t\tbuf.writePart(this.part.sig);\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else {\n\t\t\t\treturn (this.part.sig.data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'dsa':\n\t\tcase 'ecdsa':\n\t\t\tvar r, s;\n\t\t\tif (format === 'asn1') {\n\t\t\t\tvar der = new asn1.BerWriter();\n\t\t\t\tder.startSequence();\n\t\t\t\tr = utils.mpNormalize(this.part.r.data);\n\t\t\t\ts = utils.mpNormalize(this.part.s.data);\n\t\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\n\t\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\n\t\t\t\tder.endSequence();\n\t\t\t\treturn (der.buffer);\n\t\t\t} else if (format === 'ssh' && this.type === 'dsa') {\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\tbuf.writeString('ssh-dss');\n\t\t\t\tr = this.part.r.data;\n\t\t\t\tif (r.length > 20 && r[0] === 0x00)\n\t\t\t\t\tr = r.slice(1);\n\t\t\t\ts = this.part.s.data;\n\t\t\t\tif (s.length > 20 && s[0] === 0x00)\n\t\t\t\t\ts = s.slice(1);\n\t\t\t\tif ((this.hashAlgorithm &&\n\t\t\t\t    this.hashAlgorithm !== 'sha1') ||\n\t\t\t\t    r.length + s.length !== 40) {\n\t\t\t\t\tthrow (new Error('OpenSSH only supports ' +\n\t\t\t\t\t    'DSA signatures with SHA1 hash'));\n\t\t\t\t}\n\t\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\n\t\t\t\tvar inner = new SSHBuffer({});\n\t\t\t\tr = this.part.r.data;\n\t\t\t\tinner.writeBuffer(r);\n\t\t\t\tinner.writePart(this.part.s);\n\n\t\t\t\tbuf = new SSHBuffer({});\n\t\t\t\t/* XXX: find a more proper way to do this? */\n\t\t\t\tvar curve;\n\t\t\t\tif (r[0] === 0x00)\n\t\t\t\t\tr = r.slice(1);\n\t\t\t\tvar sz = r.length * 8;\n\t\t\t\tif (sz === 256)\n\t\t\t\t\tcurve = 'nistp256';\n\t\t\t\telse if (sz === 384)\n\t\t\t\t\tcurve = 'nistp384';\n\t\t\t\telse if (sz === 528)\n\t\t\t\t\tcurve = 'nistp521';\n\t\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\n\t\t\t\tbuf.writeBuffer(inner.toBuffer());\n\t\t\t\treturn (buf.toBuffer());\n\t\t\t}\n\t\t\tthrow (new Error('Invalid signature format'));\n\t\tdefault:\n\t\t\tthrow (new Error('Invalid signature data'));\n\t\t}\n\t};\n\n\tSignature.prototype.toString = function (format) {\n\t\tassert.optionalString(format, 'format');\n\t\treturn (this.toBuffer(format).toString('base64'));\n\t};\n\n\tSignature.parse = function (data, type, format) {\n\t\tif (typeof (data) === 'string')\n\t\t\tdata = Buffer.from(data, 'base64');\n\t\tassert.buffer(data, 'data');\n\t\tassert.string(format, 'format');\n\t\tassert.string(type, 'type');\n\n\t\tvar opts = {};\n\t\topts.type = type.toLowerCase();\n\t\topts.parts = [];\n\n\t\ttry {\n\t\t\tassert.ok(data.length > 0, 'signature must not be empty');\n\t\t\tswitch (opts.type) {\n\t\t\tcase 'rsa':\n\t\t\t\treturn (parseOneNum(data, type, format, opts));\n\t\t\tcase 'ed25519':\n\t\t\t\treturn (parseOneNum(data, type, format, opts));\n\n\t\t\tcase 'dsa':\n\t\t\tcase 'ecdsa':\n\t\t\t\tif (format === 'asn1')\n\t\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\n\t\t\t\telse if (opts.type === 'dsa')\n\t\t\t\t\treturn (parseDSA(data, type, format, opts));\n\t\t\t\telse\n\t\t\t\t\treturn (parseECDSA(data, type, format, opts));\n\n\t\t\tdefault:\n\t\t\t\tthrow (new InvalidAlgorithmError(type));\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\tif (e instanceof InvalidAlgorithmError)\n\t\t\t\tthrow (e);\n\t\t\tthrow (new SignatureParseError(type, format, e));\n\t\t}\n\t};\n\n\tfunction parseOneNum(data, type, format, opts) {\n\t\tif (format === 'ssh') {\n\t\t\ttry {\n\t\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\t\tvar head = buf.readString();\n\t\t\t} catch (e) {\n\t\t\t\t/* fall through */\n\t\t\t}\n\t\t\tif (buf !== undefined) {\n\t\t\t\tvar msg = 'SSH signature does not match expected ' +\n\t\t\t\t    'type (expected ' + type + ', got ' + head + ')';\n\t\t\t\tswitch (head) {\n\t\t\t\tcase 'ssh-rsa':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha1';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rsa-sha2-256':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rsa-sha2-512':\n\t\t\t\t\tassert.strictEqual(type, 'rsa', msg);\n\t\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ssh-ed25519':\n\t\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\n\t\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow (new Error('Unknown SSH signature ' +\n\t\t\t\t\t    'type: ' + head));\n\t\t\t\t}\n\t\t\t\tvar sig = buf.readPart();\n\t\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\t\tsig.name = 'sig';\n\t\t\t\topts.parts.push(sig);\n\t\t\t\treturn (new Signature(opts));\n\t\t\t}\n\t\t}\n\t\topts.parts.push({name: 'sig', data: data});\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseDSAasn1(data, type, format, opts) {\n\t\tvar der = new asn1.BerReader(data);\n\t\tder.readSequence();\n\t\tvar r = der.readString(asn1.Ber.Integer, true);\n\t\tvar s = der.readString(asn1.Ber.Integer, true);\n\n\t\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\n\t\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\n\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseDSA(data, type, format, opts) {\n\t\tif (data.length != 40) {\n\t\t\tvar buf = new SSHBuffer({buffer: data});\n\t\t\tvar d = buf.readBuffer();\n\t\t\tif (d.toString('ascii') === 'ssh-dss')\n\t\t\t\td = buf.readBuffer();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\t\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\n\t\t\tdata = d;\n\t\t}\n\t\topts.parts.push({name: 'r', data: data.slice(0, 20)});\n\t\topts.parts.push({name: 's', data: data.slice(20, 40)});\n\t\treturn (new Signature(opts));\n\t}\n\n\tfunction parseECDSA(data, type, format, opts) {\n\t\tvar buf = new SSHBuffer({buffer: data});\n\n\t\tvar r, s;\n\t\tvar inner = buf.readBuffer();\n\t\tvar stype = inner.toString('ascii');\n\t\tif (stype.slice(0, 6) === 'ecdsa-') {\n\t\t\tvar parts = stype.split('-');\n\t\t\tassert.strictEqual(parts[0], 'ecdsa');\n\t\t\tassert.strictEqual(parts[1], 'sha2');\n\t\t\topts.curve = parts[2];\n\t\t\tswitch (opts.curve) {\n\t\t\tcase 'nistp256':\n\t\t\t\topts.hashAlgo = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 'nistp384':\n\t\t\t\topts.hashAlgo = 'sha384';\n\t\t\t\tbreak;\n\t\t\tcase 'nistp521':\n\t\t\t\topts.hashAlgo = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\n\t\t\t\t    opts.curve));\n\t\t\t}\n\t\t\tinner = buf.readBuffer();\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n\t\t\tbuf = new SSHBuffer({buffer: inner});\n\t\t\tr = buf.readPart();\n\t\t} else {\n\t\t\tr = {data: inner};\n\t\t}\n\n\t\ts = buf.readPart();\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\n\n\t\tr.name = 'r';\n\t\ts.name = 's';\n\n\t\topts.parts.push(r);\n\t\topts.parts.push(s);\n\t\treturn (new Signature(opts));\n\t}\n\n\tSignature.isSignature = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, Signature, ver));\n\t};\n\n\t/*\n\t * API versions for Signature:\n\t * [1,0] -- initial ver\n\t * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n\t *          hashAlgorithm property\n\t * [2,1] -- first tagged version\n\t */\n\tSignature.prototype._sshpkApiVersion = [2, 1];\n\n\tSignature._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toBuffer);\n\t\tif (obj.hasOwnProperty('hashAlgorithm'))\n\t\t\treturn ([2, 0]);\n\t\treturn ([1, 0]);\n\t};\n\treturn signature;\n}\n\nexport { requireSignature as __require };","start":1667202707677,"end":1667202707709,"order":"normal"}]}
