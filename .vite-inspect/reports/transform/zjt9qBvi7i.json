{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/putty.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar rfc4253 = require('./rfc4253');\nvar Key = require('../key');\nvar SSHBuffer = require('../ssh-buffer');\nvar crypto = require('crypto');\nvar PrivateKey = require('../private-key');\n\nvar errors = require('../errors');\n\n// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html\nfunction read(buf, options) {\n\tvar lines = buf.toString('ascii').split(/[\\r\\n]+/);\n\tvar found = false;\n\tvar parts;\n\tvar si = 0;\n\tvar formatVersion;\n\twhile (si < lines.length) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tif (parts) {\n\t\t\tformatVersion = {\n\t\t\t\t'putty-user-key-file-2': 2,\n\t\t\t\t'putty-user-key-file-3': 3\n\t\t\t}[parts[0].toLowerCase()];\n\t\t\tif (formatVersion) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\tthrow (new Error('No PuTTY format first line found'));\n\t}\n\tvar alg = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'encryption');\n\tvar encryption = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'comment');\n\tvar comment = parts[1];\n\n\tparts = splitHeader(lines[si++]);\n\tassert.equal(parts[0].toLowerCase(), 'public-lines');\n\tvar publicLines = parseInt(parts[1], 10);\n\tif (!isFinite(publicLines) || publicLines < 0 ||\n\t    publicLines > lines.length) {\n\t\tthrow (new Error('Invalid public-lines count'));\n\t}\n\n\tvar publicBuf = Buffer.from(\n\t    lines.slice(si, si + publicLines).join(''), 'base64');\n\tvar keyType = rfc4253.algToKeyType(alg);\n\tvar key = rfc4253.read(publicBuf);\n\tif (key.type !== keyType) {\n\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t}\n\n\tsi += publicLines;\n\tif (lines[si]) {\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'private-lines');\n\t\tvar privateLines = parseInt(parts[1], 10);\n\t\tif (!isFinite(privateLines) || privateLines < 0 ||\n\t\t    privateLines > lines.length) {\n\t\t\tthrow (new Error('Invalid private-lines count'));\n\t\t}\n\n\t\tvar privateBuf = Buffer.from(\n\t\t\tlines.slice(si, si + privateLines).join(''), 'base64');\n\n\t\tif (encryption !== 'none' && formatVersion === 3) {\n\t\t\tthrow new Error('Encrypted keys arenot supported for' +\n\t\t\t' PuTTY format version 3');\n\t\t}\n\n\t\tif (encryption === 'aes256-cbc') {\n\t\t\tif (!options.passphrase) {\n\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t\toptions.filename, 'PEM'));\n\t\t\t}\n\n\t\t\tvar iv = Buffer.alloc(16, 0);\n\t\t\tvar decipher = crypto.createDecipheriv(\n\t\t\t\t'aes-256-cbc',\n\t\t\t\tderivePPK2EncryptionKey(options.passphrase),\n\t\t\t\tiv);\n\t\t\tdecipher.setAutoPadding(false);\n\t\t\tprivateBuf = Buffer.concat([\n\t\t\t\tdecipher.update(privateBuf), decipher.final()]);\n\t\t}\n\n\t\tkey = new PrivateKey(key);\n\t\tif (key.type !== keyType) {\n\t\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t\t}\n\n\t\tvar sshbuf = new SSHBuffer({buffer: privateBuf});\n\t\tvar privateKeyParts;\n\t\tif (alg === 'ssh-dss') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'x',\n\t\t\t\tdata: sshbuf.readBuffer()\n\t\t\t}];\n\t\t} else if (alg === 'ssh-rsa') {\n\t\t\tprivateKeyParts = [\n\t\t\t\t{ name: 'd', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'p', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'q', data: sshbuf.readBuffer() },\n\t\t\t\t{ name: 'iqmp', data: sshbuf.readBuffer() }\n\t\t\t];\n\t\t} else if (alg.match(/^ecdsa-sha2-nistp/)) {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'd', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else if (alg === 'ssh-ed25519') {\n\t\t\tprivateKeyParts = [ {\n\t\t\t\tname: 'k', data: sshbuf.readBuffer()\n\t\t\t} ];\n\t\t} else {\n\t\t\tthrow new Error('Unsupported PPK key type: ' + alg);\n\t\t}\n\n\t\tkey = new PrivateKey({\n\t\t\ttype: key.type,\n\t\t\tparts: key.parts.concat(privateKeyParts)\n\t\t});\n\t}\n\n\tkey.comment = comment;\n\treturn (key);\n}\n\nfunction derivePPK2EncryptionKey(passphrase) {\n\tvar hash1 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 0]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\tvar hash2 = crypto.createHash('sha1').update(Buffer.concat([\n\t\tBuffer.from([0, 0, 0, 1]),\n\t\tBuffer.from(passphrase)\n\t])).digest();\n\treturn (Buffer.concat([hash1, hash2]).slice(0, 32));\n}\n\nfunction splitHeader(line) {\n\tvar idx = line.indexOf(':');\n\tif (idx === -1)\n\t\treturn (null);\n\tvar header = line.slice(0, idx);\n\t++idx;\n\twhile (line[idx] === ' ')\n\t\t++idx;\n\tvar rest = line.slice(idx);\n\treturn ([header, rest]);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tvar buf = rfc4253.write(key);\n\tvar comment = key.comment || '';\n\n\tvar b64 = buf.toString('base64');\n\tvar lines = wrap(b64, 64);\n\n\tlines.unshift('Public-Lines: ' + lines.length);\n\tlines.unshift('Comment: ' + comment);\n\tlines.unshift('Encryption: none');\n\tlines.unshift('PuTTY-User-Key-File-2: ' + alg);\n\n\treturn (Buffer.from(lines.join('\\n') + '\\n'));\n}\n\nfunction wrap(txt, len) {\n\tvar lines = [];\n\tvar pos = 0;\n\twhile (pos < txt.length) {\n\t\tlines.push(txt.slice(pos, pos + 64));\n\t\tpos += 64;\n\t}\n\treturn (lines);\n}\n","start":1667202983847,"end":1667202984032},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ssh-buffer.js?commonjs-wrapped\";\nimport require$$5 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\n\nvar putty;\nvar hasRequiredPutty;\n\nfunction requirePutty () {\n\tif (hasRequiredPutty) return putty;\n\thasRequiredPutty = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tputty = {\n\t\tread: read,\n\t\twrite: write\n\t};\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar rfc4253 = require$$2();\n\tvar Key = require$$3();\n\tvar SSHBuffer = require$$4();\n\tvar crypto = require$$5;\n\tvar PrivateKey = require$$6();\n\n\tvar errors = require$$7();\n\n\t// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html\n\tfunction read(buf, options) {\n\t\tvar lines = buf.toString('ascii').split(/[\\r\\n]+/);\n\t\tvar found = false;\n\t\tvar parts;\n\t\tvar si = 0;\n\t\tvar formatVersion;\n\t\twhile (si < lines.length) {\n\t\t\tparts = splitHeader(lines[si++]);\n\t\t\tif (parts) {\n\t\t\t\tformatVersion = {\n\t\t\t\t\t'putty-user-key-file-2': 2,\n\t\t\t\t\t'putty-user-key-file-3': 3\n\t\t\t\t}[parts[0].toLowerCase()];\n\t\t\t\tif (formatVersion) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tthrow (new Error('No PuTTY format first line found'));\n\t\t}\n\t\tvar alg = parts[1];\n\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'encryption');\n\t\tvar encryption = parts[1];\n\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'comment');\n\t\tvar comment = parts[1];\n\n\t\tparts = splitHeader(lines[si++]);\n\t\tassert.equal(parts[0].toLowerCase(), 'public-lines');\n\t\tvar publicLines = parseInt(parts[1], 10);\n\t\tif (!isFinite(publicLines) || publicLines < 0 ||\n\t\t    publicLines > lines.length) {\n\t\t\tthrow (new Error('Invalid public-lines count'));\n\t\t}\n\n\t\tvar publicBuf = Buffer.from(\n\t\t    lines.slice(si, si + publicLines).join(''), 'base64');\n\t\tvar keyType = rfc4253.algToKeyType(alg);\n\t\tvar key = rfc4253.read(publicBuf);\n\t\tif (key.type !== keyType) {\n\t\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t\t}\n\n\t\tsi += publicLines;\n\t\tif (lines[si]) {\n\t\t\tparts = splitHeader(lines[si++]);\n\t\t\tassert.equal(parts[0].toLowerCase(), 'private-lines');\n\t\t\tvar privateLines = parseInt(parts[1], 10);\n\t\t\tif (!isFinite(privateLines) || privateLines < 0 ||\n\t\t\t    privateLines > lines.length) {\n\t\t\t\tthrow (new Error('Invalid private-lines count'));\n\t\t\t}\n\n\t\t\tvar privateBuf = Buffer.from(\n\t\t\t\tlines.slice(si, si + privateLines).join(''), 'base64');\n\n\t\t\tif (encryption !== 'none' && formatVersion === 3) {\n\t\t\t\tthrow new Error('Encrypted keys arenot supported for' +\n\t\t\t\t' PuTTY format version 3');\n\t\t\t}\n\n\t\t\tif (encryption === 'aes256-cbc') {\n\t\t\t\tif (!options.passphrase) {\n\t\t\t\t\tthrow (new errors.KeyEncryptedError(\n\t\t\t\t\t\toptions.filename, 'PEM'));\n\t\t\t\t}\n\n\t\t\t\tvar iv = Buffer.alloc(16, 0);\n\t\t\t\tvar decipher = crypto.createDecipheriv(\n\t\t\t\t\t'aes-256-cbc',\n\t\t\t\t\tderivePPK2EncryptionKey(options.passphrase),\n\t\t\t\t\tiv);\n\t\t\t\tdecipher.setAutoPadding(false);\n\t\t\t\tprivateBuf = Buffer.concat([\n\t\t\t\t\tdecipher.update(privateBuf), decipher.final()]);\n\t\t\t}\n\n\t\t\tkey = new PrivateKey(key);\n\t\t\tif (key.type !== keyType) {\n\t\t\t\tthrow (new Error('Outer key algorithm mismatch'));\n\t\t\t}\n\n\t\t\tvar sshbuf = new SSHBuffer({buffer: privateBuf});\n\t\t\tvar privateKeyParts;\n\t\t\tif (alg === 'ssh-dss') {\n\t\t\t\tprivateKeyParts = [ {\n\t\t\t\t\tname: 'x',\n\t\t\t\t\tdata: sshbuf.readBuffer()\n\t\t\t\t}];\n\t\t\t} else if (alg === 'ssh-rsa') {\n\t\t\t\tprivateKeyParts = [\n\t\t\t\t\t{ name: 'd', data: sshbuf.readBuffer() },\n\t\t\t\t\t{ name: 'p', data: sshbuf.readBuffer() },\n\t\t\t\t\t{ name: 'q', data: sshbuf.readBuffer() },\n\t\t\t\t\t{ name: 'iqmp', data: sshbuf.readBuffer() }\n\t\t\t\t];\n\t\t\t} else if (alg.match(/^ecdsa-sha2-nistp/)) {\n\t\t\t\tprivateKeyParts = [ {\n\t\t\t\t\tname: 'd', data: sshbuf.readBuffer()\n\t\t\t\t} ];\n\t\t\t} else if (alg === 'ssh-ed25519') {\n\t\t\t\tprivateKeyParts = [ {\n\t\t\t\t\tname: 'k', data: sshbuf.readBuffer()\n\t\t\t\t} ];\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unsupported PPK key type: ' + alg);\n\t\t\t}\n\n\t\t\tkey = new PrivateKey({\n\t\t\t\ttype: key.type,\n\t\t\t\tparts: key.parts.concat(privateKeyParts)\n\t\t\t});\n\t\t}\n\n\t\tkey.comment = comment;\n\t\treturn (key);\n\t}\n\n\tfunction derivePPK2EncryptionKey(passphrase) {\n\t\tvar hash1 = crypto.createHash('sha1').update(Buffer.concat([\n\t\t\tBuffer.from([0, 0, 0, 0]),\n\t\t\tBuffer.from(passphrase)\n\t\t])).digest();\n\t\tvar hash2 = crypto.createHash('sha1').update(Buffer.concat([\n\t\t\tBuffer.from([0, 0, 0, 1]),\n\t\t\tBuffer.from(passphrase)\n\t\t])).digest();\n\t\treturn (Buffer.concat([hash1, hash2]).slice(0, 32));\n\t}\n\n\tfunction splitHeader(line) {\n\t\tvar idx = line.indexOf(':');\n\t\tif (idx === -1)\n\t\t\treturn (null);\n\t\tvar header = line.slice(0, idx);\n\t\t++idx;\n\t\twhile (line[idx] === ' ')\n\t\t\t++idx;\n\t\tvar rest = line.slice(idx);\n\t\treturn ([header, rest]);\n\t}\n\n\tfunction write(key, options) {\n\t\tassert.object(key);\n\t\tif (!Key.isKey(key))\n\t\t\tthrow (new Error('Must be a public key'));\n\n\t\tvar alg = rfc4253.keyTypeToAlg(key);\n\t\tvar buf = rfc4253.write(key);\n\t\tvar comment = key.comment || '';\n\n\t\tvar b64 = buf.toString('base64');\n\t\tvar lines = wrap(b64, 64);\n\n\t\tlines.unshift('Public-Lines: ' + lines.length);\n\t\tlines.unshift('Comment: ' + comment);\n\t\tlines.unshift('Encryption: none');\n\t\tlines.unshift('PuTTY-User-Key-File-2: ' + alg);\n\n\t\treturn (Buffer.from(lines.join('\\n') + '\\n'));\n\t}\n\n\tfunction wrap(txt, len) {\n\t\tvar lines = [];\n\t\tvar pos = 0;\n\t\twhile (pos < txt.length) {\n\t\t\tlines.push(txt.slice(pos, pos + 64));\n\t\t\tpos += 64;\n\t\t}\n\t\treturn (lines);\n\t}\n\treturn putty;\n}\n\nexport { requirePutty as __require };","start":1667202984032,"end":1667202984904,"order":"normal"}]}
