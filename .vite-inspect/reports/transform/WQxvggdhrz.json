{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\twrite: write\n};\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar rfc4253 = require('./rfc4253');\nvar utils = require('../utils');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\n\nvar sshpriv = require('./ssh-private');\n\n/*JSSTYLED*/\nvar SSHKEY_RE = /^([a-z0-9-]+)[ \\t]+([a-zA-Z0-9+\\/]+[=]*)([ \\t]+([^ \\t][^\\n]*[\\n]*)?)?$/;\n/*JSSTYLED*/\nvar SSHKEY_RE2 = /^([a-z0-9-]+)[ \\t\\n]+([a-zA-Z0-9+\\/][a-zA-Z0-9+\\/ \\t\\n=]*)([^a-zA-Z0-9+\\/ \\t\\n=].*)?$/;\n\nfunction read(buf, options) {\n\tif (typeof (buf) !== 'string') {\n\t\tassert.buffer(buf, 'buf');\n\t\tbuf = buf.toString('ascii');\n\t}\n\n\tvar trimmed = buf.trim().replace(/[\\\\\\r]/g, '');\n\tvar m = trimmed.match(SSHKEY_RE);\n\tif (!m)\n\t\tm = trimmed.match(SSHKEY_RE2);\n\tassert.ok(m, 'key must match regex');\n\n\tvar type = rfc4253.algToKeyType(m[1]);\n\tvar kbuf = Buffer.from(m[2], 'base64');\n\n\t/*\n\t * This is a bit tricky. If we managed to parse the key and locate the\n\t * key comment with the regex, then do a non-partial read and assert\n\t * that we have consumed all bytes. If we couldn't locate the key\n\t * comment, though, there may be whitespace shenanigans going on that\n\t * have conjoined the comment to the rest of the key. We do a partial\n\t * read in this case to try to make the best out of a sorry situation.\n\t */\n\tvar key;\n\tvar ret = {};\n\tif (m[4]) {\n\t\ttry {\n\t\t\tkey = rfc4253.read(kbuf);\n\n\t\t} catch (e) {\n\t\t\tm = trimmed.match(SSHKEY_RE2);\n\t\t\tassert.ok(m, 'key must match regex');\n\t\t\tkbuf = Buffer.from(m[2], 'base64');\n\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t\t}\n\t} else {\n\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t}\n\n\tassert.strictEqual(type, key.type);\n\n\tif (m[4] && m[4].length > 0) {\n\t\tkey.comment = m[4];\n\n\t} else if (ret.consumed) {\n\t\t/*\n\t\t * Now the magic: trying to recover the key comment when it's\n\t\t * gotten conjoined to the key or otherwise shenanigan'd.\n\t\t *\n\t\t * Work out how much base64 we used, then drop all non-base64\n\t\t * chars from the beginning up to this point in the the string.\n\t\t * Then offset in this and try to make up for missing = chars.\n\t\t */\n\t\tvar data = m[2] + (m[3] ? m[3] : '');\n\t\tvar realOffset = Math.ceil(ret.consumed / 3) * 4;\n\t\tdata = data.slice(0, realOffset - 2). /*JSSTYLED*/\n\t\t    replace(/[^a-zA-Z0-9+\\/=]/g, '') +\n\t\t    data.slice(realOffset - 2);\n\n\t\tvar padding = ret.consumed % 3;\n\t\tif (padding > 0 &&\n\t\t    data.slice(realOffset - 1, realOffset) !== '=')\n\t\t\trealOffset--;\n\t\twhile (data.slice(realOffset, realOffset + 1) === '=')\n\t\t\trealOffset++;\n\n\t\t/* Finally, grab what we think is the comment & clean it up. */\n\t\tvar trailer = data.slice(realOffset);\n\t\ttrailer = trailer.replace(/[\\r\\n]/g, ' ').\n\t\t    replace(/^\\s+/, '');\n\t\tif (trailer.match(/^[a-zA-Z0-9]/))\n\t\t\tkey.comment = trailer;\n\t}\n\n\treturn (key);\n}\n\nfunction write(key, options) {\n\tassert.object(key);\n\tif (!Key.isKey(key))\n\t\tthrow (new Error('Must be a public key'));\n\n\tvar parts = [];\n\tvar alg = rfc4253.keyTypeToAlg(key);\n\tparts.push(alg);\n\n\tvar buf = rfc4253.write(key);\n\tparts.push(buf.toString('base64'));\n\n\tif (key.comment)\n\t\tparts.push(key.comment);\n\n\treturn (Buffer.from(parts.join(' ')));\n}\n","start":1667202983836,"end":1667202984004},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\n\nvar ssh;\nvar hasRequiredSsh;\n\nfunction requireSsh () {\n\tif (hasRequiredSsh) return ssh;\n\thasRequiredSsh = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tssh = {\n\t\tread: read,\n\t\twrite: write\n\t};\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar rfc4253 = require$$2();\n\tvar utils = require$$3();\n\tvar Key = require$$4();\n\tvar PrivateKey = require$$5();\n\n\tvar sshpriv = require$$6();\n\n\t/*JSSTYLED*/\n\tvar SSHKEY_RE = /^([a-z0-9-]+)[ \\t]+([a-zA-Z0-9+\\/]+[=]*)([ \\t]+([^ \\t][^\\n]*[\\n]*)?)?$/;\n\t/*JSSTYLED*/\n\tvar SSHKEY_RE2 = /^([a-z0-9-]+)[ \\t\\n]+([a-zA-Z0-9+\\/][a-zA-Z0-9+\\/ \\t\\n=]*)([^a-zA-Z0-9+\\/ \\t\\n=].*)?$/;\n\n\tfunction read(buf, options) {\n\t\tif (typeof (buf) !== 'string') {\n\t\t\tassert.buffer(buf, 'buf');\n\t\t\tbuf = buf.toString('ascii');\n\t\t}\n\n\t\tvar trimmed = buf.trim().replace(/[\\\\\\r]/g, '');\n\t\tvar m = trimmed.match(SSHKEY_RE);\n\t\tif (!m)\n\t\t\tm = trimmed.match(SSHKEY_RE2);\n\t\tassert.ok(m, 'key must match regex');\n\n\t\tvar type = rfc4253.algToKeyType(m[1]);\n\t\tvar kbuf = Buffer.from(m[2], 'base64');\n\n\t\t/*\n\t\t * This is a bit tricky. If we managed to parse the key and locate the\n\t\t * key comment with the regex, then do a non-partial read and assert\n\t\t * that we have consumed all bytes. If we couldn't locate the key\n\t\t * comment, though, there may be whitespace shenanigans going on that\n\t\t * have conjoined the comment to the rest of the key. We do a partial\n\t\t * read in this case to try to make the best out of a sorry situation.\n\t\t */\n\t\tvar key;\n\t\tvar ret = {};\n\t\tif (m[4]) {\n\t\t\ttry {\n\t\t\t\tkey = rfc4253.read(kbuf);\n\n\t\t\t} catch (e) {\n\t\t\t\tm = trimmed.match(SSHKEY_RE2);\n\t\t\t\tassert.ok(m, 'key must match regex');\n\t\t\t\tkbuf = Buffer.from(m[2], 'base64');\n\t\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t\t\t}\n\t\t} else {\n\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\n\t\t}\n\n\t\tassert.strictEqual(type, key.type);\n\n\t\tif (m[4] && m[4].length > 0) {\n\t\t\tkey.comment = m[4];\n\n\t\t} else if (ret.consumed) {\n\t\t\t/*\n\t\t\t * Now the magic: trying to recover the key comment when it's\n\t\t\t * gotten conjoined to the key or otherwise shenanigan'd.\n\t\t\t *\n\t\t\t * Work out how much base64 we used, then drop all non-base64\n\t\t\t * chars from the beginning up to this point in the the string.\n\t\t\t * Then offset in this and try to make up for missing = chars.\n\t\t\t */\n\t\t\tvar data = m[2] + (m[3] ? m[3] : '');\n\t\t\tvar realOffset = Math.ceil(ret.consumed / 3) * 4;\n\t\t\tdata = data.slice(0, realOffset - 2). /*JSSTYLED*/\n\t\t\t    replace(/[^a-zA-Z0-9+\\/=]/g, '') +\n\t\t\t    data.slice(realOffset - 2);\n\n\t\t\tvar padding = ret.consumed % 3;\n\t\t\tif (padding > 0 &&\n\t\t\t    data.slice(realOffset - 1, realOffset) !== '=')\n\t\t\t\trealOffset--;\n\t\t\twhile (data.slice(realOffset, realOffset + 1) === '=')\n\t\t\t\trealOffset++;\n\n\t\t\t/* Finally, grab what we think is the comment & clean it up. */\n\t\t\tvar trailer = data.slice(realOffset);\n\t\t\ttrailer = trailer.replace(/[\\r\\n]/g, ' ').\n\t\t\t    replace(/^\\s+/, '');\n\t\t\tif (trailer.match(/^[a-zA-Z0-9]/))\n\t\t\t\tkey.comment = trailer;\n\t\t}\n\n\t\treturn (key);\n\t}\n\n\tfunction write(key, options) {\n\t\tassert.object(key);\n\t\tif (!Key.isKey(key))\n\t\t\tthrow (new Error('Must be a public key'));\n\n\t\tvar parts = [];\n\t\tvar alg = rfc4253.keyTypeToAlg(key);\n\t\tparts.push(alg);\n\n\t\tvar buf = rfc4253.write(key);\n\t\tparts.push(buf.toString('base64'));\n\n\t\tif (key.comment)\n\t\t\tparts.push(key.comment);\n\n\t\treturn (Buffer.from(parts.join(' ')));\n\t}\n\treturn ssh;\n}\n\nexport { requireSsh as __require };","start":1667202984005,"end":1667202985041,"order":"normal"}]}
