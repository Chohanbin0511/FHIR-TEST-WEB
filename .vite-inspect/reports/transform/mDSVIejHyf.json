{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/index.js","transforms":[{"name":"vite:load-fallback","result":"var crypto = require(\"crypto\");\nvar BigInteger = require(\"jsbn\").BigInteger;\nvar ECPointFp = require(\"./lib/ec.js\").ECPointFp;\nvar Buffer = require(\"safer-buffer\").Buffer;\nexports.ECCurves = require(\"./lib/sec.js\");\n\n// zero prepad\nfunction unstupid(hex,len)\n{\n\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n}\n\nexports.ECKey = function(curve, key, isPublic)\n{\n  var priv;\n\tvar c = curve();\n\tvar n = c.getN();\n  var bytes = Math.floor(n.bitLength()/8);\n\n  if(key)\n  {\n    if(isPublic)\n    {\n      var curve = c.getCurve();\n//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n//      var y = key.slice(bytes+1);\n//      this.P = new ECPointFp(curve,\n//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n      this.P = curve.decodePointHex(key.toString(\"hex\"));\n    }else{\n      if(key.length != bytes) return false;\n      priv = new BigInteger(key.toString(\"hex\"), 16);      \n    }\n  }else{\n    var n1 = n.subtract(BigInteger.ONE);\n    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n    priv = r.mod(n1).add(BigInteger.ONE);\n    this.P = c.getG().multiply(priv);\n  }\n  if(this.P)\n  {\n//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n//  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n  }\n  if(priv)\n  {\n    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),\"hex\");\n    this.deriveSharedSecret = function(key)\n    {\n      if(!key || !key.P) return false;\n      var S = key.P.multiply(priv);\n      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n   }     \n  }\n}\n\n","start":1667202706992,"end":1667202707212},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as eccJsbn } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/jsbn/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/ec.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/sec.js?commonjs-wrapped\";\n\nvar hasRequiredEccJsbn;\n\nfunction requireEccJsbn () {\n\tif (hasRequiredEccJsbn) return eccJsbn;\n\thasRequiredEccJsbn = 1;\n\tvar crypto = require$$0;\n\tvar BigInteger = require$$1().BigInteger;\n\tvar ECPointFp = require$$2().ECPointFp;\n\tvar Buffer = require$$3().Buffer;\n\teccJsbn.ECCurves = require$$4();\n\n\t// zero prepad\n\tfunction unstupid(hex,len)\n\t{\n\t\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n\t}\n\n\teccJsbn.ECKey = function(curve, key, isPublic)\n\t{\n\t  var priv;\n\t\tvar c = curve();\n\t\tvar n = c.getN();\n\t  var bytes = Math.floor(n.bitLength()/8);\n\n\t  if(key)\n\t  {\n\t    if(isPublic)\n\t    {\n\t      var curve = c.getCurve();\n\t//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n\t//      var y = key.slice(bytes+1);\n\t//      this.P = new ECPointFp(curve,\n\t//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n\t//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n\t      this.P = curve.decodePointHex(key.toString(\"hex\"));\n\t    }else{\n\t      if(key.length != bytes) return false;\n\t      priv = new BigInteger(key.toString(\"hex\"), 16);      \n\t    }\n\t  }else{\n\t    var n1 = n.subtract(BigInteger.ONE);\n\t    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n\t    priv = r.mod(n1).add(BigInteger.ONE);\n\t    this.P = c.getG().multiply(priv);\n\t  }\n\t  if(this.P)\n\t  {\n\t//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n\t//  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n\t    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n\t  }\n\t  if(priv)\n\t  {\n\t    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),\"hex\");\n\t    this.deriveSharedSecret = function(key)\n\t    {\n\t      if(!key || !key.P) return false;\n\t      var S = key.P.multiply(priv);\n\t      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n\t   }     \n\t  }\n\t}\n\treturn eccJsbn;\n}\n\nexport { requireEccJsbn as __require };","start":1667202707212,"end":1667202707420,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as eccJsbn } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/jsbn/index.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/ec.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/sec.js?commonjs-wrapped\";\n\nvar hasRequiredEccJsbn;\n\nfunction requireEccJsbn () {\n\tif (hasRequiredEccJsbn) return eccJsbn;\n\thasRequiredEccJsbn = 1;\n\tvar crypto = require$$0;\n\tvar BigInteger = require$$1().BigInteger;\n\tvar ECPointFp = require$$2().ECPointFp;\n\tvar Buffer = require$$3().Buffer;\n\teccJsbn.ECCurves = require$$4();\n\n\t// zero prepad\n\tfunction unstupid(hex,len)\n\t{\n\t\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n\t}\n\n\teccJsbn.ECKey = function(curve, key, isPublic)\n\t{\n\t  var priv;\n\t\tvar c = curve();\n\t\tvar n = c.getN();\n\t  var bytes = Math.floor(n.bitLength()/8);\n\n\t  if(key)\n\t  {\n\t    if(isPublic)\n\t    {\n\t      var curve = c.getCurve();\n\t//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n\t//      var y = key.slice(bytes+1);\n\t//      this.P = new ECPointFp(curve,\n\t//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n\t//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n\t      this.P = curve.decodePointHex(key.toString(\"hex\"));\n\t    }else{\n\t      if(key.length != bytes) return false;\n\t      priv = new BigInteger(key.toString(\"hex\"), 16);      \n\t    }\n\t  }else{\n\t    var n1 = n.subtract(BigInteger.ONE);\n\t    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n\t    priv = r.mod(n1).add(BigInteger.ONE);\n\t    this.P = c.getG().multiply(priv);\n\t  }\n\t  if(this.P)\n\t  {\n\t//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n\t//  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n\t    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n\t  }\n\t  if(priv)\n\t  {\n\t    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),\"hex\");\n\t    this.deriveSharedSecret = function(key)\n\t    {\n\t      if(!key || !key.P) return false;\n\t      var S = key.P.multiply(priv);\n\t      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n\t   }     \n\t  }\n\t}\n\treturn eccJsbn;\n}\n\nexport { requireEccJsbn as __require };","start":1667202707420,"end":1667202707421,"order":"normal"}]}
