{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/uri-js/dist/es5/uri.all.js","transforms":[{"name":"vite:load-fallback","result":"/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n","start":1667202983941,"end":1667202984257},{"name":"commonjs","result":"/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as uri_allModule, exports as uri_all } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/uri-js/dist/es5/uri.all.js?commonjs-module\"\n\nvar hasRequiredUri_all;\n\nfunction requireUri_all () {\n\tif (hasRequiredUri_all) return uri_all;\n\thasRequiredUri_all = 1;\n\t(function (module, exports) {\n\t\t(function (global, factory) {\n\t\t\t'object' === 'object' && 'object' !== 'undefined' ? factory(exports) :\n\t\t\ttypeof undefined === 'function' && undefined.amd ? undefined(['exports'], factory) :\n\t\t\t(factory((global.URI = global.URI || {})));\n\t\t}(commonjsHelpers.commonjsGlobal, (function (exports) { 'use strict';\n\n\t\tfunction merge() {\n\t\t    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t        sets[_key] = arguments[_key];\n\t\t    }\n\n\t\t    if (sets.length > 1) {\n\t\t        sets[0] = sets[0].slice(0, -1);\n\t\t        var xl = sets.length - 1;\n\t\t        for (var x = 1; x < xl; ++x) {\n\t\t            sets[x] = sets[x].slice(1, -1);\n\t\t        }\n\t\t        sets[xl] = sets[xl].slice(1);\n\t\t        return sets.join('');\n\t\t    } else {\n\t\t        return sets[0];\n\t\t    }\n\t\t}\n\t\tfunction subexp(str) {\n\t\t    return \"(?:\" + str + \")\";\n\t\t}\n\t\tfunction typeOf(o) {\n\t\t    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n\t\t}\n\t\tfunction toUpperCase(str) {\n\t\t    return str.toUpperCase();\n\t\t}\n\t\tfunction toArray(obj) {\n\t\t    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n\t\t}\n\t\tfunction assign(target, source) {\n\t\t    var obj = target;\n\t\t    if (source) {\n\t\t        for (var key in source) {\n\t\t            obj[key] = source[key];\n\t\t        }\n\t\t    }\n\t\t    return obj;\n\t\t}\n\n\t\tfunction buildExps(isIRI) {\n\t\t    var ALPHA$$ = \"[A-Za-z]\",\n\t\t        CR$ = \"[\\\\x0D]\",\n\t\t        DIGIT$$ = \"[0-9]\",\n\t\t        DQUOTE$$ = \"[\\\\x22]\",\n\t\t        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n\t\t        //case-insensitive\n\t\t    LF$$ = \"[\\\\x0A]\",\n\t\t        SP$$ = \"[\\\\x20]\",\n\t\t        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n\t\t        //expanded\n\t\t    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\t        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\t        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\t        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n\t\t        //subset, excludes bidi control characters\n\t\t    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n\t\t        //subset\n\t\t    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\t        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\t        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\t        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\t        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n\t\t        //relaxed parsing rules\n\t\t    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\t        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\t        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\t        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n\t\t        //                           6( h16 \":\" ) ls32\n\t\t    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n\t\t        //                      \"::\" 5( h16 \":\" ) ls32\n\t\t    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n\t\t        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\t    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n\t\t        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\t    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n\t\t        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\t    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n\t\t        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\t    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n\t\t        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\t    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n\t\t        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\t    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n\t\t        //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\t    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\t        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n\t\t        //RFC 6874\n\t\t    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n\t\t        //RFC 6874\n\t\t    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n\t\t        //RFC 6874, with relaxed parsing rules\n\t\t    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\t        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n\t\t        //RFC 6874\n\t\t    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\t        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\t        PORT$ = subexp(DIGIT$$ + \"*\"),\n\t\t        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\t        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\t        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\t        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\t        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\t        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\t        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n\t\t        //simplified\n\t\t    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n\t\t        //simplified\n\t\t    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n\t\t        //simplified\n\t\t    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\t        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\t        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\t        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\t        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\t        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\t        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\t        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\t        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\t        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\t\t        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\t        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\t        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\t        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\t        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n\t\t    return {\n\t\t        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\t        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\t        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\t        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\t        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\t        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\t        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\t        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\t        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n\t\t        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\t        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n\t\t        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\t        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n\t\t    };\n\t\t}\n\t\tvar URI_PROTOCOL = buildExps(false);\n\n\t\tvar IRI_PROTOCOL = buildExps(true);\n\n\t\tvar slicedToArray = function () {\n\t\t  function sliceIterator(arr, i) {\n\t\t    var _arr = [];\n\t\t    var _n = true;\n\t\t    var _d = false;\n\t\t    var _e = undefined;\n\n\t\t    try {\n\t\t      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t\t        _arr.push(_s.value);\n\n\t\t        if (i && _arr.length === i) break;\n\t\t      }\n\t\t    } catch (err) {\n\t\t      _d = true;\n\t\t      _e = err;\n\t\t    } finally {\n\t\t      try {\n\t\t        if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t\t      } finally {\n\t\t        if (_d) throw _e;\n\t\t      }\n\t\t    }\n\n\t\t    return _arr;\n\t\t  }\n\n\t\t  return function (arr, i) {\n\t\t    if (Array.isArray(arr)) {\n\t\t      return arr;\n\t\t    } else if (Symbol.iterator in Object(arr)) {\n\t\t      return sliceIterator(arr, i);\n\t\t    } else {\n\t\t      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t\t    }\n\t\t  };\n\t\t}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tvar toConsumableArray = function (arr) {\n\t\t  if (Array.isArray(arr)) {\n\t\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n\t\t    return arr2;\n\t\t  } else {\n\t\t    return Array.from(arr);\n\t\t  }\n\t\t};\n\n\t\t/** Highest positive signed 32-bit float value */\n\n\t\tvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n\t\t/** Bootstring parameters */\n\t\tvar base = 36;\n\t\tvar tMin = 1;\n\t\tvar tMax = 26;\n\t\tvar skew = 38;\n\t\tvar damp = 700;\n\t\tvar initialBias = 72;\n\t\tvar initialN = 128; // 0x80\n\t\tvar delimiter = '-'; // '\\x2D'\n\n\t\t/** Regular expressions */\n\t\tvar regexPunycode = /^xn--/;\n\t\tvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n\t\tvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n\t\t/** Error messages */\n\t\tvar errors = {\n\t\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t\t'invalid-input': 'Invalid input'\n\t\t};\n\n\t\t/** Convenience shortcuts */\n\t\tvar baseMinusTMin = base - tMin;\n\t\tvar floor = Math.floor;\n\t\tvar stringFromCharCode = String.fromCharCode;\n\n\t\t/*--------------------------------------------------------------------------*/\n\n\t\t/**\n\t\t * A generic error utility function.\n\t\t * @private\n\t\t * @param {String} type The error type.\n\t\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t\t */\n\t\tfunction error$1(type) {\n\t\t\tthrow new RangeError(errors[type]);\n\t\t}\n\n\t\t/**\n\t\t * A generic `Array#map` utility function.\n\t\t * @private\n\t\t * @param {Array} array The array to iterate over.\n\t\t * @param {Function} callback The function that gets called for every array\n\t\t * item.\n\t\t * @returns {Array} A new array of values returned by the callback function.\n\t\t */\n\t\tfunction map(array, fn) {\n\t\t\tvar result = [];\n\t\t\tvar length = array.length;\n\t\t\twhile (length--) {\n\t\t\t\tresult[length] = fn(array[length]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t\t * addresses.\n\t\t * @private\n\t\t * @param {String} domain The domain name or email address.\n\t\t * @param {Function} callback The function that gets called for every\n\t\t * character.\n\t\t * @returns {Array} A new string of characters returned by the callback\n\t\t * function.\n\t\t */\n\t\tfunction mapDomain(string, fn) {\n\t\t\tvar parts = string.split('@');\n\t\t\tvar result = '';\n\t\t\tif (parts.length > 1) {\n\t\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\t\tresult = parts[0] + '@';\n\t\t\t\tstring = parts[1];\n\t\t\t}\n\t\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\t\tvar labels = string.split('.');\n\t\t\tvar encoded = map(labels, fn).join('.');\n\t\t\treturn result + encoded;\n\t\t}\n\n\t\t/**\n\t\t * Creates an array containing the numeric code points of each Unicode\n\t\t * character in the string. While JavaScript uses UCS-2 internally,\n\t\t * this function will convert a pair of surrogate halves (each of which\n\t\t * UCS-2 exposes as separate characters) into a single code point,\n\t\t * matching UTF-16.\n\t\t * @see `punycode.ucs2.encode`\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode.ucs2\n\t\t * @name decode\n\t\t * @param {String} string The Unicode input string (UCS-2).\n\t\t * @returns {Array} The new array of code points.\n\t\t */\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [];\n\t\t\tvar counter = 0;\n\t\t\tvar length = string.length;\n\t\t\twhile (counter < length) {\n\t\t\t\tvar value = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t\t// Low surrogate.\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n\t\t * Creates a string based on an array of numeric code points.\n\t\t * @see `punycode.ucs2.decode`\n\t\t * @memberOf punycode.ucs2\n\t\t * @name encode\n\t\t * @param {Array} codePoints The array of numeric code points.\n\t\t * @returns {String} The new Unicode string (UCS-2).\n\t\t */\n\t\tvar ucs2encode = function ucs2encode(array) {\n\t\t\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n\t\t};\n\n\t\t/**\n\t\t * Converts a basic code point into a digit/integer.\n\t\t * @see `digitToBasic()`\n\t\t * @private\n\t\t * @param {Number} codePoint The basic numeric code point value.\n\t\t * @returns {Number} The numeric value of a basic code point (for use in\n\t\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t\t * the code point does not represent a value.\n\t\t */\n\t\tvar basicToDigit = function basicToDigit(codePoint) {\n\t\t\tif (codePoint - 0x30 < 0x0A) {\n\t\t\t\treturn codePoint - 0x16;\n\t\t\t}\n\t\t\tif (codePoint - 0x41 < 0x1A) {\n\t\t\t\treturn codePoint - 0x41;\n\t\t\t}\n\t\t\tif (codePoint - 0x61 < 0x1A) {\n\t\t\t\treturn codePoint - 0x61;\n\t\t\t}\n\t\t\treturn base;\n\t\t};\n\n\t\t/**\n\t\t * Converts a digit/integer into a basic code point.\n\t\t * @see `basicToDigit()`\n\t\t * @private\n\t\t * @param {Number} digit The numeric value of a basic code point.\n\t\t * @returns {Number} The basic code point whose value (when used for\n\t\t * representing integers) is `digit`, which needs to be in the range\n\t\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t\t * used; else, the lowercase form is used. The behavior is undefined\n\t\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t\t */\n\t\tvar digitToBasic = function digitToBasic(digit, flag) {\n\t\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t\t// 26..35 map to ASCII 0..9\n\t\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t\t};\n\n\t\t/**\n\t\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t\t * @private\n\t\t */\n\t\tvar adapt = function adapt(delta, numPoints, firstTime) {\n\t\t\tvar k = 0;\n\t\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\t\tdelta += floor(delta / numPoints);\n\t\t\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t\t}\n\t\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t\t};\n\n\t\t/**\n\t\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t\t * symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t\t * @returns {String} The resulting string of Unicode symbols.\n\t\t */\n\t\tvar decode = function decode(input) {\n\t\t\t// Don't use UCS-2.\n\t\t\tvar output = [];\n\t\t\tvar inputLength = input.length;\n\t\t\tvar i = 0;\n\t\t\tvar n = initialN;\n\t\t\tvar bias = initialBias;\n\n\t\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t\t// the first basic code points to the output.\n\n\t\t\tvar basic = input.lastIndexOf(delimiter);\n\t\t\tif (basic < 0) {\n\t\t\t\tbasic = 0;\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < basic; ++j) {\n\t\t\t\t// if it's not a basic code point\n\t\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\t\terror$1('not-basic');\n\t\t\t\t}\n\t\t\t\toutput.push(input.charCodeAt(j));\n\t\t\t}\n\n\t\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t\t// points were copied; start at the beginning otherwise.\n\n\t\t\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t\t// value at the end to obtain `delta`.\n\t\t\t\tvar oldi = i;\n\t\t\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\t\terror$1('invalid-input');\n\t\t\t\t\t}\n\n\t\t\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\t\terror$1('overflow');\n\t\t\t\t\t}\n\n\t\t\t\t\ti += digit * w;\n\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\t\t\tif (digit < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\t\terror$1('overflow');\n\t\t\t\t\t}\n\n\t\t\t\t\tw *= baseMinusT;\n\t\t\t\t}\n\n\t\t\t\tvar out = output.length + 1;\n\t\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\n\t\t\t\tn += floor(i / out);\n\t\t\t\ti %= out;\n\n\t\t\t\t// Insert `n` at position `i` of the output.\n\t\t\t\toutput.splice(i++, 0, n);\n\t\t\t}\n\n\t\t\treturn String.fromCodePoint.apply(String, output);\n\t\t};\n\n\t\t/**\n\t\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t\t * Punycode string of ASCII-only symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The string of Unicode symbols.\n\t\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t\t */\n\t\tvar encode = function encode(input) {\n\t\t\tvar output = [];\n\n\t\t\t// Convert the input in UCS-2 to an array of Unicode code points.\n\t\t\tinput = ucs2decode(input);\n\n\t\t\t// Cache the length.\n\t\t\tvar inputLength = input.length;\n\n\t\t\t// Initialize the state.\n\t\t\tvar n = initialN;\n\t\t\tvar delta = 0;\n\t\t\tvar bias = initialBias;\n\n\t\t\t// Handle the basic code points.\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar basicLength = output.length;\n\t\t\tvar handledCPCount = basicLength;\n\n\t\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t\t// `basicLength` is the number of basic code points.\n\n\t\t\t// Finish the basic string with a delimiter unless it's empty.\n\t\t\tif (basicLength) {\n\t\t\t\toutput.push(delimiter);\n\t\t\t}\n\n\t\t\t// Main encoding loop:\n\t\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t\t// larger one:\n\t\t\t\tvar m = maxInt;\n\t\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\t\tvar _didIteratorError2 = false;\n\t\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\t\t\tm = currentValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t\t\t// but guard against overflow.\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t_iteratorError2 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\n\t\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\t\tn = m;\n\n\t\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\t\tvar _didIteratorError3 = false;\n\t\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\t\t\terror$1('overflow');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\t\t\tvar q = delta;\n\t\t\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\t\t\tdelta = 0;\n\t\t\t\t\t\t\t++handledCPCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t\t_iteratorError3 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t++delta;\n\t\t\t\t++n;\n\t\t\t}\n\t\t\treturn output.join('');\n\t\t};\n\n\t\t/**\n\t\t * Converts a Punycode string representing a domain name or an email address\n\t\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t\t * it doesn't matter if you call it on a string that has already been\n\t\t * converted to Unicode.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycoded domain name or email address to\n\t\t * convert to Unicode.\n\t\t * @returns {String} The Unicode representation of the given Punycode\n\t\t * string.\n\t\t */\n\t\tvar toUnicode = function toUnicode(input) {\n\t\t\treturn mapDomain(input, function (string) {\n\t\t\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Converts a Unicode string representing a domain name or an email address to\n\t\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t\t * ASCII.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The domain name or email address to convert, as a\n\t\t * Unicode string.\n\t\t * @returns {String} The Punycode representation of the given domain name or\n\t\t * email address.\n\t\t */\n\t\tvar toASCII = function toASCII(input) {\n\t\t\treturn mapDomain(input, function (string) {\n\t\t\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t\t\t});\n\t\t};\n\n\t\t/*--------------------------------------------------------------------------*/\n\n\t\t/** Define the public API */\n\t\tvar punycode = {\n\t\t\t/**\n\t\t  * A string representing the current Punycode.js version number.\n\t\t  * @memberOf punycode\n\t\t  * @type String\n\t\t  */\n\t\t\t'version': '2.1.0',\n\t\t\t/**\n\t\t  * An object of methods to convert from JavaScript's internal character\n\t\t  * representation (UCS-2) to Unicode code points, and back.\n\t\t  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t  * @memberOf punycode\n\t\t  * @type Object\n\t\t  */\n\t\t\t'ucs2': {\n\t\t\t\t'decode': ucs2decode,\n\t\t\t\t'encode': ucs2encode\n\t\t\t},\n\t\t\t'decode': decode,\n\t\t\t'encode': encode,\n\t\t\t'toASCII': toASCII,\n\t\t\t'toUnicode': toUnicode\n\t\t};\n\n\t\t/**\n\t\t * URI.js\n\t\t *\n\t\t * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n\t\t * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n\t\t * @see http://github.com/garycourt/uri-js\n\t\t */\n\t\t/**\n\t\t * Copyright 2011 Gary Court. All rights reserved.\n\t\t *\n\t\t * Redistribution and use in source and binary forms, with or without modification, are\n\t\t * permitted provided that the following conditions are met:\n\t\t *\n\t\t *    1. Redistributions of source code must retain the above copyright notice, this list of\n\t\t *       conditions and the following disclaimer.\n\t\t *\n\t\t *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n\t\t *       of conditions and the following disclaimer in the documentation and/or other materials\n\t\t *       provided with the distribution.\n\t\t *\n\t\t * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\t\t * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n\t\t * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n\t\t * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n\t\t * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\t\t * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n\t\t * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n\t\t * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n\t\t * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t *\n\t\t * The views and conclusions contained in the software and documentation are those of the\n\t\t * authors and should not be interpreted as representing official policies, either expressed\n\t\t * or implied, of Gary Court.\n\t\t */\n\t\tvar SCHEMES = {};\n\t\tfunction pctEncChar(chr) {\n\t\t    var c = chr.charCodeAt(0);\n\t\t    var e = void 0;\n\t\t    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n\t\t    return e;\n\t\t}\n\t\tfunction pctDecChars(str) {\n\t\t    var newStr = \"\";\n\t\t    var i = 0;\n\t\t    var il = str.length;\n\t\t    while (i < il) {\n\t\t        var c = parseInt(str.substr(i + 1, 2), 16);\n\t\t        if (c < 128) {\n\t\t            newStr += String.fromCharCode(c);\n\t\t            i += 3;\n\t\t        } else if (c >= 194 && c < 224) {\n\t\t            if (il - i >= 6) {\n\t\t                var c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n\t\t            } else {\n\t\t                newStr += str.substr(i, 6);\n\t\t            }\n\t\t            i += 6;\n\t\t        } else if (c >= 224) {\n\t\t            if (il - i >= 9) {\n\t\t                var _c = parseInt(str.substr(i + 4, 2), 16);\n\t\t                var c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n\t\t            } else {\n\t\t                newStr += str.substr(i, 9);\n\t\t            }\n\t\t            i += 9;\n\t\t        } else {\n\t\t            newStr += str.substr(i, 3);\n\t\t            i += 3;\n\t\t        }\n\t\t    }\n\t\t    return newStr;\n\t\t}\n\t\tfunction _normalizeComponentEncoding(components, protocol) {\n\t\t    function decodeUnreserved(str) {\n\t\t        var decStr = pctDecChars(str);\n\t\t        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n\t\t    }\n\t\t    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\t\t    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\t\t    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\t\t    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\t\t    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\t\t    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\t\t    return components;\n\t\t}\n\n\t\tfunction _stripLeadingZeros(str) {\n\t\t    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n\t\t}\n\t\tfunction _normalizeIPv4(host, protocol) {\n\t\t    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n\t\t    var _matches = slicedToArray(matches, 2),\n\t\t        address = _matches[1];\n\n\t\t    if (address) {\n\t\t        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t\t    } else {\n\t\t        return host;\n\t\t    }\n\t\t}\n\t\tfunction _normalizeIPv6(host, protocol) {\n\t\t    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n\t\t    var _matches2 = slicedToArray(matches, 3),\n\t\t        address = _matches2[1],\n\t\t        zone = _matches2[2];\n\n\t\t    if (address) {\n\t\t        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n\t\t            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n\t\t            last = _address$toLowerCase$2[0],\n\t\t            first = _address$toLowerCase$2[1];\n\n\t\t        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\t        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\t        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\t        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\t        var lastFieldsStart = lastFields.length - fieldCount;\n\t\t        var fields = Array(fieldCount);\n\t\t        for (var x = 0; x < fieldCount; ++x) {\n\t\t            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t        }\n\t\t        if (isLastFieldIPv4Address) {\n\t\t            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t        }\n\t\t        var allZeroFields = fields.reduce(function (acc, field, index) {\n\t\t            if (!field || field === \"0\") {\n\t\t                var lastLongest = acc[acc.length - 1];\n\t\t                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t                    lastLongest.length++;\n\t\t                } else {\n\t\t                    acc.push({ index: index, length: 1 });\n\t\t                }\n\t\t            }\n\t\t            return acc;\n\t\t        }, []);\n\t\t        var longestZeroFields = allZeroFields.sort(function (a, b) {\n\t\t            return b.length - a.length;\n\t\t        })[0];\n\t\t        var newHost = void 0;\n\t\t        if (longestZeroFields && longestZeroFields.length > 1) {\n\t\t            var newFirst = fields.slice(0, longestZeroFields.index);\n\t\t            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t        } else {\n\t\t            newHost = fields.join(\":\");\n\t\t        }\n\t\t        if (zone) {\n\t\t            newHost += \"%\" + zone;\n\t\t        }\n\t\t        return newHost;\n\t\t    } else {\n\t\t        return host;\n\t\t    }\n\t\t}\n\t\tvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n\t\tvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n\t\tfunction parse(uriString) {\n\t\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\t    var components = {};\n\t\t    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n\t\t    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\t\t    var matches = uriString.match(URI_PARSE);\n\t\t    if (matches) {\n\t\t        if (NO_MATCH_IS_UNDEFINED) {\n\t\t            //store each component\n\t\t            components.scheme = matches[1];\n\t\t            components.userinfo = matches[3];\n\t\t            components.host = matches[4];\n\t\t            components.port = parseInt(matches[5], 10);\n\t\t            components.path = matches[6] || \"\";\n\t\t            components.query = matches[7];\n\t\t            components.fragment = matches[8];\n\t\t            //fix port number\n\t\t            if (isNaN(components.port)) {\n\t\t                components.port = matches[5];\n\t\t            }\n\t\t        } else {\n\t\t            //IE FIX for improper RegExp matching\n\t\t            //store each component\n\t\t            components.scheme = matches[1] || undefined;\n\t\t            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n\t\t            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n\t\t            components.port = parseInt(matches[5], 10);\n\t\t            components.path = matches[6] || \"\";\n\t\t            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n\t\t            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n\t\t            //fix port number\n\t\t            if (isNaN(components.port)) {\n\t\t                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n\t\t            }\n\t\t        }\n\t\t        if (components.host) {\n\t\t            //normalize IP hosts\n\t\t            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t        }\n\t\t        //determine reference type\n\t\t        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t            components.reference = \"same-document\";\n\t\t        } else if (components.scheme === undefined) {\n\t\t            components.reference = \"relative\";\n\t\t        } else if (components.fragment === undefined) {\n\t\t            components.reference = \"absolute\";\n\t\t        } else {\n\t\t            components.reference = \"uri\";\n\t\t        }\n\t\t        //check for reference errors\n\t\t        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t        }\n\t\t        //find scheme handler\n\t\t        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\t\t        //check if scheme can't handle IRIs\n\t\t        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t            //if host component is a domain name\n\t\t            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n\t\t                //convert Unicode IDN -> ASCII IDN\n\t\t                try {\n\t\t                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t                } catch (e) {\n\t\t                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t                }\n\t\t            }\n\t\t            //convert IRI -> URI\n\t\t            _normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t        } else {\n\t\t            //normalize encodings\n\t\t            _normalizeComponentEncoding(components, protocol);\n\t\t        }\n\t\t        //perform scheme specific parsing\n\t\t        if (schemeHandler && schemeHandler.parse) {\n\t\t            schemeHandler.parse(components, options);\n\t\t        }\n\t\t    } else {\n\t\t        components.error = components.error || \"URI can not be parsed.\";\n\t\t    }\n\t\t    return components;\n\t\t}\n\n\t\tfunction _recomposeAuthority(components, options) {\n\t\t    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n\t\t    var uriTokens = [];\n\t\t    if (components.userinfo !== undefined) {\n\t\t        uriTokens.push(components.userinfo);\n\t\t        uriTokens.push(\"@\");\n\t\t    }\n\t\t    if (components.host !== undefined) {\n\t\t        //normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\t        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n\t\t            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n\t\t        }));\n\t\t    }\n\t\t    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\t        uriTokens.push(\":\");\n\t\t        uriTokens.push(String(components.port));\n\t\t    }\n\t\t    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n\t\t}\n\n\t\tvar RDS1 = /^\\.\\.?\\//;\n\t\tvar RDS2 = /^\\/\\.(\\/|$)/;\n\t\tvar RDS3 = /^\\/\\.\\.(\\/|$)/;\n\t\tvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\t\tfunction removeDotSegments(input) {\n\t\t    var output = [];\n\t\t    while (input.length) {\n\t\t        if (input.match(RDS1)) {\n\t\t            input = input.replace(RDS1, \"\");\n\t\t        } else if (input.match(RDS2)) {\n\t\t            input = input.replace(RDS2, \"/\");\n\t\t        } else if (input.match(RDS3)) {\n\t\t            input = input.replace(RDS3, \"/\");\n\t\t            output.pop();\n\t\t        } else if (input === \".\" || input === \"..\") {\n\t\t            input = \"\";\n\t\t        } else {\n\t\t            var im = input.match(RDS5);\n\t\t            if (im) {\n\t\t                var s = im[0];\n\t\t                input = input.slice(s.length);\n\t\t                output.push(s);\n\t\t            } else {\n\t\t                throw new Error(\"Unexpected dot segment condition\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    return output.join(\"\");\n\t\t}\n\n\t\tfunction serialize(components) {\n\t\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\t    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n\t\t    var uriTokens = [];\n\t\t    //find scheme handler\n\t\t    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\t\t    //perform scheme specific serialization\n\t\t    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\t\t    if (components.host) {\n\t\t        //if host component is an IPv6 address\n\t\t        if (protocol.IPV6ADDRESS.test(components.host)) {}\n\t\t        //TODO: normalize IPv6 address as per RFC 5952\n\n\t\t        //if host component is a domain name\n\t\t        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n\t\t                //convert IDN via punycode\n\t\t                try {\n\t\t                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n\t\t                } catch (e) {\n\t\t                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t                }\n\t\t            }\n\t\t    }\n\t\t    //normalize encoding\n\t\t    _normalizeComponentEncoding(components, protocol);\n\t\t    if (options.reference !== \"suffix\" && components.scheme) {\n\t\t        uriTokens.push(components.scheme);\n\t\t        uriTokens.push(\":\");\n\t\t    }\n\t\t    var authority = _recomposeAuthority(components, options);\n\t\t    if (authority !== undefined) {\n\t\t        if (options.reference !== \"suffix\") {\n\t\t            uriTokens.push(\"//\");\n\t\t        }\n\t\t        uriTokens.push(authority);\n\t\t        if (components.path && components.path.charAt(0) !== \"/\") {\n\t\t            uriTokens.push(\"/\");\n\t\t        }\n\t\t    }\n\t\t    if (components.path !== undefined) {\n\t\t        var s = components.path;\n\t\t        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t            s = removeDotSegments(s);\n\t\t        }\n\t\t        if (authority === undefined) {\n\t\t            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n\t\t        }\n\t\t        uriTokens.push(s);\n\t\t    }\n\t\t    if (components.query !== undefined) {\n\t\t        uriTokens.push(\"?\");\n\t\t        uriTokens.push(components.query);\n\t\t    }\n\t\t    if (components.fragment !== undefined) {\n\t\t        uriTokens.push(\"#\");\n\t\t        uriTokens.push(components.fragment);\n\t\t    }\n\t\t    return uriTokens.join(\"\"); //merge tokens into a string\n\t\t}\n\n\t\tfunction resolveComponents(base, relative) {\n\t\t    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\t    var skipNormalization = arguments[3];\n\n\t\t    var target = {};\n\t\t    if (!skipNormalization) {\n\t\t        base = parse(serialize(base, options), options); //normalize base components\n\t\t        relative = parse(serialize(relative, options), options); //normalize relative components\n\t\t    }\n\t\t    options = options || {};\n\t\t    if (!options.tolerant && relative.scheme) {\n\t\t        target.scheme = relative.scheme;\n\t\t        //target.authority = relative.authority;\n\t\t        target.userinfo = relative.userinfo;\n\t\t        target.host = relative.host;\n\t\t        target.port = relative.port;\n\t\t        target.path = removeDotSegments(relative.path || \"\");\n\t\t        target.query = relative.query;\n\t\t    } else {\n\t\t        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t            //target.authority = relative.authority;\n\t\t            target.userinfo = relative.userinfo;\n\t\t            target.host = relative.host;\n\t\t            target.port = relative.port;\n\t\t            target.path = removeDotSegments(relative.path || \"\");\n\t\t            target.query = relative.query;\n\t\t        } else {\n\t\t            if (!relative.path) {\n\t\t                target.path = base.path;\n\t\t                if (relative.query !== undefined) {\n\t\t                    target.query = relative.query;\n\t\t                } else {\n\t\t                    target.query = base.query;\n\t\t                }\n\t\t            } else {\n\t\t                if (relative.path.charAt(0) === \"/\") {\n\t\t                    target.path = removeDotSegments(relative.path);\n\t\t                } else {\n\t\t                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t                        target.path = \"/\" + relative.path;\n\t\t                    } else if (!base.path) {\n\t\t                        target.path = relative.path;\n\t\t                    } else {\n\t\t                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t                    }\n\t\t                    target.path = removeDotSegments(target.path);\n\t\t                }\n\t\t                target.query = relative.query;\n\t\t            }\n\t\t            //target.authority = base.authority;\n\t\t            target.userinfo = base.userinfo;\n\t\t            target.host = base.host;\n\t\t            target.port = base.port;\n\t\t        }\n\t\t        target.scheme = base.scheme;\n\t\t    }\n\t\t    target.fragment = relative.fragment;\n\t\t    return target;\n\t\t}\n\n\t\tfunction resolve(baseURI, relativeURI, options) {\n\t\t    var schemelessOptions = assign({ scheme: 'null' }, options);\n\t\t    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n\t\t}\n\n\t\tfunction normalize(uri, options) {\n\t\t    if (typeof uri === \"string\") {\n\t\t        uri = serialize(parse(uri, options), options);\n\t\t    } else if (typeOf(uri) === \"object\") {\n\t\t        uri = parse(serialize(uri, options), options);\n\t\t    }\n\t\t    return uri;\n\t\t}\n\n\t\tfunction equal(uriA, uriB, options) {\n\t\t    if (typeof uriA === \"string\") {\n\t\t        uriA = serialize(parse(uriA, options), options);\n\t\t    } else if (typeOf(uriA) === \"object\") {\n\t\t        uriA = serialize(uriA, options);\n\t\t    }\n\t\t    if (typeof uriB === \"string\") {\n\t\t        uriB = serialize(parse(uriB, options), options);\n\t\t    } else if (typeOf(uriB) === \"object\") {\n\t\t        uriB = serialize(uriB, options);\n\t\t    }\n\t\t    return uriA === uriB;\n\t\t}\n\n\t\tfunction escapeComponent(str, options) {\n\t\t    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n\t\t}\n\n\t\tfunction unescapeComponent(str, options) {\n\t\t    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n\t\t}\n\n\t\tvar handler = {\n\t\t    scheme: \"http\",\n\t\t    domainHost: true,\n\t\t    parse: function parse(components, options) {\n\t\t        //report missing host\n\t\t        if (!components.host) {\n\t\t            components.error = components.error || \"HTTP URIs must have a host.\";\n\t\t        }\n\t\t        return components;\n\t\t    },\n\t\t    serialize: function serialize(components, options) {\n\t\t        var secure = String(components.scheme).toLowerCase() === \"https\";\n\t\t        //normalize the default port\n\t\t        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t            components.port = undefined;\n\t\t        }\n\t\t        //normalize the empty path\n\t\t        if (!components.path) {\n\t\t            components.path = \"/\";\n\t\t        }\n\t\t        //NOTE: We do not parse query strings for HTTP URIs\n\t\t        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t        //and not the HTTP spec.\n\t\t        return components;\n\t\t    }\n\t\t};\n\n\t\tvar handler$1 = {\n\t\t    scheme: \"https\",\n\t\t    domainHost: handler.domainHost,\n\t\t    parse: handler.parse,\n\t\t    serialize: handler.serialize\n\t\t};\n\n\t\tfunction isSecure(wsComponents) {\n\t\t    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n\t\t}\n\t\t//RFC 6455\n\t\tvar handler$2 = {\n\t\t    scheme: \"ws\",\n\t\t    domainHost: true,\n\t\t    parse: function parse(components, options) {\n\t\t        var wsComponents = components;\n\t\t        //indicate if the secure flag is set\n\t\t        wsComponents.secure = isSecure(wsComponents);\n\t\t        //construct resouce name\n\t\t        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\t        wsComponents.path = undefined;\n\t\t        wsComponents.query = undefined;\n\t\t        return wsComponents;\n\t\t    },\n\t\t    serialize: function serialize(wsComponents, options) {\n\t\t        //normalize the default port\n\t\t        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t            wsComponents.port = undefined;\n\t\t        }\n\t\t        //ensure scheme matches secure flag\n\t\t        if (typeof wsComponents.secure === 'boolean') {\n\t\t            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n\t\t            wsComponents.secure = undefined;\n\t\t        }\n\t\t        //reconstruct path from resource name\n\t\t        if (wsComponents.resourceName) {\n\t\t            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n\t\t                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n\t\t                path = _wsComponents$resourc2[0],\n\t\t                query = _wsComponents$resourc2[1];\n\n\t\t            wsComponents.path = path && path !== '/' ? path : undefined;\n\t\t            wsComponents.query = query;\n\t\t            wsComponents.resourceName = undefined;\n\t\t        }\n\t\t        //forbid fragment component\n\t\t        wsComponents.fragment = undefined;\n\t\t        return wsComponents;\n\t\t    }\n\t\t};\n\n\t\tvar handler$3 = {\n\t\t    scheme: \"wss\",\n\t\t    domainHost: handler$2.domainHost,\n\t\t    parse: handler$2.parse,\n\t\t    serialize: handler$2.serialize\n\t\t};\n\n\t\tvar O = {};\n\t\tvar isIRI = true;\n\t\t//RFC 3986\n\t\tvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n\t\tvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n\t\tvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n\t\t//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n\t\t//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n\t\t//const WSP$$ = \"[\\\\x20\\\\x09]\";\n\t\t//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n\t\t//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n\t\t//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n\t\t//const WSP$$ = \"[\\\\x20\\\\x09]\";\n\t\t//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n\t\t//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n\t\t//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n\t\t//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n\t\tvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n\t\tvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n\t\tvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\n\t\tvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n\t\tvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n\t\tvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n\t\tvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n\t\tvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n\t\tvar NOT_HFVALUE = NOT_HFNAME;\n\t\tfunction decodeUnreserved(str) {\n\t\t    var decStr = pctDecChars(str);\n\t\t    return !decStr.match(UNRESERVED) ? str : decStr;\n\t\t}\n\t\tvar handler$4 = {\n\t\t    scheme: \"mailto\",\n\t\t    parse: function parse$$1(components, options) {\n\t\t        var mailtoComponents = components;\n\t\t        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n\t\t        mailtoComponents.path = undefined;\n\t\t        if (mailtoComponents.query) {\n\t\t            var unknownHeaders = false;\n\t\t            var headers = {};\n\t\t            var hfields = mailtoComponents.query.split(\"&\");\n\t\t            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t                var hfield = hfields[x].split(\"=\");\n\t\t                switch (hfield[0]) {\n\t\t                    case \"to\":\n\t\t                        var toAddrs = hfield[1].split(\",\");\n\t\t                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n\t\t                            to.push(toAddrs[_x]);\n\t\t                        }\n\t\t                        break;\n\t\t                    case \"subject\":\n\t\t                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t                        break;\n\t\t                    case \"body\":\n\t\t                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t                        break;\n\t\t                    default:\n\t\t                        unknownHeaders = true;\n\t\t                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t                        break;\n\t\t                }\n\t\t            }\n\t\t            if (unknownHeaders) mailtoComponents.headers = headers;\n\t\t        }\n\t\t        mailtoComponents.query = undefined;\n\t\t        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n\t\t            var addr = to[_x2].split(\"@\");\n\t\t            addr[0] = unescapeComponent(addr[0]);\n\t\t            if (!options.unicodeSupport) {\n\t\t                //convert Unicode IDN -> ASCII IDN\n\t\t                try {\n\t\t                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t                } catch (e) {\n\t\t                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t                }\n\t\t            } else {\n\t\t                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t            }\n\t\t            to[_x2] = addr.join(\"@\");\n\t\t        }\n\t\t        return mailtoComponents;\n\t\t    },\n\t\t    serialize: function serialize$$1(mailtoComponents, options) {\n\t\t        var components = mailtoComponents;\n\t\t        var to = toArray(mailtoComponents.to);\n\t\t        if (to) {\n\t\t            for (var x = 0, xl = to.length; x < xl; ++x) {\n\t\t                var toAddr = String(to[x]);\n\t\t                var atIdx = toAddr.lastIndexOf(\"@\");\n\t\t                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t                var domain = toAddr.slice(atIdx + 1);\n\t\t                //convert IDN via punycode\n\t\t                try {\n\t\t                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n\t\t                } catch (e) {\n\t\t                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t                }\n\t\t                to[x] = localPart + \"@\" + domain;\n\t\t            }\n\t\t            components.path = to.join(\",\");\n\t\t        }\n\t\t        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\t\t        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\t        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\t\t        var fields = [];\n\t\t        for (var name in headers) {\n\t\t            if (headers[name] !== O[name]) {\n\t\t                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n\t\t            }\n\t\t        }\n\t\t        if (fields.length) {\n\t\t            components.query = fields.join(\"&\");\n\t\t        }\n\t\t        return components;\n\t\t    }\n\t\t};\n\n\t\tvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n\t\t//RFC 2141\n\t\tvar handler$5 = {\n\t\t    scheme: \"urn\",\n\t\t    parse: function parse$$1(components, options) {\n\t\t        var matches = components.path && components.path.match(URN_PARSE);\n\t\t        var urnComponents = components;\n\t\t        if (matches) {\n\t\t            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t            var nid = matches[1].toLowerCase();\n\t\t            var nss = matches[2];\n\t\t            var urnScheme = scheme + \":\" + (options.nid || nid);\n\t\t            var schemeHandler = SCHEMES[urnScheme];\n\t\t            urnComponents.nid = nid;\n\t\t            urnComponents.nss = nss;\n\t\t            urnComponents.path = undefined;\n\t\t            if (schemeHandler) {\n\t\t                urnComponents = schemeHandler.parse(urnComponents, options);\n\t\t            }\n\t\t        } else {\n\t\t            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t        }\n\t\t        return urnComponents;\n\t\t    },\n\t\t    serialize: function serialize$$1(urnComponents, options) {\n\t\t        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t        var nid = urnComponents.nid;\n\t\t        var urnScheme = scheme + \":\" + (options.nid || nid);\n\t\t        var schemeHandler = SCHEMES[urnScheme];\n\t\t        if (schemeHandler) {\n\t\t            urnComponents = schemeHandler.serialize(urnComponents, options);\n\t\t        }\n\t\t        var uriComponents = urnComponents;\n\t\t        var nss = urnComponents.nss;\n\t\t        uriComponents.path = (nid || options.nid) + \":\" + nss;\n\t\t        return uriComponents;\n\t\t    }\n\t\t};\n\n\t\tvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n\t\t//RFC 4122\n\t\tvar handler$6 = {\n\t\t    scheme: \"urn:uuid\",\n\t\t    parse: function parse(urnComponents, options) {\n\t\t        var uuidComponents = urnComponents;\n\t\t        uuidComponents.uuid = uuidComponents.nss;\n\t\t        uuidComponents.nss = undefined;\n\t\t        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t        }\n\t\t        return uuidComponents;\n\t\t    },\n\t\t    serialize: function serialize(uuidComponents, options) {\n\t\t        var urnComponents = uuidComponents;\n\t\t        //normalize UUID\n\t\t        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\t        return urnComponents;\n\t\t    }\n\t\t};\n\n\t\tSCHEMES[handler.scheme] = handler;\n\t\tSCHEMES[handler$1.scheme] = handler$1;\n\t\tSCHEMES[handler$2.scheme] = handler$2;\n\t\tSCHEMES[handler$3.scheme] = handler$3;\n\t\tSCHEMES[handler$4.scheme] = handler$4;\n\t\tSCHEMES[handler$5.scheme] = handler$5;\n\t\tSCHEMES[handler$6.scheme] = handler$6;\n\n\t\texports.SCHEMES = SCHEMES;\n\t\texports.pctEncChar = pctEncChar;\n\t\texports.pctDecChars = pctDecChars;\n\t\texports.parse = parse;\n\t\texports.removeDotSegments = removeDotSegments;\n\t\texports.serialize = serialize;\n\t\texports.resolveComponents = resolveComponents;\n\t\texports.resolve = resolve;\n\t\texports.normalize = normalize;\n\t\texports.equal = equal;\n\t\texports.escapeComponent = escapeComponent;\n\t\texports.unescapeComponent = unescapeComponent;\n\n\t\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\t\t})));\n\t\t//# sourceMappingURL=uri.all.js.map\n} (uri_allModule, uri_all));\n\treturn uri_all;\n}\n\nexport { requireUri_all as __require };","start":1667202984257,"end":1667202984292,"order":"normal"}]}
