{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/tunnel-agent/index.js","transforms":[{"name":"vite:load-fallback","result":"'use strict'\n\nvar net = require('net')\n  , tls = require('tls')\n  , http = require('http')\n  , https = require('https')\n  , events = require('events')\n  , assert = require('assert')\n  , util = require('util')\n  , Buffer = require('safe-buffer').Buffer\n  ;\n\nexports.httpOverHttp = httpOverHttp\nexports.httpsOverHttp = httpsOverHttp\nexports.httpOverHttps = httpOverHttps\nexports.httpsOverHttps = httpsOverHttps\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  return agent\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  return agent\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.proxyOptions = self.options.proxy || {}\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n  self.requests = []\n  self.sockets = []\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i]\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1)\n        pending.request.onSocket(socket)\n        return\n      }\n    }\n    socket.destroy()\n    self.removeSocket(socket)\n  })\n}\nutil.inherits(TunnelingAgent, events.EventEmitter)\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\n  var self = this\n\n   // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: options.host, port: options.port, request: req})\n    return\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createConnection({host: options.host, port: options.port, request: req})\n}\n\nTunnelingAgent.prototype.createConnection = function createConnection(pending) {\n  var self = this\n\n  self.createSocket(pending, function(socket) {\n    socket.on('free', onFree)\n    socket.on('close', onCloseOrRemove)\n    socket.on('agentRemove', onCloseOrRemove)\n    pending.request.onSocket(socket)\n\n    function onFree() {\n      self.emit('free', socket, pending.host, pending.port)\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket)\n      socket.removeListener('free', onFree)\n      socket.removeListener('close', onCloseOrRemove)\n      socket.removeListener('agentRemove', onCloseOrRemove)\n    }\n  })\n}\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this\n  var placeholder = {}\n  self.sockets.push(placeholder)\n\n  var connectOptions = mergeOptions({}, self.proxyOptions,\n    { method: 'CONNECT'\n    , path: options.host + ':' + options.port\n    , agent: false\n    }\n  )\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {}\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        Buffer.from(connectOptions.proxyAuth).toString('base64')\n  }\n\n  debug('making CONNECT request')\n  var connectReq = self.request(connectOptions)\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\n  connectReq.once('response', onResponse) // for v0.6\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\n  connectReq.once('connect', onConnect)   // for v0.7 or later\n  connectReq.once('error', onError)\n  connectReq.end()\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head)\n    })\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners()\n    socket.removeAllListeners()\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0)\n      debug('tunneling connection has established')\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\n      cb(socket)\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n      error.code = 'ECONNRESET'\n      options.request.emit('error', error)\n      self.removeSocket(placeholder)\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners()\n\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n    error.code = 'ECONNRESET'\n    options.request.emit('error', error)\n    self.removeSocket(placeholder)\n  }\n}\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) return\n\n  this.sockets.splice(pos, 1)\n\n  var pending = this.requests.shift()\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createConnection(pending)\n  }\n}\n\nfunction createSecureSocket(options, cb) {\n  var self = this\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options,\n      { servername: options.host\n      , socket: socket\n      }\n    ))\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket\n    cb(secureSocket)\n  })\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i]\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides)\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j]\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k]\n        }\n      }\n    }\n  }\n  return target\n}\n\n\nvar debug\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments)\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0]\n    } else {\n      args.unshift('TUNNEL:')\n    }\n    console.error.apply(console, args)\n  }\n} else {\n  debug = function() {}\n}\nexports.debug = debug // for test\n","start":1667202982449,"end":1667202982628},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as tunnelAgent } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/tunnel-agent/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/events/events.js?commonjs-wrapped\";\nimport require$$5 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safe-buffer/index.js?commonjs-wrapped\";\n\nvar hasRequiredTunnelAgent;\n\nfunction requireTunnelAgent () {\n\tif (hasRequiredTunnelAgent) return tunnelAgent;\n\thasRequiredTunnelAgent = 1;\n\t'use strict'\n\n\tvar net = require$$0\n\t  , tls = require$$1\n\t  , http = require$$2\n\t  , https = require$$3\n\t  , events = require$$4()\n\t  , assert = require$$5\n\t  , util = require$$6()\n\t  , Buffer = require$$7().Buffer\n\t  ;\n\n\ttunnelAgent.httpOverHttp = httpOverHttp\n\ttunnelAgent.httpsOverHttp = httpsOverHttp\n\ttunnelAgent.httpOverHttps = httpOverHttps\n\ttunnelAgent.httpsOverHttps = httpsOverHttps\n\n\n\tfunction httpOverHttp(options) {\n\t  var agent = new TunnelingAgent(options)\n\t  agent.request = http.request\n\t  return agent\n\t}\n\n\tfunction httpsOverHttp(options) {\n\t  var agent = new TunnelingAgent(options)\n\t  agent.request = http.request\n\t  agent.createSocket = createSecureSocket\n\t  agent.defaultPort = 443\n\t  return agent\n\t}\n\n\tfunction httpOverHttps(options) {\n\t  var agent = new TunnelingAgent(options)\n\t  agent.request = https.request\n\t  return agent\n\t}\n\n\tfunction httpsOverHttps(options) {\n\t  var agent = new TunnelingAgent(options)\n\t  agent.request = https.request\n\t  agent.createSocket = createSecureSocket\n\t  agent.defaultPort = 443\n\t  return agent\n\t}\n\n\n\tfunction TunnelingAgent(options) {\n\t  var self = this\n\t  self.options = options || {}\n\t  self.proxyOptions = self.options.proxy || {}\n\t  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n\t  self.requests = []\n\t  self.sockets = []\n\n\t  self.on('free', function onFree(socket, host, port) {\n\t    for (var i = 0, len = self.requests.length; i < len; ++i) {\n\t      var pending = self.requests[i]\n\t      if (pending.host === host && pending.port === port) {\n\t        // Detect the request to connect same origin server,\n\t        // reuse the connection.\n\t        self.requests.splice(i, 1)\n\t        pending.request.onSocket(socket)\n\t        return\n\t      }\n\t    }\n\t    socket.destroy()\n\t    self.removeSocket(socket)\n\t  })\n\t}\n\tutil.inherits(TunnelingAgent, events.EventEmitter)\n\n\tTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\n\t  var self = this\n\n\t   // Legacy API: addRequest(req, host, port, path)\n\t  if (typeof options === 'string') {\n\t    options = {\n\t      host: options,\n\t      port: arguments[2],\n\t      path: arguments[3]\n\t    };\n\t  }\n\n\t  if (self.sockets.length >= this.maxSockets) {\n\t    // We are over limit so we'll add it to the queue.\n\t    self.requests.push({host: options.host, port: options.port, request: req})\n\t    return\n\t  }\n\n\t  // If we are under maxSockets create a new one.\n\t  self.createConnection({host: options.host, port: options.port, request: req})\n\t}\n\n\tTunnelingAgent.prototype.createConnection = function createConnection(pending) {\n\t  var self = this\n\n\t  self.createSocket(pending, function(socket) {\n\t    socket.on('free', onFree)\n\t    socket.on('close', onCloseOrRemove)\n\t    socket.on('agentRemove', onCloseOrRemove)\n\t    pending.request.onSocket(socket)\n\n\t    function onFree() {\n\t      self.emit('free', socket, pending.host, pending.port)\n\t    }\n\n\t    function onCloseOrRemove(err) {\n\t      self.removeSocket(socket)\n\t      socket.removeListener('free', onFree)\n\t      socket.removeListener('close', onCloseOrRemove)\n\t      socket.removeListener('agentRemove', onCloseOrRemove)\n\t    }\n\t  })\n\t}\n\n\tTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n\t  var self = this\n\t  var placeholder = {}\n\t  self.sockets.push(placeholder)\n\n\t  var connectOptions = mergeOptions({}, self.proxyOptions,\n\t    { method: 'CONNECT'\n\t    , path: options.host + ':' + options.port\n\t    , agent: false\n\t    }\n\t  )\n\t  if (connectOptions.proxyAuth) {\n\t    connectOptions.headers = connectOptions.headers || {}\n\t    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n\t        Buffer.from(connectOptions.proxyAuth).toString('base64')\n\t  }\n\n\t  debug('making CONNECT request')\n\t  var connectReq = self.request(connectOptions)\n\t  connectReq.useChunkedEncodingByDefault = false // for v0.6\n\t  connectReq.once('response', onResponse) // for v0.6\n\t  connectReq.once('upgrade', onUpgrade)   // for v0.6\n\t  connectReq.once('connect', onConnect)   // for v0.7 or later\n\t  connectReq.once('error', onError)\n\t  connectReq.end()\n\n\t  function onResponse(res) {\n\t    // Very hacky. This is necessary to avoid http-parser leaks.\n\t    res.upgrade = true\n\t  }\n\n\t  function onUpgrade(res, socket, head) {\n\t    // Hacky.\n\t    process.nextTick(function() {\n\t      onConnect(res, socket, head)\n\t    })\n\t  }\n\n\t  function onConnect(res, socket, head) {\n\t    connectReq.removeAllListeners()\n\t    socket.removeAllListeners()\n\n\t    if (res.statusCode === 200) {\n\t      assert.equal(head.length, 0)\n\t      debug('tunneling connection has established')\n\t      self.sockets[self.sockets.indexOf(placeholder)] = socket\n\t      cb(socket)\n\t    } else {\n\t      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n\t      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n\t      error.code = 'ECONNRESET'\n\t      options.request.emit('error', error)\n\t      self.removeSocket(placeholder)\n\t    }\n\t  }\n\n\t  function onError(cause) {\n\t    connectReq.removeAllListeners()\n\n\t    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n\t    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n\t    error.code = 'ECONNRESET'\n\t    options.request.emit('error', error)\n\t    self.removeSocket(placeholder)\n\t  }\n\t}\n\n\tTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n\t  var pos = this.sockets.indexOf(socket)\n\t  if (pos === -1) return\n\n\t  this.sockets.splice(pos, 1)\n\n\t  var pending = this.requests.shift()\n\t  if (pending) {\n\t    // If we have pending requests and a socket gets closed a new one\n\t    // needs to be created to take over in the pool for the one that closed.\n\t    this.createConnection(pending)\n\t  }\n\t}\n\n\tfunction createSecureSocket(options, cb) {\n\t  var self = this\n\t  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n\t    // 0 is dummy port for v0.6\n\t    var secureSocket = tls.connect(0, mergeOptions({}, self.options,\n\t      { servername: options.host\n\t      , socket: socket\n\t      }\n\t    ))\n\t    self.sockets[self.sockets.indexOf(socket)] = secureSocket\n\t    cb(secureSocket)\n\t  })\n\t}\n\n\n\tfunction mergeOptions(target) {\n\t  for (var i = 1, len = arguments.length; i < len; ++i) {\n\t    var overrides = arguments[i]\n\t    if (typeof overrides === 'object') {\n\t      var keys = Object.keys(overrides)\n\t      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n\t        var k = keys[j]\n\t        if (overrides[k] !== undefined) {\n\t          target[k] = overrides[k]\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return target\n\t}\n\n\n\tvar debug\n\tif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n\t  debug = function() {\n\t    var args = Array.prototype.slice.call(arguments)\n\t    if (typeof args[0] === 'string') {\n\t      args[0] = 'TUNNEL: ' + args[0]\n\t    } else {\n\t      args.unshift('TUNNEL:')\n\t    }\n\t    console.error.apply(console, args)\n\t  }\n\t} else {\n\t  debug = function() {}\n\t}\n\ttunnelAgent.debug = debug // for test\n\treturn tunnelAgent;\n}\n\nexport { requireTunnelAgent as __require };","start":1667202982629,"end":1667202984819,"order":"normal"}]}
