{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/aws4/aws4.js","transforms":[{"name":"vite:load-fallback","result":"var aws4 = exports,\n    url = require('url'),\n    querystring = require('querystring'),\n    crypto = require('crypto'),\n    lru = require('./lru'),\n    credentialsCache = lru(1000)\n\n// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html\n\nfunction hmac(key, string, encoding) {\n  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)\n}\n\nfunction hash(string, encoding) {\n  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)\n}\n\n// This function assumes the string has already been percent encoded\nfunction encodeRfc3986(urlEncodedString) {\n  return urlEncodedString.replace(/[!'()*]/g, function(c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nfunction encodeRfc3986Full(str) {\n  return encodeRfc3986(encodeURIComponent(str))\n}\n\n// A bit of a combination of:\n// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59\n// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199\n// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34\nvar HEADERS_TO_IGNORE = {\n  'authorization': true,\n  'connection': true,\n  'x-amzn-trace-id': true,\n  'user-agent': true,\n  'expect': true,\n  'presigned-expires': true,\n  'range': true,\n}\n\n// request: { path | body, [host], [method], [headers], [service], [region] }\n// credentials: { accessKeyId, secretAccessKey, [sessionToken] }\nfunction RequestSigner(request, credentials) {\n\n  if (typeof request === 'string') request = url.parse(request)\n\n  var headers = request.headers = (request.headers || {}),\n      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host)\n\n  this.request = request\n  this.credentials = credentials || this.defaultCredentials()\n\n  this.service = request.service || hostParts[0] || ''\n  this.region = request.region || hostParts[1] || 'us-east-1'\n\n  // SES uses a different domain from the service name\n  if (this.service === 'email') this.service = 'ses'\n\n  if (!request.method && request.body)\n    request.method = 'POST'\n\n  if (!headers.Host && !headers.host) {\n    headers.Host = request.hostname || request.host || this.createHost()\n\n    // If a port is specified explicitly, use it as is\n    if (request.port)\n      headers.Host += ':' + request.port\n  }\n  if (!request.hostname && !request.host)\n    request.hostname = headers.Host || headers.host\n\n  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'\n}\n\nRequestSigner.prototype.matchHost = function(host) {\n  var match = (host || '').match(/([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com(\\.cn)?$/)\n  var hostParts = (match || []).slice(1, 3)\n\n  // ES's hostParts are sometimes the other way round, if the value that is expected\n  // to be region equals ‘es’ switch them back\n  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com\n  if (hostParts[1] === 'es')\n    hostParts = hostParts.reverse()\n\n  if (hostParts[1] == 's3') {\n    hostParts[0] = 's3'\n    hostParts[1] = 'us-east-1'\n  } else {\n    for (var i = 0; i < 2; i++) {\n      if (/^s3-/.test(hostParts[i])) {\n        hostParts[1] = hostParts[i].slice(3)\n        hostParts[0] = 's3'\n        break\n      }\n    }\n  }\n\n  return hostParts\n}\n\n// http://docs.aws.amazon.com/general/latest/gr/rande.html\nRequestSigner.prototype.isSingleRegion = function() {\n  // Special case for S3 and SimpleDB in us-east-1\n  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true\n\n  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']\n    .indexOf(this.service) >= 0\n}\n\nRequestSigner.prototype.createHost = function() {\n  var region = this.isSingleRegion() ? '' : '.' + this.region,\n      subdomain = this.service === 'ses' ? 'email' : this.service\n  return subdomain + region + '.amazonaws.com'\n}\n\nRequestSigner.prototype.prepareRequest = function() {\n  this.parsePath()\n\n  var request = this.request, headers = request.headers, query\n\n  if (request.signQuery) {\n\n    this.parsedPath.query = query = this.parsedPath.query || {}\n\n    if (this.credentials.sessionToken)\n      query['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n    if (this.service === 's3' && !query['X-Amz-Expires'])\n      query['X-Amz-Expires'] = 86400\n\n    if (query['X-Amz-Date'])\n      this.datetime = query['X-Amz-Date']\n    else\n      query['X-Amz-Date'] = this.getDateTime()\n\n    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'\n    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()\n    query['X-Amz-SignedHeaders'] = this.signedHeaders()\n\n  } else {\n\n    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {\n      if (request.body && !headers['Content-Type'] && !headers['content-type'])\n        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n\n      if (request.body && !headers['Content-Length'] && !headers['content-length'])\n        headers['Content-Length'] = Buffer.byteLength(request.body)\n\n      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])\n        headers['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])\n        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')\n\n      if (headers['X-Amz-Date'] || headers['x-amz-date'])\n        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date']\n      else\n        headers['X-Amz-Date'] = this.getDateTime()\n    }\n\n    delete headers.Authorization\n    delete headers.authorization\n  }\n}\n\nRequestSigner.prototype.sign = function() {\n  if (!this.parsedPath) this.prepareRequest()\n\n  if (this.request.signQuery) {\n    this.parsedPath.query['X-Amz-Signature'] = this.signature()\n  } else {\n    this.request.headers.Authorization = this.authHeader()\n  }\n\n  this.request.path = this.formatPath()\n\n  return this.request\n}\n\nRequestSigner.prototype.getDateTime = function() {\n  if (!this.datetime) {\n    var headers = this.request.headers,\n      date = new Date(headers.Date || headers.date || new Date)\n\n    this.datetime = date.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n\n    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access\n    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)\n  }\n  return this.datetime\n}\n\nRequestSigner.prototype.getDate = function() {\n  return this.getDateTime().substr(0, 8)\n}\n\nRequestSigner.prototype.authHeader = function() {\n  return [\n    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),\n    'SignedHeaders=' + this.signedHeaders(),\n    'Signature=' + this.signature(),\n  ].join(', ')\n}\n\nRequestSigner.prototype.signature = function() {\n  var date = this.getDate(),\n      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),\n      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)\n  if (!kCredentials) {\n    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)\n    kRegion = hmac(kDate, this.region)\n    kService = hmac(kRegion, this.service)\n    kCredentials = hmac(kService, 'aws4_request')\n    credentialsCache.set(cacheKey, kCredentials)\n  }\n  return hmac(kCredentials, this.stringToSign(), 'hex')\n}\n\nRequestSigner.prototype.stringToSign = function() {\n  return [\n    'AWS4-HMAC-SHA256',\n    this.getDateTime(),\n    this.credentialString(),\n    hash(this.canonicalString(), 'hex'),\n  ].join('\\n')\n}\n\nRequestSigner.prototype.canonicalString = function() {\n  if (!this.parsedPath) this.prepareRequest()\n\n  var pathStr = this.parsedPath.path,\n      query = this.parsedPath.query,\n      headers = this.request.headers,\n      queryStr = '',\n      normalizePath = this.service !== 's3',\n      decodePath = this.service === 's3' || this.request.doNotEncodePath,\n      decodeSlashesInPath = this.service === 's3',\n      firstValOnly = this.service === 's3',\n      bodyHash\n\n  if (this.service === 's3' && this.request.signQuery) {\n    bodyHash = 'UNSIGNED-PAYLOAD'\n  } else if (this.isCodeCommitGit) {\n    bodyHash = ''\n  } else {\n    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||\n      hash(this.request.body || '', 'hex')\n  }\n\n  if (query) {\n    var reducedQuery = Object.keys(query).reduce(function(obj, key) {\n      if (!key) return obj\n      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :\n        (firstValOnly ? query[key][0] : query[key])\n      return obj\n    }, {})\n    var encodedQueryPieces = []\n    Object.keys(reducedQuery).sort().forEach(function(key) {\n      if (!Array.isArray(reducedQuery[key])) {\n        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]))\n      } else {\n        reducedQuery[key].map(encodeRfc3986Full).sort()\n          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val) })\n      }\n    })\n    queryStr = encodedQueryPieces.join('&')\n  }\n  if (pathStr !== '/') {\n    if (normalizePath) pathStr = pathStr.replace(/\\/{2,}/g, '/')\n    pathStr = pathStr.split('/').reduce(function(path, piece) {\n      if (normalizePath && piece === '..') {\n        path.pop()\n      } else if (!normalizePath || piece !== '.') {\n        if (decodePath) piece = decodeURIComponent(piece.replace(/\\+/g, ' '))\n        path.push(encodeRfc3986Full(piece))\n      }\n      return path\n    }, []).join('/')\n    if (pathStr[0] !== '/') pathStr = '/' + pathStr\n    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')\n  }\n\n  return [\n    this.request.method || 'GET',\n    pathStr,\n    queryStr,\n    this.canonicalHeaders() + '\\n',\n    this.signedHeaders(),\n    bodyHash,\n  ].join('\\n')\n}\n\nRequestSigner.prototype.canonicalHeaders = function() {\n  var headers = this.request.headers\n  function trimAll(header) {\n    return header.toString().trim().replace(/\\s+/g, ' ')\n  }\n  return Object.keys(headers)\n    .filter(function(key) { return HEADERS_TO_IGNORE[key.toLowerCase()] == null })\n    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })\n    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })\n    .join('\\n')\n}\n\nRequestSigner.prototype.signedHeaders = function() {\n  return Object.keys(this.request.headers)\n    .map(function(key) { return key.toLowerCase() })\n    .filter(function(key) { return HEADERS_TO_IGNORE[key] == null })\n    .sort()\n    .join(';')\n}\n\nRequestSigner.prototype.credentialString = function() {\n  return [\n    this.getDate(),\n    this.region,\n    this.service,\n    'aws4_request',\n  ].join('/')\n}\n\nRequestSigner.prototype.defaultCredentials = function() {\n  var env = process.env\n  return {\n    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,\n    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,\n    sessionToken: env.AWS_SESSION_TOKEN,\n  }\n}\n\nRequestSigner.prototype.parsePath = function() {\n  var path = this.request.path || '/'\n\n  // S3 doesn't always encode characters > 127 correctly and\n  // all services don't encode characters > 255 correctly\n  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all\n  if (/[^0-9A-Za-z;,/?:@&=+$\\-_.!~*'()#%]/.test(path)) {\n    path = encodeURI(decodeURI(path))\n  }\n\n  var queryIx = path.indexOf('?'),\n      query = null\n\n  if (queryIx >= 0) {\n    query = querystring.parse(path.slice(queryIx + 1))\n    path = path.slice(0, queryIx)\n  }\n\n  this.parsedPath = {\n    path: path,\n    query: query,\n  }\n}\n\nRequestSigner.prototype.formatPath = function() {\n  var path = this.parsedPath.path,\n      query = this.parsedPath.query\n\n  if (!query) return path\n\n  // Services don't support empty query string keys\n  if (query[''] != null) delete query['']\n\n  return path + '?' + encodeRfc3986(querystring.stringify(query))\n}\n\naws4.RequestSigner = RequestSigner\n\naws4.sign = function(request, credentials) {\n  return new RequestSigner(request, credentials).sign()\n}\n","start":1667202704600,"end":1667202704832},{"name":"vite:define","result":"var aws4 = exports,\n    url = require('url'),\n    querystring = require('querystring'),\n    crypto = require('crypto'),\n    lru = require('./lru'),\n    credentialsCache = lru(1000)\n\n// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html\n\nfunction hmac(key, string, encoding) {\n  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)\n}\n\nfunction hash(string, encoding) {\n  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)\n}\n\n// This function assumes the string has already been percent encoded\nfunction encodeRfc3986(urlEncodedString) {\n  return urlEncodedString.replace(/[!'()*]/g, function(c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nfunction encodeRfc3986Full(str) {\n  return encodeRfc3986(encodeURIComponent(str))\n}\n\n// A bit of a combination of:\n// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59\n// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199\n// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34\nvar HEADERS_TO_IGNORE = {\n  'authorization': true,\n  'connection': true,\n  'x-amzn-trace-id': true,\n  'user-agent': true,\n  'expect': true,\n  'presigned-expires': true,\n  'range': true,\n}\n\n// request: { path | body, [host], [method], [headers], [service], [region] }\n// credentials: { accessKeyId, secretAccessKey, [sessionToken] }\nfunction RequestSigner(request, credentials) {\n\n  if (typeof request === 'string') request = url.parse(request)\n\n  var headers = request.headers = (request.headers || {}),\n      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host)\n\n  this.request = request\n  this.credentials = credentials || this.defaultCredentials()\n\n  this.service = request.service || hostParts[0] || ''\n  this.region = request.region || hostParts[1] || 'us-east-1'\n\n  // SES uses a different domain from the service name\n  if (this.service === 'email') this.service = 'ses'\n\n  if (!request.method && request.body)\n    request.method = 'POST'\n\n  if (!headers.Host && !headers.host) {\n    headers.Host = request.hostname || request.host || this.createHost()\n\n    // If a port is specified explicitly, use it as is\n    if (request.port)\n      headers.Host += ':' + request.port\n  }\n  if (!request.hostname && !request.host)\n    request.hostname = headers.Host || headers.host\n\n  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'\n}\n\nRequestSigner.prototype.matchHost = function(host) {\n  var match = (host || '').match(/([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com(\\.cn)?$/)\n  var hostParts = (match || []).slice(1, 3)\n\n  // ES's hostParts are sometimes the other way round, if the value that is expected\n  // to be region equals ‘es’ switch them back\n  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com\n  if (hostParts[1] === 'es')\n    hostParts = hostParts.reverse()\n\n  if (hostParts[1] == 's3') {\n    hostParts[0] = 's3'\n    hostParts[1] = 'us-east-1'\n  } else {\n    for (var i = 0; i < 2; i++) {\n      if (/^s3-/.test(hostParts[i])) {\n        hostParts[1] = hostParts[i].slice(3)\n        hostParts[0] = 's3'\n        break\n      }\n    }\n  }\n\n  return hostParts\n}\n\n// http://docs.aws.amazon.com/general/latest/gr/rande.html\nRequestSigner.prototype.isSingleRegion = function() {\n  // Special case for S3 and SimpleDB in us-east-1\n  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true\n\n  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']\n    .indexOf(this.service) >= 0\n}\n\nRequestSigner.prototype.createHost = function() {\n  var region = this.isSingleRegion() ? '' : '.' + this.region,\n      subdomain = this.service === 'ses' ? 'email' : this.service\n  return subdomain + region + '.amazonaws.com'\n}\n\nRequestSigner.prototype.prepareRequest = function() {\n  this.parsePath()\n\n  var request = this.request, headers = request.headers, query\n\n  if (request.signQuery) {\n\n    this.parsedPath.query = query = this.parsedPath.query || {}\n\n    if (this.credentials.sessionToken)\n      query['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n    if (this.service === 's3' && !query['X-Amz-Expires'])\n      query['X-Amz-Expires'] = 86400\n\n    if (query['X-Amz-Date'])\n      this.datetime = query['X-Amz-Date']\n    else\n      query['X-Amz-Date'] = this.getDateTime()\n\n    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'\n    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()\n    query['X-Amz-SignedHeaders'] = this.signedHeaders()\n\n  } else {\n\n    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {\n      if (request.body && !headers['Content-Type'] && !headers['content-type'])\n        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n\n      if (request.body && !headers['Content-Length'] && !headers['content-length'])\n        headers['Content-Length'] = Buffer.byteLength(request.body)\n\n      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])\n        headers['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])\n        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')\n\n      if (headers['X-Amz-Date'] || headers['x-amz-date'])\n        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date']\n      else\n        headers['X-Amz-Date'] = this.getDateTime()\n    }\n\n    delete headers.Authorization\n    delete headers.authorization\n  }\n}\n\nRequestSigner.prototype.sign = function() {\n  if (!this.parsedPath) this.prepareRequest()\n\n  if (this.request.signQuery) {\n    this.parsedPath.query['X-Amz-Signature'] = this.signature()\n  } else {\n    this.request.headers.Authorization = this.authHeader()\n  }\n\n  this.request.path = this.formatPath()\n\n  return this.request\n}\n\nRequestSigner.prototype.getDateTime = function() {\n  if (!this.datetime) {\n    var headers = this.request.headers,\n      date = new Date(headers.Date || headers.date || new Date)\n\n    this.datetime = date.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n\n    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access\n    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)\n  }\n  return this.datetime\n}\n\nRequestSigner.prototype.getDate = function() {\n  return this.getDateTime().substr(0, 8)\n}\n\nRequestSigner.prototype.authHeader = function() {\n  return [\n    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),\n    'SignedHeaders=' + this.signedHeaders(),\n    'Signature=' + this.signature(),\n  ].join(', ')\n}\n\nRequestSigner.prototype.signature = function() {\n  var date = this.getDate(),\n      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),\n      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)\n  if (!kCredentials) {\n    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)\n    kRegion = hmac(kDate, this.region)\n    kService = hmac(kRegion, this.service)\n    kCredentials = hmac(kService, 'aws4_request')\n    credentialsCache.set(cacheKey, kCredentials)\n  }\n  return hmac(kCredentials, this.stringToSign(), 'hex')\n}\n\nRequestSigner.prototype.stringToSign = function() {\n  return [\n    'AWS4-HMAC-SHA256',\n    this.getDateTime(),\n    this.credentialString(),\n    hash(this.canonicalString(), 'hex'),\n  ].join('\\n')\n}\n\nRequestSigner.prototype.canonicalString = function() {\n  if (!this.parsedPath) this.prepareRequest()\n\n  var pathStr = this.parsedPath.path,\n      query = this.parsedPath.query,\n      headers = this.request.headers,\n      queryStr = '',\n      normalizePath = this.service !== 's3',\n      decodePath = this.service === 's3' || this.request.doNotEncodePath,\n      decodeSlashesInPath = this.service === 's3',\n      firstValOnly = this.service === 's3',\n      bodyHash\n\n  if (this.service === 's3' && this.request.signQuery) {\n    bodyHash = 'UNSIGNED-PAYLOAD'\n  } else if (this.isCodeCommitGit) {\n    bodyHash = ''\n  } else {\n    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||\n      hash(this.request.body || '', 'hex')\n  }\n\n  if (query) {\n    var reducedQuery = Object.keys(query).reduce(function(obj, key) {\n      if (!key) return obj\n      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :\n        (firstValOnly ? query[key][0] : query[key])\n      return obj\n    }, {})\n    var encodedQueryPieces = []\n    Object.keys(reducedQuery).sort().forEach(function(key) {\n      if (!Array.isArray(reducedQuery[key])) {\n        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]))\n      } else {\n        reducedQuery[key].map(encodeRfc3986Full).sort()\n          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val) })\n      }\n    })\n    queryStr = encodedQueryPieces.join('&')\n  }\n  if (pathStr !== '/') {\n    if (normalizePath) pathStr = pathStr.replace(/\\/{2,}/g, '/')\n    pathStr = pathStr.split('/').reduce(function(path, piece) {\n      if (normalizePath && piece === '..') {\n        path.pop()\n      } else if (!normalizePath || piece !== '.') {\n        if (decodePath) piece = decodeURIComponent(piece.replace(/\\+/g, ' '))\n        path.push(encodeRfc3986Full(piece))\n      }\n      return path\n    }, []).join('/')\n    if (pathStr[0] !== '/') pathStr = '/' + pathStr\n    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')\n  }\n\n  return [\n    this.request.method || 'GET',\n    pathStr,\n    queryStr,\n    this.canonicalHeaders() + '\\n',\n    this.signedHeaders(),\n    bodyHash,\n  ].join('\\n')\n}\n\nRequestSigner.prototype.canonicalHeaders = function() {\n  var headers = this.request.headers\n  function trimAll(header) {\n    return header.toString().trim().replace(/\\s+/g, ' ')\n  }\n  return Object.keys(headers)\n    .filter(function(key) { return HEADERS_TO_IGNORE[key.toLowerCase()] == null })\n    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })\n    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })\n    .join('\\n')\n}\n\nRequestSigner.prototype.signedHeaders = function() {\n  return Object.keys(this.request.headers)\n    .map(function(key) { return key.toLowerCase() })\n    .filter(function(key) { return HEADERS_TO_IGNORE[key] == null })\n    .sort()\n    .join(';')\n}\n\nRequestSigner.prototype.credentialString = function() {\n  return [\n    this.getDate(),\n    this.region,\n    this.service,\n    'aws4_request',\n  ].join('/')\n}\n\nRequestSigner.prototype.defaultCredentials = function() {\n  var env = {}\n  return {\n    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,\n    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,\n    sessionToken: env.AWS_SESSION_TOKEN,\n  }\n}\n\nRequestSigner.prototype.parsePath = function() {\n  var path = this.request.path || '/'\n\n  // S3 doesn't always encode characters > 127 correctly and\n  // all services don't encode characters > 255 correctly\n  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all\n  if (/[^0-9A-Za-z;,/?:@&=+$\\-_.!~*'()#%]/.test(path)) {\n    path = encodeURI(decodeURI(path))\n  }\n\n  var queryIx = path.indexOf('?'),\n      query = null\n\n  if (queryIx >= 0) {\n    query = querystring.parse(path.slice(queryIx + 1))\n    path = path.slice(0, queryIx)\n  }\n\n  this.parsedPath = {\n    path: path,\n    query: query,\n  }\n}\n\nRequestSigner.prototype.formatPath = function() {\n  var path = this.parsedPath.path,\n      query = this.parsedPath.query\n\n  if (!query) return path\n\n  // Services don't support empty query string keys\n  if (query[''] != null) delete query['']\n\n  return path + '?' + encodeRfc3986(querystring.stringify(query))\n}\n\naws4.RequestSigner = RequestSigner\n\naws4.sign = function(request, credentials) {\n  return new RequestSigner(request, credentials).sign()\n}\n","start":1667202704833,"end":1667202704833,"order":"normal"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as aws4_1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/aws4.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/querystring/index.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/lru.js?commonjs-wrapped\";\n\nvar hasRequiredAws4;\n\nfunction requireAws4 () {\n\tif (hasRequiredAws4) return aws4_1;\n\thasRequiredAws4 = 1;\n\t(function (exports) {\n\t\tvar aws4 = exports,\n\t\t    url = require$$0,\n\t\t    querystring = require$$1(),\n\t\t    crypto = require$$2,\n\t\t    lru = require$$3(),\n\t\t    credentialsCache = lru(1000)\n\n\t\t// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html\n\n\t\tfunction hmac(key, string, encoding) {\n\t\t  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)\n\t\t}\n\n\t\tfunction hash(string, encoding) {\n\t\t  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)\n\t\t}\n\n\t\t// This function assumes the string has already been percent encoded\n\t\tfunction encodeRfc3986(urlEncodedString) {\n\t\t  return urlEncodedString.replace(/[!'()*]/g, function(c) {\n\t\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t\t  })\n\t\t}\n\n\t\tfunction encodeRfc3986Full(str) {\n\t\t  return encodeRfc3986(encodeURIComponent(str))\n\t\t}\n\n\t\t// A bit of a combination of:\n\t\t// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59\n\t\t// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199\n\t\t// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34\n\t\tvar HEADERS_TO_IGNORE = {\n\t\t  'authorization': true,\n\t\t  'connection': true,\n\t\t  'x-amzn-trace-id': true,\n\t\t  'user-agent': true,\n\t\t  'expect': true,\n\t\t  'presigned-expires': true,\n\t\t  'range': true,\n\t\t}\n\n\t\t// request: { path | body, [host], [method], [headers], [service], [region] }\n\t\t// credentials: { accessKeyId, secretAccessKey, [sessionToken] }\n\t\tfunction RequestSigner(request, credentials) {\n\n\t\t  if (typeof request === 'string') request = url.parse(request)\n\n\t\t  var headers = request.headers = (request.headers || {}),\n\t\t      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host)\n\n\t\t  this.request = request\n\t\t  this.credentials = credentials || this.defaultCredentials()\n\n\t\t  this.service = request.service || hostParts[0] || ''\n\t\t  this.region = request.region || hostParts[1] || 'us-east-1'\n\n\t\t  // SES uses a different domain from the service name\n\t\t  if (this.service === 'email') this.service = 'ses'\n\n\t\t  if (!request.method && request.body)\n\t\t    request.method = 'POST'\n\n\t\t  if (!headers.Host && !headers.host) {\n\t\t    headers.Host = request.hostname || request.host || this.createHost()\n\n\t\t    // If a port is specified explicitly, use it as is\n\t\t    if (request.port)\n\t\t      headers.Host += ':' + request.port\n\t\t  }\n\t\t  if (!request.hostname && !request.host)\n\t\t    request.hostname = headers.Host || headers.host\n\n\t\t  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'\n\t\t}\n\n\t\tRequestSigner.prototype.matchHost = function(host) {\n\t\t  var match = (host || '').match(/([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com(\\.cn)?$/)\n\t\t  var hostParts = (match || []).slice(1, 3)\n\n\t\t  // ES's hostParts are sometimes the other way round, if the value that is expected\n\t\t  // to be region equals ‘es’ switch them back\n\t\t  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com\n\t\t  if (hostParts[1] === 'es')\n\t\t    hostParts = hostParts.reverse()\n\n\t\t  if (hostParts[1] == 's3') {\n\t\t    hostParts[0] = 's3'\n\t\t    hostParts[1] = 'us-east-1'\n\t\t  } else {\n\t\t    for (var i = 0; i < 2; i++) {\n\t\t      if (/^s3-/.test(hostParts[i])) {\n\t\t        hostParts[1] = hostParts[i].slice(3)\n\t\t        hostParts[0] = 's3'\n\t\t        break\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return hostParts\n\t\t}\n\n\t\t// http://docs.aws.amazon.com/general/latest/gr/rande.html\n\t\tRequestSigner.prototype.isSingleRegion = function() {\n\t\t  // Special case for S3 and SimpleDB in us-east-1\n\t\t  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true\n\n\t\t  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']\n\t\t    .indexOf(this.service) >= 0\n\t\t}\n\n\t\tRequestSigner.prototype.createHost = function() {\n\t\t  var region = this.isSingleRegion() ? '' : '.' + this.region,\n\t\t      subdomain = this.service === 'ses' ? 'email' : this.service\n\t\t  return subdomain + region + '.amazonaws.com'\n\t\t}\n\n\t\tRequestSigner.prototype.prepareRequest = function() {\n\t\t  this.parsePath()\n\n\t\t  var request = this.request, headers = request.headers, query\n\n\t\t  if (request.signQuery) {\n\n\t\t    this.parsedPath.query = query = this.parsedPath.query || {}\n\n\t\t    if (this.credentials.sessionToken)\n\t\t      query['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n\t\t    if (this.service === 's3' && !query['X-Amz-Expires'])\n\t\t      query['X-Amz-Expires'] = 86400\n\n\t\t    if (query['X-Amz-Date'])\n\t\t      this.datetime = query['X-Amz-Date']\n\t\t    else\n\t\t      query['X-Amz-Date'] = this.getDateTime()\n\n\t\t    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'\n\t\t    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()\n\t\t    query['X-Amz-SignedHeaders'] = this.signedHeaders()\n\n\t\t  } else {\n\n\t\t    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {\n\t\t      if (request.body && !headers['Content-Type'] && !headers['content-type'])\n\t\t        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n\n\t\t      if (request.body && !headers['Content-Length'] && !headers['content-length'])\n\t\t        headers['Content-Length'] = Buffer.byteLength(request.body)\n\n\t\t      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])\n\t\t        headers['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n\t\t      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])\n\t\t        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')\n\n\t\t      if (headers['X-Amz-Date'] || headers['x-amz-date'])\n\t\t        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date']\n\t\t      else\n\t\t        headers['X-Amz-Date'] = this.getDateTime()\n\t\t    }\n\n\t\t    delete headers.Authorization\n\t\t    delete headers.authorization\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.sign = function() {\n\t\t  if (!this.parsedPath) this.prepareRequest()\n\n\t\t  if (this.request.signQuery) {\n\t\t    this.parsedPath.query['X-Amz-Signature'] = this.signature()\n\t\t  } else {\n\t\t    this.request.headers.Authorization = this.authHeader()\n\t\t  }\n\n\t\t  this.request.path = this.formatPath()\n\n\t\t  return this.request\n\t\t}\n\n\t\tRequestSigner.prototype.getDateTime = function() {\n\t\t  if (!this.datetime) {\n\t\t    var headers = this.request.headers,\n\t\t      date = new Date(headers.Date || headers.date || new Date)\n\n\t\t    this.datetime = date.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n\n\t\t    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access\n\t\t    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)\n\t\t  }\n\t\t  return this.datetime\n\t\t}\n\n\t\tRequestSigner.prototype.getDate = function() {\n\t\t  return this.getDateTime().substr(0, 8)\n\t\t}\n\n\t\tRequestSigner.prototype.authHeader = function() {\n\t\t  return [\n\t\t    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),\n\t\t    'SignedHeaders=' + this.signedHeaders(),\n\t\t    'Signature=' + this.signature(),\n\t\t  ].join(', ')\n\t\t}\n\n\t\tRequestSigner.prototype.signature = function() {\n\t\t  var date = this.getDate(),\n\t\t      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),\n\t\t      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)\n\t\t  if (!kCredentials) {\n\t\t    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)\n\t\t    kRegion = hmac(kDate, this.region)\n\t\t    kService = hmac(kRegion, this.service)\n\t\t    kCredentials = hmac(kService, 'aws4_request')\n\t\t    credentialsCache.set(cacheKey, kCredentials)\n\t\t  }\n\t\t  return hmac(kCredentials, this.stringToSign(), 'hex')\n\t\t}\n\n\t\tRequestSigner.prototype.stringToSign = function() {\n\t\t  return [\n\t\t    'AWS4-HMAC-SHA256',\n\t\t    this.getDateTime(),\n\t\t    this.credentialString(),\n\t\t    hash(this.canonicalString(), 'hex'),\n\t\t  ].join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.canonicalString = function() {\n\t\t  if (!this.parsedPath) this.prepareRequest()\n\n\t\t  var pathStr = this.parsedPath.path,\n\t\t      query = this.parsedPath.query,\n\t\t      headers = this.request.headers,\n\t\t      queryStr = '',\n\t\t      normalizePath = this.service !== 's3',\n\t\t      decodePath = this.service === 's3' || this.request.doNotEncodePath,\n\t\t      decodeSlashesInPath = this.service === 's3',\n\t\t      firstValOnly = this.service === 's3',\n\t\t      bodyHash\n\n\t\t  if (this.service === 's3' && this.request.signQuery) {\n\t\t    bodyHash = 'UNSIGNED-PAYLOAD'\n\t\t  } else if (this.isCodeCommitGit) {\n\t\t    bodyHash = ''\n\t\t  } else {\n\t\t    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||\n\t\t      hash(this.request.body || '', 'hex')\n\t\t  }\n\n\t\t  if (query) {\n\t\t    var reducedQuery = Object.keys(query).reduce(function(obj, key) {\n\t\t      if (!key) return obj\n\t\t      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :\n\t\t        (firstValOnly ? query[key][0] : query[key])\n\t\t      return obj\n\t\t    }, {})\n\t\t    var encodedQueryPieces = []\n\t\t    Object.keys(reducedQuery).sort().forEach(function(key) {\n\t\t      if (!Array.isArray(reducedQuery[key])) {\n\t\t        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]))\n\t\t      } else {\n\t\t        reducedQuery[key].map(encodeRfc3986Full).sort()\n\t\t          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val) })\n\t\t      }\n\t\t    })\n\t\t    queryStr = encodedQueryPieces.join('&')\n\t\t  }\n\t\t  if (pathStr !== '/') {\n\t\t    if (normalizePath) pathStr = pathStr.replace(/\\/{2,}/g, '/')\n\t\t    pathStr = pathStr.split('/').reduce(function(path, piece) {\n\t\t      if (normalizePath && piece === '..') {\n\t\t        path.pop()\n\t\t      } else if (!normalizePath || piece !== '.') {\n\t\t        if (decodePath) piece = decodeURIComponent(piece.replace(/\\+/g, ' '))\n\t\t        path.push(encodeRfc3986Full(piece))\n\t\t      }\n\t\t      return path\n\t\t    }, []).join('/')\n\t\t    if (pathStr[0] !== '/') pathStr = '/' + pathStr\n\t\t    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')\n\t\t  }\n\n\t\t  return [\n\t\t    this.request.method || 'GET',\n\t\t    pathStr,\n\t\t    queryStr,\n\t\t    this.canonicalHeaders() + '\\n',\n\t\t    this.signedHeaders(),\n\t\t    bodyHash,\n\t\t  ].join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.canonicalHeaders = function() {\n\t\t  var headers = this.request.headers\n\t\t  function trimAll(header) {\n\t\t    return header.toString().trim().replace(/\\s+/g, ' ')\n\t\t  }\n\t\t  return Object.keys(headers)\n\t\t    .filter(function(key) { return HEADERS_TO_IGNORE[key.toLowerCase()] == null })\n\t\t    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })\n\t\t    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })\n\t\t    .join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.signedHeaders = function() {\n\t\t  return Object.keys(this.request.headers)\n\t\t    .map(function(key) { return key.toLowerCase() })\n\t\t    .filter(function(key) { return HEADERS_TO_IGNORE[key] == null })\n\t\t    .sort()\n\t\t    .join(';')\n\t\t}\n\n\t\tRequestSigner.prototype.credentialString = function() {\n\t\t  return [\n\t\t    this.getDate(),\n\t\t    this.region,\n\t\t    this.service,\n\t\t    'aws4_request',\n\t\t  ].join('/')\n\t\t}\n\n\t\tRequestSigner.prototype.defaultCredentials = function() {\n\t\t  var env = {}\n\t\t  return {\n\t\t    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,\n\t\t    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,\n\t\t    sessionToken: env.AWS_SESSION_TOKEN,\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.parsePath = function() {\n\t\t  var path = this.request.path || '/'\n\n\t\t  // S3 doesn't always encode characters > 127 correctly and\n\t\t  // all services don't encode characters > 255 correctly\n\t\t  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all\n\t\t  if (/[^0-9A-Za-z;,/?:@&=+$\\-_.!~*'()#%]/.test(path)) {\n\t\t    path = encodeURI(decodeURI(path))\n\t\t  }\n\n\t\t  var queryIx = path.indexOf('?'),\n\t\t      query = null\n\n\t\t  if (queryIx >= 0) {\n\t\t    query = querystring.parse(path.slice(queryIx + 1))\n\t\t    path = path.slice(0, queryIx)\n\t\t  }\n\n\t\t  this.parsedPath = {\n\t\t    path: path,\n\t\t    query: query,\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.formatPath = function() {\n\t\t  var path = this.parsedPath.path,\n\t\t      query = this.parsedPath.query\n\n\t\t  if (!query) return path\n\n\t\t  // Services don't support empty query string keys\n\t\t  if (query[''] != null) delete query['']\n\n\t\t  return path + '?' + encodeRfc3986(querystring.stringify(query))\n\t\t}\n\n\t\taws4.RequestSigner = RequestSigner\n\n\t\taws4.sign = function(request, credentials) {\n\t\t  return new RequestSigner(request, credentials).sign()\n\t\t}\n} (aws4_1));\n\treturn aws4_1;\n}\n\nexport { requireAws4 as __require };","start":1667202704833,"end":1667202705611,"order":"normal"},{"name":"node-polyfills","result":"import { Buffer as Buffer } from 'buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as aws4_1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/aws4.js?commonjs-exports\"\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/querystring/index.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/lru.js?commonjs-wrapped\";\n\nvar hasRequiredAws4;\n\nfunction requireAws4 () {\n\tif (hasRequiredAws4) return aws4_1;\n\thasRequiredAws4 = 1;\n\t(function (exports) {\n\t\tvar aws4 = exports,\n\t\t    url = require$$0,\n\t\t    querystring = require$$1(),\n\t\t    crypto = require$$2,\n\t\t    lru = require$$3(),\n\t\t    credentialsCache = lru(1000)\n\n\t\t// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html\n\n\t\tfunction hmac(key, string, encoding) {\n\t\t  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)\n\t\t}\n\n\t\tfunction hash(string, encoding) {\n\t\t  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)\n\t\t}\n\n\t\t// This function assumes the string has already been percent encoded\n\t\tfunction encodeRfc3986(urlEncodedString) {\n\t\t  return urlEncodedString.replace(/[!'()*]/g, function(c) {\n\t\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t\t  })\n\t\t}\n\n\t\tfunction encodeRfc3986Full(str) {\n\t\t  return encodeRfc3986(encodeURIComponent(str))\n\t\t}\n\n\t\t// A bit of a combination of:\n\t\t// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59\n\t\t// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199\n\t\t// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34\n\t\tvar HEADERS_TO_IGNORE = {\n\t\t  'authorization': true,\n\t\t  'connection': true,\n\t\t  'x-amzn-trace-id': true,\n\t\t  'user-agent': true,\n\t\t  'expect': true,\n\t\t  'presigned-expires': true,\n\t\t  'range': true,\n\t\t}\n\n\t\t// request: { path | body, [host], [method], [headers], [service], [region] }\n\t\t// credentials: { accessKeyId, secretAccessKey, [sessionToken] }\n\t\tfunction RequestSigner(request, credentials) {\n\n\t\t  if (typeof request === 'string') request = url.parse(request)\n\n\t\t  var headers = request.headers = (request.headers || {}),\n\t\t      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host)\n\n\t\t  this.request = request\n\t\t  this.credentials = credentials || this.defaultCredentials()\n\n\t\t  this.service = request.service || hostParts[0] || ''\n\t\t  this.region = request.region || hostParts[1] || 'us-east-1'\n\n\t\t  // SES uses a different domain from the service name\n\t\t  if (this.service === 'email') this.service = 'ses'\n\n\t\t  if (!request.method && request.body)\n\t\t    request.method = 'POST'\n\n\t\t  if (!headers.Host && !headers.host) {\n\t\t    headers.Host = request.hostname || request.host || this.createHost()\n\n\t\t    // If a port is specified explicitly, use it as is\n\t\t    if (request.port)\n\t\t      headers.Host += ':' + request.port\n\t\t  }\n\t\t  if (!request.hostname && !request.host)\n\t\t    request.hostname = headers.Host || headers.host\n\n\t\t  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'\n\t\t}\n\n\t\tRequestSigner.prototype.matchHost = function(host) {\n\t\t  var match = (host || '').match(/([^\\.]+)\\.(?:([^\\.]*)\\.)?amazonaws\\.com(\\.cn)?$/)\n\t\t  var hostParts = (match || []).slice(1, 3)\n\n\t\t  // ES's hostParts are sometimes the other way round, if the value that is expected\n\t\t  // to be region equals ‘es’ switch them back\n\t\t  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com\n\t\t  if (hostParts[1] === 'es')\n\t\t    hostParts = hostParts.reverse()\n\n\t\t  if (hostParts[1] == 's3') {\n\t\t    hostParts[0] = 's3'\n\t\t    hostParts[1] = 'us-east-1'\n\t\t  } else {\n\t\t    for (var i = 0; i < 2; i++) {\n\t\t      if (/^s3-/.test(hostParts[i])) {\n\t\t        hostParts[1] = hostParts[i].slice(3)\n\t\t        hostParts[0] = 's3'\n\t\t        break\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return hostParts\n\t\t}\n\n\t\t// http://docs.aws.amazon.com/general/latest/gr/rande.html\n\t\tRequestSigner.prototype.isSingleRegion = function() {\n\t\t  // Special case for S3 and SimpleDB in us-east-1\n\t\t  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true\n\n\t\t  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']\n\t\t    .indexOf(this.service) >= 0\n\t\t}\n\n\t\tRequestSigner.prototype.createHost = function() {\n\t\t  var region = this.isSingleRegion() ? '' : '.' + this.region,\n\t\t      subdomain = this.service === 'ses' ? 'email' : this.service\n\t\t  return subdomain + region + '.amazonaws.com'\n\t\t}\n\n\t\tRequestSigner.prototype.prepareRequest = function() {\n\t\t  this.parsePath()\n\n\t\t  var request = this.request, headers = request.headers, query\n\n\t\t  if (request.signQuery) {\n\n\t\t    this.parsedPath.query = query = this.parsedPath.query || {}\n\n\t\t    if (this.credentials.sessionToken)\n\t\t      query['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n\t\t    if (this.service === 's3' && !query['X-Amz-Expires'])\n\t\t      query['X-Amz-Expires'] = 86400\n\n\t\t    if (query['X-Amz-Date'])\n\t\t      this.datetime = query['X-Amz-Date']\n\t\t    else\n\t\t      query['X-Amz-Date'] = this.getDateTime()\n\n\t\t    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'\n\t\t    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()\n\t\t    query['X-Amz-SignedHeaders'] = this.signedHeaders()\n\n\t\t  } else {\n\n\t\t    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {\n\t\t      if (request.body && !headers['Content-Type'] && !headers['content-type'])\n\t\t        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n\n\t\t      if (request.body && !headers['Content-Length'] && !headers['content-length'])\n\t\t        headers['Content-Length'] = Buffer.byteLength(request.body)\n\n\t\t      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])\n\t\t        headers['X-Amz-Security-Token'] = this.credentials.sessionToken\n\n\t\t      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])\n\t\t        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')\n\n\t\t      if (headers['X-Amz-Date'] || headers['x-amz-date'])\n\t\t        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date']\n\t\t      else\n\t\t        headers['X-Amz-Date'] = this.getDateTime()\n\t\t    }\n\n\t\t    delete headers.Authorization\n\t\t    delete headers.authorization\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.sign = function() {\n\t\t  if (!this.parsedPath) this.prepareRequest()\n\n\t\t  if (this.request.signQuery) {\n\t\t    this.parsedPath.query['X-Amz-Signature'] = this.signature()\n\t\t  } else {\n\t\t    this.request.headers.Authorization = this.authHeader()\n\t\t  }\n\n\t\t  this.request.path = this.formatPath()\n\n\t\t  return this.request\n\t\t}\n\n\t\tRequestSigner.prototype.getDateTime = function() {\n\t\t  if (!this.datetime) {\n\t\t    var headers = this.request.headers,\n\t\t      date = new Date(headers.Date || headers.date || new Date)\n\n\t\t    this.datetime = date.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '')\n\n\t\t    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access\n\t\t    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)\n\t\t  }\n\t\t  return this.datetime\n\t\t}\n\n\t\tRequestSigner.prototype.getDate = function() {\n\t\t  return this.getDateTime().substr(0, 8)\n\t\t}\n\n\t\tRequestSigner.prototype.authHeader = function() {\n\t\t  return [\n\t\t    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),\n\t\t    'SignedHeaders=' + this.signedHeaders(),\n\t\t    'Signature=' + this.signature(),\n\t\t  ].join(', ')\n\t\t}\n\n\t\tRequestSigner.prototype.signature = function() {\n\t\t  var date = this.getDate(),\n\t\t      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),\n\t\t      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)\n\t\t  if (!kCredentials) {\n\t\t    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)\n\t\t    kRegion = hmac(kDate, this.region)\n\t\t    kService = hmac(kRegion, this.service)\n\t\t    kCredentials = hmac(kService, 'aws4_request')\n\t\t    credentialsCache.set(cacheKey, kCredentials)\n\t\t  }\n\t\t  return hmac(kCredentials, this.stringToSign(), 'hex')\n\t\t}\n\n\t\tRequestSigner.prototype.stringToSign = function() {\n\t\t  return [\n\t\t    'AWS4-HMAC-SHA256',\n\t\t    this.getDateTime(),\n\t\t    this.credentialString(),\n\t\t    hash(this.canonicalString(), 'hex'),\n\t\t  ].join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.canonicalString = function() {\n\t\t  if (!this.parsedPath) this.prepareRequest()\n\n\t\t  var pathStr = this.parsedPath.path,\n\t\t      query = this.parsedPath.query,\n\t\t      headers = this.request.headers,\n\t\t      queryStr = '',\n\t\t      normalizePath = this.service !== 's3',\n\t\t      decodePath = this.service === 's3' || this.request.doNotEncodePath,\n\t\t      decodeSlashesInPath = this.service === 's3',\n\t\t      firstValOnly = this.service === 's3',\n\t\t      bodyHash\n\n\t\t  if (this.service === 's3' && this.request.signQuery) {\n\t\t    bodyHash = 'UNSIGNED-PAYLOAD'\n\t\t  } else if (this.isCodeCommitGit) {\n\t\t    bodyHash = ''\n\t\t  } else {\n\t\t    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||\n\t\t      hash(this.request.body || '', 'hex')\n\t\t  }\n\n\t\t  if (query) {\n\t\t    var reducedQuery = Object.keys(query).reduce(function(obj, key) {\n\t\t      if (!key) return obj\n\t\t      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :\n\t\t        (firstValOnly ? query[key][0] : query[key])\n\t\t      return obj\n\t\t    }, {})\n\t\t    var encodedQueryPieces = []\n\t\t    Object.keys(reducedQuery).sort().forEach(function(key) {\n\t\t      if (!Array.isArray(reducedQuery[key])) {\n\t\t        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]))\n\t\t      } else {\n\t\t        reducedQuery[key].map(encodeRfc3986Full).sort()\n\t\t          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val) })\n\t\t      }\n\t\t    })\n\t\t    queryStr = encodedQueryPieces.join('&')\n\t\t  }\n\t\t  if (pathStr !== '/') {\n\t\t    if (normalizePath) pathStr = pathStr.replace(/\\/{2,}/g, '/')\n\t\t    pathStr = pathStr.split('/').reduce(function(path, piece) {\n\t\t      if (normalizePath && piece === '..') {\n\t\t        path.pop()\n\t\t      } else if (!normalizePath || piece !== '.') {\n\t\t        if (decodePath) piece = decodeURIComponent(piece.replace(/\\+/g, ' '))\n\t\t        path.push(encodeRfc3986Full(piece))\n\t\t      }\n\t\t      return path\n\t\t    }, []).join('/')\n\t\t    if (pathStr[0] !== '/') pathStr = '/' + pathStr\n\t\t    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')\n\t\t  }\n\n\t\t  return [\n\t\t    this.request.method || 'GET',\n\t\t    pathStr,\n\t\t    queryStr,\n\t\t    this.canonicalHeaders() + '\\n',\n\t\t    this.signedHeaders(),\n\t\t    bodyHash,\n\t\t  ].join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.canonicalHeaders = function() {\n\t\t  var headers = this.request.headers\n\t\t  function trimAll(header) {\n\t\t    return header.toString().trim().replace(/\\s+/g, ' ')\n\t\t  }\n\t\t  return Object.keys(headers)\n\t\t    .filter(function(key) { return HEADERS_TO_IGNORE[key.toLowerCase()] == null })\n\t\t    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })\n\t\t    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })\n\t\t    .join('\\n')\n\t\t}\n\n\t\tRequestSigner.prototype.signedHeaders = function() {\n\t\t  return Object.keys(this.request.headers)\n\t\t    .map(function(key) { return key.toLowerCase() })\n\t\t    .filter(function(key) { return HEADERS_TO_IGNORE[key] == null })\n\t\t    .sort()\n\t\t    .join(';')\n\t\t}\n\n\t\tRequestSigner.prototype.credentialString = function() {\n\t\t  return [\n\t\t    this.getDate(),\n\t\t    this.region,\n\t\t    this.service,\n\t\t    'aws4_request',\n\t\t  ].join('/')\n\t\t}\n\n\t\tRequestSigner.prototype.defaultCredentials = function() {\n\t\t  var env = {}\n\t\t  return {\n\t\t    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,\n\t\t    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,\n\t\t    sessionToken: env.AWS_SESSION_TOKEN,\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.parsePath = function() {\n\t\t  var path = this.request.path || '/'\n\n\t\t  // S3 doesn't always encode characters > 127 correctly and\n\t\t  // all services don't encode characters > 255 correctly\n\t\t  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all\n\t\t  if (/[^0-9A-Za-z;,/?:@&=+$\\-_.!~*'()#%]/.test(path)) {\n\t\t    path = encodeURI(decodeURI(path))\n\t\t  }\n\n\t\t  var queryIx = path.indexOf('?'),\n\t\t      query = null\n\n\t\t  if (queryIx >= 0) {\n\t\t    query = querystring.parse(path.slice(queryIx + 1))\n\t\t    path = path.slice(0, queryIx)\n\t\t  }\n\n\t\t  this.parsedPath = {\n\t\t    path: path,\n\t\t    query: query,\n\t\t  }\n\t\t}\n\n\t\tRequestSigner.prototype.formatPath = function() {\n\t\t  var path = this.parsedPath.path,\n\t\t      query = this.parsedPath.query\n\n\t\t  if (!query) return path\n\n\t\t  // Services don't support empty query string keys\n\t\t  if (query[''] != null) delete query['']\n\n\t\t  return path + '?' + encodeRfc3986(querystring.stringify(query))\n\t\t}\n\n\t\taws4.RequestSigner = RequestSigner\n\n\t\taws4.sign = function(request, credentials) {\n\t\t  return new RequestSigner(request, credentials).sign()\n\t\t}\n} (aws4_1));\n\treturn aws4_1;\n}\n\nexport { requireAws4 as __require };","start":1667202705612,"end":1667202705618,"order":"normal"}]}
