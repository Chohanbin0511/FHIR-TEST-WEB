{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/decorate.js","transforms":[{"name":"vite:load-fallback","result":"(function() {\r\n    var fhirAPI;\r\n    var adapter;\r\n\r\n    function getNext (bundle, process) {\r\n        var i;\r\n        var d = bundle.data.entry || [];\r\n        var entries = [];\r\n        for (i = 0; i < d.length; i++) {\r\n            entries.push(d[i].resource);\r\n        }\r\n        process(entries);\r\n        var def = adapter.defer();\r\n        fhirAPI.nextPage({bundle:bundle.data}).then(function (r) {\r\n            getNext(r, process).then(function (t) {\r\n                def.resolve();\r\n            });\r\n        }, function(err) {def.resolve()});\r\n        return def.promise;\r\n    }\r\n    \r\n    function drain (searchParams, process, done, fail) {\r\n        var ret = adapter.defer();\r\n        \r\n        fhirAPI.search(searchParams).then(function(data){\r\n            getNext(data, process).then(function() {\r\n                done();\r\n            }, function(err) {\r\n                fail(err);\r\n            });\r\n        }, function(err) {\r\n            fail(err);\r\n        });\r\n    };\r\n    \r\n    function fetchAll (searchParams){\r\n        var ret = adapter.defer();\r\n        var results = [];\r\n        \r\n        drain(\r\n            searchParams,\r\n            function(entries) {\r\n                entries.forEach(function(entry) {\r\n                    results.push(entry);\r\n                });\r\n            },\r\n            function () {\r\n                ret.resolve(results);\r\n            },\r\n            function (err) {\r\n                ret.reject(err);\r\n            }\r\n        );\r\n          \r\n        return ret.promise;\r\n    };\r\n\r\n    function fetchAllWithReferences (searchParams, resolveParams) {\r\n        var ret = adapter.defer();\r\n          \r\n        fhirAPI.search(searchParams)  // TODO: THIS IS NOT CORRECT (need fetchAll, but it does not return a bundle yet)\r\n            .then(function(results){\r\n\r\n                var resolvedReferences = {};\r\n\r\n                var queue = [function() {ret.resolve(results, resolvedReferences);}];\r\n                \r\n                function enqueue (bundle,resource,reference) {\r\n                  queue.push(function() {resolveReference(bundle,resource,reference)});\r\n                }\r\n\r\n                function next() {\r\n                  (queue.pop())();\r\n                }\r\n\r\n                function resolveReference (bundle,resource,reference) {\r\n                    var referenceID = reference.reference;\r\n                    fhirAPI.resolve({'bundle': bundle, 'resource': resource, 'reference':reference}).then(function(res){\r\n                      var referencedObject = res.data || res.content;\r\n                      resolvedReferences[referenceID] = referencedObject;\r\n                      next();\r\n                    });\r\n                }\r\n\r\n                var bundle = results.data;\r\n\r\n                bundle.entry && bundle.entry.forEach(function(element){\r\n                  var resource = element.resource;\r\n                  var type = resource.resourceType;\r\n                  resolveParams && resolveParams.forEach(function(resolveParam){\r\n                    var param = resolveParam.split('.');\r\n                    var targetType = param[0];\r\n                    var targetElement = param[1];\r\n                    var reference = resource[targetElement];\r\n                    if (type === targetType && reference) {\r\n                      var referenceID = reference.reference;\r\n                      if (!resolvedReferences[referenceID]) {\r\n                        enqueue(bundle,resource,reference);\r\n                      }\r\n                    }\r\n                  });\r\n                });\r\n\r\n                next();\r\n\r\n            }, function(){\r\n                ret.reject(\"Could not fetch search results\");\r\n            });\r\n          \r\n        return ret.promise;\r\n    };\r\n    \r\n    function decorate (client, newAdapter) {\r\n        fhirAPI = client;\r\n        adapter = newAdapter;\r\n        client[\"drain\"] = drain;\r\n        client[\"fetchAll\"] = fetchAll;\r\n        client[\"fetchAllWithReferences\"] = fetchAllWithReferences;\r\n        return client;\r\n    }\r\n    \r\n    module.exports = decorate;\r\n}).call(this);","start":1667202704304,"end":1667202704378},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as decorateModule, exports as decorate } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/decorate.js?commonjs-module\"\n\nvar hasRequiredDecorate;\n\nfunction requireDecorate () {\n\tif (hasRequiredDecorate) return decorate;\n\thasRequiredDecorate = 1;\n\t(function() {\r\n\t    var fhirAPI;\r\n\t    var adapter;\r\n\r\n\t    function getNext (bundle, process) {\r\n\t        var i;\r\n\t        var d = bundle.data.entry || [];\r\n\t        var entries = [];\r\n\t        for (i = 0; i < d.length; i++) {\r\n\t            entries.push(d[i].resource);\r\n\t        }\r\n\t        process(entries);\r\n\t        var def = adapter.defer();\r\n\t        fhirAPI.nextPage({bundle:bundle.data}).then(function (r) {\r\n\t            getNext(r, process).then(function (t) {\r\n\t                def.resolve();\r\n\t            });\r\n\t        }, function(err) {def.resolve()});\r\n\t        return def.promise;\r\n\t    }\r\n\t    \r\n\t    function drain (searchParams, process, done, fail) {\r\n\t        var ret = adapter.defer();\r\n\t        \r\n\t        fhirAPI.search(searchParams).then(function(data){\r\n\t            getNext(data, process).then(function() {\r\n\t                done();\r\n\t            }, function(err) {\r\n\t                fail(err);\r\n\t            });\r\n\t        }, function(err) {\r\n\t            fail(err);\r\n\t        });\r\n\t    };\r\n\t    \r\n\t    function fetchAll (searchParams){\r\n\t        var ret = adapter.defer();\r\n\t        var results = [];\r\n\t        \r\n\t        drain(\r\n\t            searchParams,\r\n\t            function(entries) {\r\n\t                entries.forEach(function(entry) {\r\n\t                    results.push(entry);\r\n\t                });\r\n\t            },\r\n\t            function () {\r\n\t                ret.resolve(results);\r\n\t            },\r\n\t            function (err) {\r\n\t                ret.reject(err);\r\n\t            }\r\n\t        );\r\n\t          \r\n\t        return ret.promise;\r\n\t    };\r\n\r\n\t    function fetchAllWithReferences (searchParams, resolveParams) {\r\n\t        var ret = adapter.defer();\r\n\t          \r\n\t        fhirAPI.search(searchParams)  // TODO: THIS IS NOT CORRECT (need fetchAll, but it does not return a bundle yet)\r\n\t            .then(function(results){\r\n\r\n\t                var resolvedReferences = {};\r\n\r\n\t                var queue = [function() {ret.resolve(results, resolvedReferences);}];\r\n\t                \r\n\t                function enqueue (bundle,resource,reference) {\r\n\t                  queue.push(function() {resolveReference(bundle,resource,reference)});\r\n\t                }\r\n\r\n\t                function next() {\r\n\t                  (queue.pop())();\r\n\t                }\r\n\r\n\t                function resolveReference (bundle,resource,reference) {\r\n\t                    var referenceID = reference.reference;\r\n\t                    fhirAPI.resolve({'bundle': bundle, 'resource': resource, 'reference':reference}).then(function(res){\r\n\t                      var referencedObject = res.data || res.content;\r\n\t                      resolvedReferences[referenceID] = referencedObject;\r\n\t                      next();\r\n\t                    });\r\n\t                }\r\n\r\n\t                var bundle = results.data;\r\n\r\n\t                bundle.entry && bundle.entry.forEach(function(element){\r\n\t                  var resource = element.resource;\r\n\t                  var type = resource.resourceType;\r\n\t                  resolveParams && resolveParams.forEach(function(resolveParam){\r\n\t                    var param = resolveParam.split('.');\r\n\t                    var targetType = param[0];\r\n\t                    var targetElement = param[1];\r\n\t                    var reference = resource[targetElement];\r\n\t                    if (type === targetType && reference) {\r\n\t                      var referenceID = reference.reference;\r\n\t                      if (!resolvedReferences[referenceID]) {\r\n\t                        enqueue(bundle,resource,reference);\r\n\t                      }\r\n\t                    }\r\n\t                  });\r\n\t                });\r\n\r\n\t                next();\r\n\r\n\t            }, function(){\r\n\t                ret.reject(\"Could not fetch search results\");\r\n\t            });\r\n\t          \r\n\t        return ret.promise;\r\n\t    };\r\n\t    \r\n\t    function decorate (client, newAdapter) {\r\n\t        fhirAPI = client;\r\n\t        adapter = newAdapter;\r\n\t        client[\"drain\"] = drain;\r\n\t        client[\"fetchAll\"] = fetchAll;\r\n\t        client[\"fetchAllWithReferences\"] = fetchAllWithReferences;\r\n\t        return client;\r\n\t    }\r\n\t    \r\n\t    decorateModule.exports = decorate;\r\n\t}).call(commonjsHelpers.commonjsGlobal);\n\treturn decorate;\n}\n\nexport { requireDecorate as __require };","start":1667202704378,"end":1667202704379,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as decorateModule, exports as decorate } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/fhir.js/src/decorate.js?commonjs-module\"\n\nvar hasRequiredDecorate;\n\nfunction requireDecorate () {\n\tif (hasRequiredDecorate) return decorate;\n\thasRequiredDecorate = 1;\n\t(function() {\r\n\t    var fhirAPI;\r\n\t    var adapter;\r\n\r\n\t    function getNext (bundle, process) {\r\n\t        var i;\r\n\t        var d = bundle.data.entry || [];\r\n\t        var entries = [];\r\n\t        for (i = 0; i < d.length; i++) {\r\n\t            entries.push(d[i].resource);\r\n\t        }\r\n\t        process(entries);\r\n\t        var def = adapter.defer();\r\n\t        fhirAPI.nextPage({bundle:bundle.data}).then(function (r) {\r\n\t            getNext(r, process).then(function (t) {\r\n\t                def.resolve();\r\n\t            });\r\n\t        }, function(err) {def.resolve()});\r\n\t        return def.promise;\r\n\t    }\r\n\t    \r\n\t    function drain (searchParams, process, done, fail) {\r\n\t        var ret = adapter.defer();\r\n\t        \r\n\t        fhirAPI.search(searchParams).then(function(data){\r\n\t            getNext(data, process).then(function() {\r\n\t                done();\r\n\t            }, function(err) {\r\n\t                fail(err);\r\n\t            });\r\n\t        }, function(err) {\r\n\t            fail(err);\r\n\t        });\r\n\t    };\r\n\t    \r\n\t    function fetchAll (searchParams){\r\n\t        var ret = adapter.defer();\r\n\t        var results = [];\r\n\t        \r\n\t        drain(\r\n\t            searchParams,\r\n\t            function(entries) {\r\n\t                entries.forEach(function(entry) {\r\n\t                    results.push(entry);\r\n\t                });\r\n\t            },\r\n\t            function () {\r\n\t                ret.resolve(results);\r\n\t            },\r\n\t            function (err) {\r\n\t                ret.reject(err);\r\n\t            }\r\n\t        );\r\n\t          \r\n\t        return ret.promise;\r\n\t    };\r\n\r\n\t    function fetchAllWithReferences (searchParams, resolveParams) {\r\n\t        var ret = adapter.defer();\r\n\t          \r\n\t        fhirAPI.search(searchParams)  // TODO: THIS IS NOT CORRECT (need fetchAll, but it does not return a bundle yet)\r\n\t            .then(function(results){\r\n\r\n\t                var resolvedReferences = {};\r\n\r\n\t                var queue = [function() {ret.resolve(results, resolvedReferences);}];\r\n\t                \r\n\t                function enqueue (bundle,resource,reference) {\r\n\t                  queue.push(function() {resolveReference(bundle,resource,reference)});\r\n\t                }\r\n\r\n\t                function next() {\r\n\t                  (queue.pop())();\r\n\t                }\r\n\r\n\t                function resolveReference (bundle,resource,reference) {\r\n\t                    var referenceID = reference.reference;\r\n\t                    fhirAPI.resolve({'bundle': bundle, 'resource': resource, 'reference':reference}).then(function(res){\r\n\t                      var referencedObject = res.data || res.content;\r\n\t                      resolvedReferences[referenceID] = referencedObject;\r\n\t                      next();\r\n\t                    });\r\n\t                }\r\n\r\n\t                var bundle = results.data;\r\n\r\n\t                bundle.entry && bundle.entry.forEach(function(element){\r\n\t                  var resource = element.resource;\r\n\t                  var type = resource.resourceType;\r\n\t                  resolveParams && resolveParams.forEach(function(resolveParam){\r\n\t                    var param = resolveParam.split('.');\r\n\t                    var targetType = param[0];\r\n\t                    var targetElement = param[1];\r\n\t                    var reference = resource[targetElement];\r\n\t                    if (type === targetType && reference) {\r\n\t                      var referenceID = reference.reference;\r\n\t                      if (!resolvedReferences[referenceID]) {\r\n\t                        enqueue(bundle,resource,reference);\r\n\t                      }\r\n\t                    }\r\n\t                  });\r\n\t                });\r\n\r\n\t                next();\r\n\r\n\t            }, function(){\r\n\t                ret.reject(\"Could not fetch search results\");\r\n\t            });\r\n\t          \r\n\t        return ret.promise;\r\n\t    };\r\n\t    \r\n\t    function decorate (client, newAdapter) {\r\n\t        fhirAPI = client;\r\n\t        adapter = newAdapter;\r\n\t        client[\"drain\"] = drain;\r\n\t        client[\"fetchAll\"] = fetchAll;\r\n\t        client[\"fetchAllWithReferences\"] = fetchAllWithReferences;\r\n\t        return client;\r\n\t    }\r\n\t    \r\n\t    decorateModule.exports = decorate;\r\n\t}).call(commonjsHelpers.commonjsGlobal);\n\treturn decorate;\n}\n\nexport { requireDecorate as __require };","start":1667202704380,"end":1667202704381,"order":"normal"}]}
