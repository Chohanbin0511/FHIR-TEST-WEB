{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright (c) 2012, Mark Cavage. All rights reserved.\n// Copyright 2015 Joyent, Inc.\n\nvar assert = require('assert');\nvar Stream = require('stream').Stream;\nvar util = require('util');\n\n\n///--- Globals\n\n/* JSSTYLED */\nvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;\n\n\n///--- Internal\n\nfunction _capitalize(str) {\n    return (str.charAt(0).toUpperCase() + str.slice(1));\n}\n\nfunction _toss(name, expected, oper, arg, actual) {\n    throw new assert.AssertionError({\n        message: util.format('%s (%s) is required', name, expected),\n        actual: (actual === undefined) ? typeof (arg) : actual(arg),\n        expected: expected,\n        operator: oper || '===',\n        stackStartFunction: _toss.caller\n    });\n}\n\nfunction _getClass(arg) {\n    return (Object.prototype.toString.call(arg).slice(8, -1));\n}\n\nfunction noop() {\n    // Why even bother with asserts?\n}\n\n\n///--- Exports\n\nvar types = {\n    bool: {\n        check: function (arg) { return typeof (arg) === 'boolean'; }\n    },\n    func: {\n        check: function (arg) { return typeof (arg) === 'function'; }\n    },\n    string: {\n        check: function (arg) { return typeof (arg) === 'string'; }\n    },\n    object: {\n        check: function (arg) {\n            return typeof (arg) === 'object' && arg !== null;\n        }\n    },\n    number: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg);\n        }\n    },\n    finite: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);\n        }\n    },\n    buffer: {\n        check: function (arg) { return Buffer.isBuffer(arg); },\n        operator: 'Buffer.isBuffer'\n    },\n    array: {\n        check: function (arg) { return Array.isArray(arg); },\n        operator: 'Array.isArray'\n    },\n    stream: {\n        check: function (arg) { return arg instanceof Stream; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    date: {\n        check: function (arg) { return arg instanceof Date; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    regexp: {\n        check: function (arg) { return arg instanceof RegExp; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    uuid: {\n        check: function (arg) {\n            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);\n        },\n        operator: 'isUUID'\n    }\n};\n\nfunction _setExports(ndebug) {\n    var keys = Object.keys(types);\n    var out;\n\n    /* re-export standard assert */\n    if (process.env.NODE_NDEBUG) {\n        out = noop;\n    } else {\n        out = function (arg, msg) {\n            if (!arg) {\n                _toss(msg, 'true', arg);\n            }\n        };\n    }\n\n    /* standard checks */\n    keys.forEach(function (k) {\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        var type = types[k];\n        out[k] = function (arg, msg) {\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* optional checks */\n    keys.forEach(function (k) {\n        var name = 'optional' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* arrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'arrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* optionalArrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'optionalArrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* re-export built-in assertions */\n    Object.keys(assert).forEach(function (k) {\n        if (k === 'AssertionError') {\n            out[k] = assert[k];\n            return;\n        }\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        out[k] = assert[k];\n    });\n\n    /* export ourselves (for unit tests _only_) */\n    out._setExports = _setExports;\n\n    return out;\n}\n\nmodule.exports = _setExports(process.env.NODE_NDEBUG);\n","start":1667202705525,"end":1667202705633},{"name":"vite:define","result":"// Copyright (c) 2012, Mark Cavage. All rights reserved.\n// Copyright 2015 Joyent, Inc.\n\nvar assert = require('assert');\nvar Stream = require('stream').Stream;\nvar util = require('util');\n\n\n///--- Globals\n\n/* JSSTYLED */\nvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;\n\n\n///--- Internal\n\nfunction _capitalize(str) {\n    return (str.charAt(0).toUpperCase() + str.slice(1));\n}\n\nfunction _toss(name, expected, oper, arg, actual) {\n    throw new assert.AssertionError({\n        message: util.format('%s (%s) is required', name, expected),\n        actual: (actual === undefined) ? typeof (arg) : actual(arg),\n        expected: expected,\n        operator: oper || '===',\n        stackStartFunction: _toss.caller\n    });\n}\n\nfunction _getClass(arg) {\n    return (Object.prototype.toString.call(arg).slice(8, -1));\n}\n\nfunction noop() {\n    // Why even bother with asserts?\n}\n\n\n///--- Exports\n\nvar types = {\n    bool: {\n        check: function (arg) { return typeof (arg) === 'boolean'; }\n    },\n    func: {\n        check: function (arg) { return typeof (arg) === 'function'; }\n    },\n    string: {\n        check: function (arg) { return typeof (arg) === 'string'; }\n    },\n    object: {\n        check: function (arg) {\n            return typeof (arg) === 'object' && arg !== null;\n        }\n    },\n    number: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg);\n        }\n    },\n    finite: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);\n        }\n    },\n    buffer: {\n        check: function (arg) { return Buffer.isBuffer(arg); },\n        operator: 'Buffer.isBuffer'\n    },\n    array: {\n        check: function (arg) { return Array.isArray(arg); },\n        operator: 'Array.isArray'\n    },\n    stream: {\n        check: function (arg) { return arg instanceof Stream; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    date: {\n        check: function (arg) { return arg instanceof Date; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    regexp: {\n        check: function (arg) { return arg instanceof RegExp; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    uuid: {\n        check: function (arg) {\n            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);\n        },\n        operator: 'isUUID'\n    }\n};\n\nfunction _setExports(ndebug) {\n    var keys = Object.keys(types);\n    var out;\n\n    /* re-export standard assert */\n    if ({}.NODE_NDEBUG) {\n        out = noop;\n    } else {\n        out = function (arg, msg) {\n            if (!arg) {\n                _toss(msg, 'true', arg);\n            }\n        };\n    }\n\n    /* standard checks */\n    keys.forEach(function (k) {\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        var type = types[k];\n        out[k] = function (arg, msg) {\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* optional checks */\n    keys.forEach(function (k) {\n        var name = 'optional' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* arrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'arrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* optionalArrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'optionalArrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* re-export built-in assertions */\n    Object.keys(assert).forEach(function (k) {\n        if (k === 'AssertionError') {\n            out[k] = assert[k];\n            return;\n        }\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        out[k] = assert[k];\n    });\n\n    /* export ourselves (for unit tests _only_) */\n    out._setExports = _setExports;\n\n    return out;\n}\n\nmodule.exports = _setExports({}.NODE_NDEBUG);\n","start":1667202705633,"end":1667202705633,"order":"normal"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$1 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/rollup-plugin-node-polyfills/polyfills/stream.js?commonjs-proxy\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\n\nvar assert_1;\nvar hasRequiredAssert;\n\nfunction requireAssert () {\n\tif (hasRequiredAssert) return assert_1;\n\thasRequiredAssert = 1;\n\t// Copyright (c) 2012, Mark Cavage. All rights reserved.\n\t// Copyright 2015 Joyent, Inc.\n\n\tvar assert = require$$0;\n\tvar Stream = require$$1.Stream;\n\tvar util = require$$2();\n\n\n\t///--- Globals\n\n\t/* JSSTYLED */\n\tvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;\n\n\n\t///--- Internal\n\n\tfunction _capitalize(str) {\n\t    return (str.charAt(0).toUpperCase() + str.slice(1));\n\t}\n\n\tfunction _toss(name, expected, oper, arg, actual) {\n\t    throw new assert.AssertionError({\n\t        message: util.format('%s (%s) is required', name, expected),\n\t        actual: (actual === undefined) ? typeof (arg) : actual(arg),\n\t        expected: expected,\n\t        operator: oper || '===',\n\t        stackStartFunction: _toss.caller\n\t    });\n\t}\n\n\tfunction _getClass(arg) {\n\t    return (Object.prototype.toString.call(arg).slice(8, -1));\n\t}\n\n\tfunction noop() {\n\t    // Why even bother with asserts?\n\t}\n\n\n\t///--- Exports\n\n\tvar types = {\n\t    bool: {\n\t        check: function (arg) { return typeof (arg) === 'boolean'; }\n\t    },\n\t    func: {\n\t        check: function (arg) { return typeof (arg) === 'function'; }\n\t    },\n\t    string: {\n\t        check: function (arg) { return typeof (arg) === 'string'; }\n\t    },\n\t    object: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'object' && arg !== null;\n\t        }\n\t    },\n\t    number: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'number' && !isNaN(arg);\n\t        }\n\t    },\n\t    finite: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);\n\t        }\n\t    },\n\t    buffer: {\n\t        check: function (arg) { return Buffer.isBuffer(arg); },\n\t        operator: 'Buffer.isBuffer'\n\t    },\n\t    array: {\n\t        check: function (arg) { return Array.isArray(arg); },\n\t        operator: 'Array.isArray'\n\t    },\n\t    stream: {\n\t        check: function (arg) { return arg instanceof Stream; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    date: {\n\t        check: function (arg) { return arg instanceof Date; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    regexp: {\n\t        check: function (arg) { return arg instanceof RegExp; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    uuid: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);\n\t        },\n\t        operator: 'isUUID'\n\t    }\n\t};\n\n\tfunction _setExports(ndebug) {\n\t    var keys = Object.keys(types);\n\t    var out;\n\n\t    /* re-export standard assert */\n\t    if ({}.NODE_NDEBUG) {\n\t        out = noop;\n\t    } else {\n\t        out = function (arg, msg) {\n\t            if (!arg) {\n\t                _toss(msg, 'true', arg);\n\t            }\n\t        };\n\t    }\n\n\t    /* standard checks */\n\t    keys.forEach(function (k) {\n\t        if (ndebug) {\n\t            out[k] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        out[k] = function (arg, msg) {\n\t            if (!type.check(arg)) {\n\t                _toss(msg, k, type.operator, arg, type.actual);\n\t            }\n\t        };\n\t    });\n\n\t    /* optional checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'optional' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        out[name] = function (arg, msg) {\n\t            if (arg === undefined || arg === null) {\n\t                return;\n\t            }\n\t            if (!type.check(arg)) {\n\t                _toss(msg, k, type.operator, arg, type.actual);\n\t            }\n\t        };\n\t    });\n\n\t    /* arrayOf checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'arrayOf' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        var expected = '[' + k + ']';\n\t        out[name] = function (arg, msg) {\n\t            if (!Array.isArray(arg)) {\n\t                _toss(msg, expected, type.operator, arg, type.actual);\n\t            }\n\t            var i;\n\t            for (i = 0; i < arg.length; i++) {\n\t                if (!type.check(arg[i])) {\n\t                    _toss(msg, expected, type.operator, arg, type.actual);\n\t                }\n\t            }\n\t        };\n\t    });\n\n\t    /* optionalArrayOf checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'optionalArrayOf' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        var expected = '[' + k + ']';\n\t        out[name] = function (arg, msg) {\n\t            if (arg === undefined || arg === null) {\n\t                return;\n\t            }\n\t            if (!Array.isArray(arg)) {\n\t                _toss(msg, expected, type.operator, arg, type.actual);\n\t            }\n\t            var i;\n\t            for (i = 0; i < arg.length; i++) {\n\t                if (!type.check(arg[i])) {\n\t                    _toss(msg, expected, type.operator, arg, type.actual);\n\t                }\n\t            }\n\t        };\n\t    });\n\n\t    /* re-export built-in assertions */\n\t    Object.keys(assert).forEach(function (k) {\n\t        if (k === 'AssertionError') {\n\t            out[k] = assert[k];\n\t            return;\n\t        }\n\t        if (ndebug) {\n\t            out[k] = noop;\n\t            return;\n\t        }\n\t        out[k] = assert[k];\n\t    });\n\n\t    /* export ourselves (for unit tests _only_) */\n\t    out._setExports = _setExports;\n\n\t    return out;\n\t}\n\n\tassert_1 = _setExports({}.NODE_NDEBUG);\n\treturn assert_1;\n}\n\nexport { requireAssert as __require };","start":1667202705633,"end":1667202707515,"order":"normal"},{"name":"node-polyfills","result":"import { Buffer as Buffer } from 'buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$1 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/rollup-plugin-node-polyfills/polyfills/stream.js?commonjs-proxy\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\n\nvar assert_1;\nvar hasRequiredAssert;\n\nfunction requireAssert () {\n\tif (hasRequiredAssert) return assert_1;\n\thasRequiredAssert = 1;\n\t// Copyright (c) 2012, Mark Cavage. All rights reserved.\n\t// Copyright 2015 Joyent, Inc.\n\n\tvar assert = require$$0;\n\tvar Stream = require$$1.Stream;\n\tvar util = require$$2();\n\n\n\t///--- Globals\n\n\t/* JSSTYLED */\n\tvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;\n\n\n\t///--- Internal\n\n\tfunction _capitalize(str) {\n\t    return (str.charAt(0).toUpperCase() + str.slice(1));\n\t}\n\n\tfunction _toss(name, expected, oper, arg, actual) {\n\t    throw new assert.AssertionError({\n\t        message: util.format('%s (%s) is required', name, expected),\n\t        actual: (actual === undefined) ? typeof (arg) : actual(arg),\n\t        expected: expected,\n\t        operator: oper || '===',\n\t        stackStartFunction: _toss.caller\n\t    });\n\t}\n\n\tfunction _getClass(arg) {\n\t    return (Object.prototype.toString.call(arg).slice(8, -1));\n\t}\n\n\tfunction noop() {\n\t    // Why even bother with asserts?\n\t}\n\n\n\t///--- Exports\n\n\tvar types = {\n\t    bool: {\n\t        check: function (arg) { return typeof (arg) === 'boolean'; }\n\t    },\n\t    func: {\n\t        check: function (arg) { return typeof (arg) === 'function'; }\n\t    },\n\t    string: {\n\t        check: function (arg) { return typeof (arg) === 'string'; }\n\t    },\n\t    object: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'object' && arg !== null;\n\t        }\n\t    },\n\t    number: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'number' && !isNaN(arg);\n\t        }\n\t    },\n\t    finite: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);\n\t        }\n\t    },\n\t    buffer: {\n\t        check: function (arg) { return Buffer.isBuffer(arg); },\n\t        operator: 'Buffer.isBuffer'\n\t    },\n\t    array: {\n\t        check: function (arg) { return Array.isArray(arg); },\n\t        operator: 'Array.isArray'\n\t    },\n\t    stream: {\n\t        check: function (arg) { return arg instanceof Stream; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    date: {\n\t        check: function (arg) { return arg instanceof Date; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    regexp: {\n\t        check: function (arg) { return arg instanceof RegExp; },\n\t        operator: 'instanceof',\n\t        actual: _getClass\n\t    },\n\t    uuid: {\n\t        check: function (arg) {\n\t            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);\n\t        },\n\t        operator: 'isUUID'\n\t    }\n\t};\n\n\tfunction _setExports(ndebug) {\n\t    var keys = Object.keys(types);\n\t    var out;\n\n\t    /* re-export standard assert */\n\t    if ({}.NODE_NDEBUG) {\n\t        out = noop;\n\t    } else {\n\t        out = function (arg, msg) {\n\t            if (!arg) {\n\t                _toss(msg, 'true', arg);\n\t            }\n\t        };\n\t    }\n\n\t    /* standard checks */\n\t    keys.forEach(function (k) {\n\t        if (ndebug) {\n\t            out[k] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        out[k] = function (arg, msg) {\n\t            if (!type.check(arg)) {\n\t                _toss(msg, k, type.operator, arg, type.actual);\n\t            }\n\t        };\n\t    });\n\n\t    /* optional checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'optional' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        out[name] = function (arg, msg) {\n\t            if (arg === undefined || arg === null) {\n\t                return;\n\t            }\n\t            if (!type.check(arg)) {\n\t                _toss(msg, k, type.operator, arg, type.actual);\n\t            }\n\t        };\n\t    });\n\n\t    /* arrayOf checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'arrayOf' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        var expected = '[' + k + ']';\n\t        out[name] = function (arg, msg) {\n\t            if (!Array.isArray(arg)) {\n\t                _toss(msg, expected, type.operator, arg, type.actual);\n\t            }\n\t            var i;\n\t            for (i = 0; i < arg.length; i++) {\n\t                if (!type.check(arg[i])) {\n\t                    _toss(msg, expected, type.operator, arg, type.actual);\n\t                }\n\t            }\n\t        };\n\t    });\n\n\t    /* optionalArrayOf checks */\n\t    keys.forEach(function (k) {\n\t        var name = 'optionalArrayOf' + _capitalize(k);\n\t        if (ndebug) {\n\t            out[name] = noop;\n\t            return;\n\t        }\n\t        var type = types[k];\n\t        var expected = '[' + k + ']';\n\t        out[name] = function (arg, msg) {\n\t            if (arg === undefined || arg === null) {\n\t                return;\n\t            }\n\t            if (!Array.isArray(arg)) {\n\t                _toss(msg, expected, type.operator, arg, type.actual);\n\t            }\n\t            var i;\n\t            for (i = 0; i < arg.length; i++) {\n\t                if (!type.check(arg[i])) {\n\t                    _toss(msg, expected, type.operator, arg, type.actual);\n\t                }\n\t            }\n\t        };\n\t    });\n\n\t    /* re-export built-in assertions */\n\t    Object.keys(assert).forEach(function (k) {\n\t        if (k === 'AssertionError') {\n\t            out[k] = assert[k];\n\t            return;\n\t        }\n\t        if (ndebug) {\n\t            out[k] = noop;\n\t            return;\n\t        }\n\t        out[k] = assert[k];\n\t    });\n\n\t    /* export ourselves (for unit tests _only_) */\n\t    out._setExports = _setExports;\n\n\t    return out;\n\t}\n\n\tassert_1 = _setExports({}.NODE_NDEBUG);\n\treturn assert_1;\n}\n\nexport { requireAssert as __require };","start":1667202707519,"end":1667202707523,"order":"normal"}]}
