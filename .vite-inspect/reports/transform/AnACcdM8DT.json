{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/fingerprint.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2018 Joyent, Inc.\n\nmodule.exports = Fingerprint;\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('./algs');\nvar crypto = require('crypto');\nvar errs = require('./errors');\nvar Key = require('./key');\nvar PrivateKey = require('./private-key');\nvar Certificate = require('./certificate');\nvar utils = require('./utils');\n\nvar FingerprintFormatError = errs.FingerprintFormatError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Fingerprint(opts) {\n\tassert.object(opts, 'options');\n\tassert.string(opts.type, 'options.type');\n\tassert.buffer(opts.hash, 'options.hash');\n\tassert.string(opts.algorithm, 'options.algorithm');\n\n\tthis.algorithm = opts.algorithm.toLowerCase();\n\tif (algs.hashAlgs[this.algorithm] !== true)\n\t\tthrow (new InvalidAlgorithmError(this.algorithm));\n\n\tthis.hash = opts.hash;\n\tthis.type = opts.type;\n\tthis.hashType = opts.hashType;\n}\n\nFingerprint.prototype.toString = function (format) {\n\tif (format === undefined) {\n\t\tif (this.algorithm === 'md5' || this.hashType === 'spki')\n\t\t\tformat = 'hex';\n\t\telse\n\t\t\tformat = 'base64';\n\t}\n\tassert.string(format);\n\n\tswitch (format) {\n\tcase 'hex':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('hex'));\n\t\treturn (addColons(this.hash.toString('hex')));\n\tcase 'base64':\n\t\tif (this.hashType === 'spki')\n\t\t\treturn (this.hash.toString('base64'));\n\t\treturn (sshBase64Format(this.algorithm,\n\t\t    this.hash.toString('base64')));\n\tdefault:\n\t\tthrow (new FingerprintFormatError(undefined, format));\n\t}\n};\n\nFingerprint.prototype.matches = function (other) {\n\tassert.object(other, 'key or certificate');\n\tif (this.type === 'key' && this.hashType !== 'ssh') {\n\t\tutils.assertCompatible(other, Key, [1, 7], 'key with spki');\n\t\tif (PrivateKey.isPrivateKey(other)) {\n\t\t\tutils.assertCompatible(other, PrivateKey, [1, 6],\n\t\t\t    'privatekey with spki support');\n\t\t}\n\t} else if (this.type === 'key') {\n\t\tutils.assertCompatible(other, Key, [1, 0], 'key');\n\t} else {\n\t\tutils.assertCompatible(other, Certificate, [1, 0],\n\t\t    'certificate');\n\t}\n\n\tvar theirHash = other.hash(this.algorithm, this.hashType);\n\tvar theirHash2 = crypto.createHash(this.algorithm).\n\t    update(theirHash).digest('base64');\n\n\tif (this.hash2 === undefined)\n\t\tthis.hash2 = crypto.createHash(this.algorithm).\n\t\t    update(this.hash).digest('base64');\n\n\treturn (this.hash2 === theirHash2);\n};\n\n/*JSSTYLED*/\nvar base64RE = /^[A-Za-z0-9+\\/=]+$/;\n/*JSSTYLED*/\nvar hexRE = /^[a-fA-F0-9]+$/;\n\nFingerprint.parse = function (fp, options) {\n\tassert.string(fp, 'fingerprint');\n\n\tvar alg, hash, enAlgs;\n\tif (Array.isArray(options)) {\n\t\tenAlgs = options;\n\t\toptions = {};\n\t}\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tif (options.enAlgs !== undefined)\n\t\tenAlgs = options.enAlgs;\n\tif (options.algorithms !== undefined)\n\t\tenAlgs = options.algorithms;\n\tassert.optionalArrayOfString(enAlgs, 'algorithms');\n\n\tvar hashType = 'ssh';\n\tif (options.hashType !== undefined)\n\t\thashType = options.hashType;\n\tassert.string(hashType, 'options.hashType');\n\n\tvar parts = fp.split(':');\n\tif (parts.length == 2) {\n\t\talg = parts[0].toLowerCase();\n\t\tif (!base64RE.test(parts[1]))\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts[1], 'base64');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else if (parts.length > 2) {\n\t\talg = 'md5';\n\t\tif (parts[0].toLowerCase() === 'md5')\n\t\t\tparts = parts.slice(1);\n\t\tparts = parts.map(function (p) {\n\t\t\twhile (p.length < 2)\n\t\t\t\tp = '0' + p;\n\t\t\tif (p.length > 2)\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\treturn (p);\n\t\t});\n\t\tparts = parts.join('');\n\t\tif (!hexRE.test(parts) || parts.length % 2 !== 0)\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\ttry {\n\t\t\thash = Buffer.from(parts, 'hex');\n\t\t} catch (e) {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\t} else {\n\t\tif (hexRE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'hex');\n\t\t} else if (base64RE.test(fp)) {\n\t\t\thash = Buffer.from(fp, 'base64');\n\t\t} else {\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\tswitch (hash.length) {\n\t\tcase 32:\n\t\t\talg = 'sha256';\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\talg = 'md5';\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\talg = 'sha1';\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\talg = 'sha512';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t}\n\n\t\t/* Plain hex/base64: guess it's probably SPKI unless told. */\n\t\tif (options.hashType === undefined)\n\t\t\thashType = 'spki';\n\t}\n\n\tif (alg === undefined)\n\t\tthrow (new FingerprintFormatError(fp));\n\n\tif (algs.hashAlgs[alg] === undefined)\n\t\tthrow (new InvalidAlgorithmError(alg));\n\n\tif (enAlgs !== undefined) {\n\t\tenAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });\n\t\tif (enAlgs.indexOf(alg) === -1)\n\t\t\tthrow (new InvalidAlgorithmError(alg));\n\t}\n\n\treturn (new Fingerprint({\n\t\talgorithm: alg,\n\t\thash: hash,\n\t\ttype: options.type || 'key',\n\t\thashType: hashType\n\t}));\n};\n\nfunction addColons(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/(.{2})(?=.)/g, '$1:'));\n}\n\nfunction base64Strip(s) {\n\t/*JSSTYLED*/\n\treturn (s.replace(/=*$/, ''));\n}\n\nfunction sshBase64Format(alg, h) {\n\treturn (alg.toUpperCase() + ':' + base64Strip(h));\n}\n\nFingerprint.isFingerprint = function (obj, ver) {\n\treturn (utils.isCompatible(obj, Fingerprint, ver));\n};\n\n/*\n * API versions for Fingerprint:\n * [1,0] -- initial ver\n * [1,1] -- first tagged ver\n * [1,2] -- hashType and spki support\n */\nFingerprint.prototype._sshpkApiVersion = [1, 2];\n\nFingerprint._oldVersionDetect = function (obj) {\n\tassert.func(obj.toString);\n\tassert.func(obj.matches);\n\treturn ([1, 0]);\n};\n","start":1667202983384,"end":1667202983540},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/certificate.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\n\nvar fingerprint;\nvar hasRequiredFingerprint;\n\nfunction requireFingerprint () {\n\tif (hasRequiredFingerprint) return fingerprint;\n\thasRequiredFingerprint = 1;\n\t// Copyright 2018 Joyent, Inc.\n\n\tfingerprint = Fingerprint;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar algs = require$$2();\n\tvar crypto = require$$3;\n\tvar errs = require$$4();\n\tvar Key = require$$5();\n\tvar PrivateKey = require$$6();\n\tvar Certificate = require$$7();\n\tvar utils = require$$8();\n\n\tvar FingerprintFormatError = errs.FingerprintFormatError;\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\n\tfunction Fingerprint(opts) {\n\t\tassert.object(opts, 'options');\n\t\tassert.string(opts.type, 'options.type');\n\t\tassert.buffer(opts.hash, 'options.hash');\n\t\tassert.string(opts.algorithm, 'options.algorithm');\n\n\t\tthis.algorithm = opts.algorithm.toLowerCase();\n\t\tif (algs.hashAlgs[this.algorithm] !== true)\n\t\t\tthrow (new InvalidAlgorithmError(this.algorithm));\n\n\t\tthis.hash = opts.hash;\n\t\tthis.type = opts.type;\n\t\tthis.hashType = opts.hashType;\n\t}\n\n\tFingerprint.prototype.toString = function (format) {\n\t\tif (format === undefined) {\n\t\t\tif (this.algorithm === 'md5' || this.hashType === 'spki')\n\t\t\t\tformat = 'hex';\n\t\t\telse\n\t\t\t\tformat = 'base64';\n\t\t}\n\t\tassert.string(format);\n\n\t\tswitch (format) {\n\t\tcase 'hex':\n\t\t\tif (this.hashType === 'spki')\n\t\t\t\treturn (this.hash.toString('hex'));\n\t\t\treturn (addColons(this.hash.toString('hex')));\n\t\tcase 'base64':\n\t\t\tif (this.hashType === 'spki')\n\t\t\t\treturn (this.hash.toString('base64'));\n\t\t\treturn (sshBase64Format(this.algorithm,\n\t\t\t    this.hash.toString('base64')));\n\t\tdefault:\n\t\t\tthrow (new FingerprintFormatError(undefined, format));\n\t\t}\n\t};\n\n\tFingerprint.prototype.matches = function (other) {\n\t\tassert.object(other, 'key or certificate');\n\t\tif (this.type === 'key' && this.hashType !== 'ssh') {\n\t\t\tutils.assertCompatible(other, Key, [1, 7], 'key with spki');\n\t\t\tif (PrivateKey.isPrivateKey(other)) {\n\t\t\t\tutils.assertCompatible(other, PrivateKey, [1, 6],\n\t\t\t\t    'privatekey with spki support');\n\t\t\t}\n\t\t} else if (this.type === 'key') {\n\t\t\tutils.assertCompatible(other, Key, [1, 0], 'key');\n\t\t} else {\n\t\t\tutils.assertCompatible(other, Certificate, [1, 0],\n\t\t\t    'certificate');\n\t\t}\n\n\t\tvar theirHash = other.hash(this.algorithm, this.hashType);\n\t\tvar theirHash2 = crypto.createHash(this.algorithm).\n\t\t    update(theirHash).digest('base64');\n\n\t\tif (this.hash2 === undefined)\n\t\t\tthis.hash2 = crypto.createHash(this.algorithm).\n\t\t\t    update(this.hash).digest('base64');\n\n\t\treturn (this.hash2 === theirHash2);\n\t};\n\n\t/*JSSTYLED*/\n\tvar base64RE = /^[A-Za-z0-9+\\/=]+$/;\n\t/*JSSTYLED*/\n\tvar hexRE = /^[a-fA-F0-9]+$/;\n\n\tFingerprint.parse = function (fp, options) {\n\t\tassert.string(fp, 'fingerprint');\n\n\t\tvar alg, hash, enAlgs;\n\t\tif (Array.isArray(options)) {\n\t\t\tenAlgs = options;\n\t\t\toptions = {};\n\t\t}\n\t\tassert.optionalObject(options, 'options');\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tif (options.enAlgs !== undefined)\n\t\t\tenAlgs = options.enAlgs;\n\t\tif (options.algorithms !== undefined)\n\t\t\tenAlgs = options.algorithms;\n\t\tassert.optionalArrayOfString(enAlgs, 'algorithms');\n\n\t\tvar hashType = 'ssh';\n\t\tif (options.hashType !== undefined)\n\t\t\thashType = options.hashType;\n\t\tassert.string(hashType, 'options.hashType');\n\n\t\tvar parts = fp.split(':');\n\t\tif (parts.length == 2) {\n\t\t\talg = parts[0].toLowerCase();\n\t\t\tif (!base64RE.test(parts[1]))\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\ttry {\n\t\t\t\thash = Buffer.from(parts[1], 'base64');\n\t\t\t} catch (e) {\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\t}\n\t\t} else if (parts.length > 2) {\n\t\t\talg = 'md5';\n\t\t\tif (parts[0].toLowerCase() === 'md5')\n\t\t\t\tparts = parts.slice(1);\n\t\t\tparts = parts.map(function (p) {\n\t\t\t\twhile (p.length < 2)\n\t\t\t\t\tp = '0' + p;\n\t\t\t\tif (p.length > 2)\n\t\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\t\treturn (p);\n\t\t\t});\n\t\t\tparts = parts.join('');\n\t\t\tif (!hexRE.test(parts) || parts.length % 2 !== 0)\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\ttry {\n\t\t\t\thash = Buffer.from(parts, 'hex');\n\t\t\t} catch (e) {\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\t}\n\t\t} else {\n\t\t\tif (hexRE.test(fp)) {\n\t\t\t\thash = Buffer.from(fp, 'hex');\n\t\t\t} else if (base64RE.test(fp)) {\n\t\t\t\thash = Buffer.from(fp, 'base64');\n\t\t\t} else {\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\t}\n\n\t\t\tswitch (hash.length) {\n\t\t\tcase 32:\n\t\t\t\talg = 'sha256';\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\talg = 'md5';\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\talg = 'sha1';\n\t\t\t\tbreak;\n\t\t\tcase 64:\n\t\t\t\talg = 'sha512';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow (new FingerprintFormatError(fp));\n\t\t\t}\n\n\t\t\t/* Plain hex/base64: guess it's probably SPKI unless told. */\n\t\t\tif (options.hashType === undefined)\n\t\t\t\thashType = 'spki';\n\t\t}\n\n\t\tif (alg === undefined)\n\t\t\tthrow (new FingerprintFormatError(fp));\n\n\t\tif (algs.hashAlgs[alg] === undefined)\n\t\t\tthrow (new InvalidAlgorithmError(alg));\n\n\t\tif (enAlgs !== undefined) {\n\t\t\tenAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });\n\t\t\tif (enAlgs.indexOf(alg) === -1)\n\t\t\t\tthrow (new InvalidAlgorithmError(alg));\n\t\t}\n\n\t\treturn (new Fingerprint({\n\t\t\talgorithm: alg,\n\t\t\thash: hash,\n\t\t\ttype: options.type || 'key',\n\t\t\thashType: hashType\n\t\t}));\n\t};\n\n\tfunction addColons(s) {\n\t\t/*JSSTYLED*/\n\t\treturn (s.replace(/(.{2})(?=.)/g, '$1:'));\n\t}\n\n\tfunction base64Strip(s) {\n\t\t/*JSSTYLED*/\n\t\treturn (s.replace(/=*$/, ''));\n\t}\n\n\tfunction sshBase64Format(alg, h) {\n\t\treturn (alg.toUpperCase() + ':' + base64Strip(h));\n\t}\n\n\tFingerprint.isFingerprint = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, Fingerprint, ver));\n\t};\n\n\t/*\n\t * API versions for Fingerprint:\n\t * [1,0] -- initial ver\n\t * [1,1] -- first tagged ver\n\t * [1,2] -- hashType and spki support\n\t */\n\tFingerprint.prototype._sshpkApiVersion = [1, 2];\n\n\tFingerprint._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toString);\n\t\tassert.func(obj.matches);\n\t\treturn ([1, 0]);\n\t};\n\treturn fingerprint;\n}\n\nexport { requireFingerprint as __require };","start":1667202983540,"end":1667202985124,"order":"normal"}]}
