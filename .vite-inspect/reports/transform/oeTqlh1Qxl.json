{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2017 Joyent, Inc.\n\nmodule.exports = PrivateKey;\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('./algs');\nvar crypto = require('crypto');\nvar Fingerprint = require('./fingerprint');\nvar Signature = require('./signature');\nvar errs = require('./errors');\nvar util = require('util');\nvar utils = require('./utils');\nvar dhe = require('./dhe');\nvar generateECDSA = dhe.generateECDSA;\nvar generateED25519 = dhe.generateED25519;\nvar edCompat = require('./ed-compat');\nvar nacl = require('tweetnacl');\n\nvar Key = require('./key');\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar KeyEncryptedError = errs.KeyEncryptedError;\n\nvar formats = {};\nformats['auto'] = require('./formats/auto');\nformats['pem'] = require('./formats/pem');\nformats['pkcs1'] = require('./formats/pkcs1');\nformats['pkcs8'] = require('./formats/pkcs8');\nformats['rfc4253'] = require('./formats/rfc4253');\nformats['ssh-private'] = require('./formats/ssh-private');\nformats['openssh'] = formats['ssh-private'];\nformats['ssh'] = formats['ssh-private'];\nformats['dnssec'] = require('./formats/dnssec');\nformats['putty'] = require('./formats/putty');\n\nfunction PrivateKey(opts) {\n\tassert.object(opts, 'options');\n\tKey.call(this, opts);\n\n\tthis._pubCache = undefined;\n}\nutil.inherits(PrivateKey, Key);\n\nPrivateKey.formats = formats;\n\nPrivateKey.prototype.toBuffer = function (format, options) {\n\tif (format === undefined)\n\t\tformat = 'pkcs1';\n\tassert.string(format, 'format');\n\tassert.object(formats[format], 'formats[format]');\n\tassert.optionalObject(options, 'options');\n\n\treturn (formats[format].write(this, options));\n};\n\nPrivateKey.prototype.hash = function (algo, type) {\n\treturn (this.toPublic().hash(algo, type));\n};\n\nPrivateKey.prototype.fingerprint = function (algo, type) {\n\treturn (this.toPublic().fingerprint(algo, type));\n};\n\nPrivateKey.prototype.toPublic = function () {\n\tif (this._pubCache)\n\t\treturn (this._pubCache);\n\n\tvar algInfo = algs.info[this.type];\n\tvar pubParts = [];\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tvar p = algInfo.parts[i];\n\t\tpubParts.push(this.part[p]);\n\t}\n\n\tthis._pubCache = new Key({\n\t\ttype: this.type,\n\t\tsource: this,\n\t\tparts: pubParts\n\t});\n\tif (this.comment)\n\t\tthis._pubCache.comment = this.comment;\n\treturn (this._pubCache);\n};\n\nPrivateKey.prototype.derive = function (newType) {\n\tassert.string(newType, 'type');\n\tvar priv, pub, pair;\n\n\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'curve25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\tpriv = this.part.k.data;\n\t\tif (priv[0] === 0x00)\n\t\t\tpriv = priv.slice(1);\n\n\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\tpub = Buffer.from(pair.publicKey);\n\n\t\treturn (new PrivateKey({\n\t\t\ttype: 'ed25519',\n\t\t\tparts: [\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t]\n\t\t}));\n\t}\n\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t    ' to ' + newType));\n};\n\nPrivateKey.prototype.createVerify = function (hashAlgo) {\n\treturn (this.toPublic().createVerify(hashAlgo));\n};\n\nPrivateKey.prototype.createSign = function (hashAlgo) {\n\tif (hashAlgo === undefined)\n\t\thashAlgo = this.defaultHashAlgorithm();\n\tassert.string(hashAlgo, 'hash algorithm');\n\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\treturn (new edCompat.Signer(this, hashAlgo));\n\tif (this.type === 'curve25519')\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t    'signing or verification'));\n\n\tvar v, nm, err;\n\ttry {\n\t\tnm = hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tif (v === undefined || (err instanceof Error &&\n\t    err.message.match(/Unknown message digest/))) {\n\t\tnm = 'RSA-';\n\t\tnm += hashAlgo.toUpperCase();\n\t\tv = crypto.createSign(nm);\n\t}\n\tassert.ok(v, 'failed to create verifier');\n\tvar oldSign = v.sign.bind(v);\n\tvar key = this.toBuffer('pkcs1');\n\tvar type = this.type;\n\tvar curve = this.curve;\n\tv.sign = function () {\n\t\tvar sig = oldSign(key);\n\t\tif (typeof (sig) === 'string')\n\t\t\tsig = Buffer.from(sig, 'binary');\n\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\tsig.hashAlgorithm = hashAlgo;\n\t\tsig.curve = curve;\n\t\treturn (sig);\n\t};\n\treturn (v);\n};\n\nPrivateKey.parse = function (data, format, options) {\n\tif (typeof (data) !== 'string')\n\t\tassert.buffer(data, 'data');\n\tif (format === undefined)\n\t\tformat = 'auto';\n\tassert.string(format, 'format');\n\tif (typeof (options) === 'string')\n\t\toptions = { filename: options };\n\tassert.optionalObject(options, 'options');\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.optionalString(options.filename, 'options.filename');\n\tif (options.filename === undefined)\n\t\toptions.filename = '(unnamed)';\n\n\tassert.object(formats[format], 'formats[format]');\n\n\ttry {\n\t\tvar k = formats[format].read(data, options);\n\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\tif (!k.comment)\n\t\t\tk.comment = options.filename;\n\t\treturn (k);\n\t} catch (e) {\n\t\tif (e.name === 'KeyEncryptedError')\n\t\t\tthrow (e);\n\t\tthrow (new KeyParseError(options.filename, format, e));\n\t}\n};\n\nPrivateKey.isPrivateKey = function (obj, ver) {\n\treturn (utils.isCompatible(obj, PrivateKey, ver));\n};\n\nPrivateKey.generate = function (type, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\tassert.object(options, 'options');\n\n\tswitch (type) {\n\tcase 'ecdsa':\n\t\tif (options.curve === undefined)\n\t\t\toptions.curve = 'nistp256';\n\t\tassert.string(options.curve, 'options.curve');\n\t\treturn (generateECDSA(options.curve));\n\tcase 'ed25519':\n\t\treturn (generateED25519());\n\tdefault:\n\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t    'type \"' + type + '\"'));\n\t}\n};\n\n/*\n * API versions for PrivateKey:\n * [1,0] -- initial ver\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n * [1,2] -- added defaultHashAlgorithm\n * [1,3] -- added derive, ed, createDH\n * [1,4] -- first tagged version\n * [1,5] -- changed ed25519 part names and format\n * [1,6] -- type arguments for hash() and fingerprint()\n */\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\nPrivateKey._oldVersionDetect = function (obj) {\n\tassert.func(obj.toPublic);\n\tassert.func(obj.createSign);\n\tif (obj.derive)\n\t\treturn ([1, 3]);\n\tif (obj.defaultHashAlgorithm)\n\t\treturn ([1, 2]);\n\tif (obj.formats['auto'])\n\t\treturn ([1, 1]);\n\treturn ([1, 0]);\n};\n","start":1667202706171,"end":1667202706367},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/fingerprint.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/dhe.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ed-compat.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/tweetnacl/nacl-fast.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/auto.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\nimport { __require as require$$19 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/dnssec.js?commonjs-wrapped\";\nimport { __require as require$$20 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/putty.js?commonjs-wrapped\";\n\nvar privateKey;\nvar hasRequiredPrivateKey;\n\nfunction requirePrivateKey () {\n\tif (hasRequiredPrivateKey) return privateKey;\n\thasRequiredPrivateKey = 1;\n\t// Copyright 2017 Joyent, Inc.\n\n\tprivateKey = PrivateKey;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar algs = require$$2();\n\tvar crypto = require$$3;\n\tvar Fingerprint = require$$4();\n\tvar Signature = require$$5();\n\tvar errs = require$$6();\n\tvar util = require$$7();\n\tvar utils = require$$8();\n\tvar dhe = require$$9();\n\tvar generateECDSA = dhe.generateECDSA;\n\tvar generateED25519 = dhe.generateED25519;\n\tvar edCompat = require$$10();\n\tvar nacl = require$$11();\n\n\tvar Key = require$$12();\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar KeyParseError = errs.KeyParseError;\n\tvar KeyEncryptedError = errs.KeyEncryptedError;\n\n\tvar formats = {};\n\tformats['auto'] = require$$13();\n\tformats['pem'] = require$$14();\n\tformats['pkcs1'] = require$$15();\n\tformats['pkcs8'] = require$$16();\n\tformats['rfc4253'] = require$$17();\n\tformats['ssh-private'] = require$$18();\n\tformats['openssh'] = formats['ssh-private'];\n\tformats['ssh'] = formats['ssh-private'];\n\tformats['dnssec'] = require$$19();\n\tformats['putty'] = require$$20();\n\n\tfunction PrivateKey(opts) {\n\t\tassert.object(opts, 'options');\n\t\tKey.call(this, opts);\n\n\t\tthis._pubCache = undefined;\n\t}\n\tutil.inherits(PrivateKey, Key);\n\n\tPrivateKey.formats = formats;\n\n\tPrivateKey.prototype.toBuffer = function (format, options) {\n\t\tif (format === undefined)\n\t\t\tformat = 'pkcs1';\n\t\tassert.string(format, 'format');\n\t\tassert.object(formats[format], 'formats[format]');\n\t\tassert.optionalObject(options, 'options');\n\n\t\treturn (formats[format].write(this, options));\n\t};\n\n\tPrivateKey.prototype.hash = function (algo, type) {\n\t\treturn (this.toPublic().hash(algo, type));\n\t};\n\n\tPrivateKey.prototype.fingerprint = function (algo, type) {\n\t\treturn (this.toPublic().fingerprint(algo, type));\n\t};\n\n\tPrivateKey.prototype.toPublic = function () {\n\t\tif (this._pubCache)\n\t\t\treturn (this._pubCache);\n\n\t\tvar algInfo = algs.info[this.type];\n\t\tvar pubParts = [];\n\t\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\t\tvar p = algInfo.parts[i];\n\t\t\tpubParts.push(this.part[p]);\n\t\t}\n\n\t\tthis._pubCache = new Key({\n\t\t\ttype: this.type,\n\t\t\tsource: this,\n\t\t\tparts: pubParts\n\t\t});\n\t\tif (this.comment)\n\t\t\tthis._pubCache.comment = this.comment;\n\t\treturn (this._pubCache);\n\t};\n\n\tPrivateKey.prototype.derive = function (newType) {\n\t\tassert.string(newType, 'type');\n\t\tvar priv, pub, pair;\n\n\t\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\t\tpriv = this.part.k.data;\n\t\t\tif (priv[0] === 0x00)\n\t\t\t\tpriv = priv.slice(1);\n\n\t\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\t\tpub = Buffer.from(pair.publicKey);\n\n\t\t\treturn (new PrivateKey({\n\t\t\t\ttype: 'curve25519',\n\t\t\t\tparts: [\n\t\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t\t]\n\t\t\t}));\n\t\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\t\tpriv = this.part.k.data;\n\t\t\tif (priv[0] === 0x00)\n\t\t\t\tpriv = priv.slice(1);\n\n\t\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\t\tpub = Buffer.from(pair.publicKey);\n\n\t\t\treturn (new PrivateKey({\n\t\t\t\ttype: 'ed25519',\n\t\t\t\tparts: [\n\t\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t\t]\n\t\t\t}));\n\t\t}\n\t\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t\t    ' to ' + newType));\n\t};\n\n\tPrivateKey.prototype.createVerify = function (hashAlgo) {\n\t\treturn (this.toPublic().createVerify(hashAlgo));\n\t};\n\n\tPrivateKey.prototype.createSign = function (hashAlgo) {\n\t\tif (hashAlgo === undefined)\n\t\t\thashAlgo = this.defaultHashAlgorithm();\n\t\tassert.string(hashAlgo, 'hash algorithm');\n\n\t\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\t\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\t\treturn (new edCompat.Signer(this, hashAlgo));\n\t\tif (this.type === 'curve25519')\n\t\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t\t    'signing or verification'));\n\n\t\tvar v, nm, err;\n\t\ttry {\n\t\t\tnm = hashAlgo.toUpperCase();\n\t\t\tv = crypto.createSign(nm);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t}\n\t\tif (v === undefined || (err instanceof Error &&\n\t\t    err.message.match(/Unknown message digest/))) {\n\t\t\tnm = 'RSA-';\n\t\t\tnm += hashAlgo.toUpperCase();\n\t\t\tv = crypto.createSign(nm);\n\t\t}\n\t\tassert.ok(v, 'failed to create verifier');\n\t\tvar oldSign = v.sign.bind(v);\n\t\tvar key = this.toBuffer('pkcs1');\n\t\tvar type = this.type;\n\t\tvar curve = this.curve;\n\t\tv.sign = function () {\n\t\t\tvar sig = oldSign(key);\n\t\t\tif (typeof (sig) === 'string')\n\t\t\t\tsig = Buffer.from(sig, 'binary');\n\t\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\t\tsig.hashAlgorithm = hashAlgo;\n\t\t\tsig.curve = curve;\n\t\t\treturn (sig);\n\t\t};\n\t\treturn (v);\n\t};\n\n\tPrivateKey.parse = function (data, format, options) {\n\t\tif (typeof (data) !== 'string')\n\t\t\tassert.buffer(data, 'data');\n\t\tif (format === undefined)\n\t\t\tformat = 'auto';\n\t\tassert.string(format, 'format');\n\t\tif (typeof (options) === 'string')\n\t\t\toptions = { filename: options };\n\t\tassert.optionalObject(options, 'options');\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.optionalString(options.filename, 'options.filename');\n\t\tif (options.filename === undefined)\n\t\t\toptions.filename = '(unnamed)';\n\n\t\tassert.object(formats[format], 'formats[format]');\n\n\t\ttry {\n\t\t\tvar k = formats[format].read(data, options);\n\t\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\t\tif (!k.comment)\n\t\t\t\tk.comment = options.filename;\n\t\t\treturn (k);\n\t\t} catch (e) {\n\t\t\tif (e.name === 'KeyEncryptedError')\n\t\t\t\tthrow (e);\n\t\t\tthrow (new KeyParseError(options.filename, format, e));\n\t\t}\n\t};\n\n\tPrivateKey.isPrivateKey = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, PrivateKey, ver));\n\t};\n\n\tPrivateKey.generate = function (type, options) {\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.object(options, 'options');\n\n\t\tswitch (type) {\n\t\tcase 'ecdsa':\n\t\t\tif (options.curve === undefined)\n\t\t\t\toptions.curve = 'nistp256';\n\t\t\tassert.string(options.curve, 'options.curve');\n\t\t\treturn (generateECDSA(options.curve));\n\t\tcase 'ed25519':\n\t\t\treturn (generateED25519());\n\t\tdefault:\n\t\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t\t    'type \"' + type + '\"'));\n\t\t}\n\t};\n\n\t/*\n\t * API versions for PrivateKey:\n\t * [1,0] -- initial ver\n\t * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n\t * [1,2] -- added defaultHashAlgorithm\n\t * [1,3] -- added derive, ed, createDH\n\t * [1,4] -- first tagged version\n\t * [1,5] -- changed ed25519 part names and format\n\t * [1,6] -- type arguments for hash() and fingerprint()\n\t */\n\tPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\n\tPrivateKey._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toPublic);\n\t\tassert.func(obj.createSign);\n\t\tif (obj.derive)\n\t\t\treturn ([1, 3]);\n\t\tif (obj.defaultHashAlgorithm)\n\t\t\treturn ([1, 2]);\n\t\tif (obj.formats['auto'])\n\t\t\treturn ([1, 1]);\n\t\treturn ([1, 0]);\n\t};\n\treturn privateKey;\n}\n\nexport { requirePrivateKey as __require };","start":1667202706368,"end":1667202707948,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport require$$3 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/fingerprint.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/errors.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/dhe.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ed-compat.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/tweetnacl/nacl-fast.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/auto.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pem.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs1.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/pkcs8.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/ssh-private.js?commonjs-wrapped\";\nimport { __require as require$$19 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/dnssec.js?commonjs-wrapped\";\nimport { __require as require$$20 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/putty.js?commonjs-wrapped\";\n\nvar privateKey;\nvar hasRequiredPrivateKey;\n\nfunction requirePrivateKey () {\n\tif (hasRequiredPrivateKey) return privateKey;\n\thasRequiredPrivateKey = 1;\n\t// Copyright 2017 Joyent, Inc.\n\n\tprivateKey = PrivateKey;\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar algs = require$$2();\n\tvar crypto = require$$3;\n\tvar Fingerprint = require$$4();\n\tvar Signature = require$$5();\n\tvar errs = require$$6();\n\tvar util = require$$7();\n\tvar utils = require$$8();\n\tvar dhe = require$$9();\n\tvar generateECDSA = dhe.generateECDSA;\n\tvar generateED25519 = dhe.generateED25519;\n\tvar edCompat = require$$10();\n\tvar nacl = require$$11();\n\n\tvar Key = require$$12();\n\n\tvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\tvar KeyParseError = errs.KeyParseError;\n\tvar KeyEncryptedError = errs.KeyEncryptedError;\n\n\tvar formats = {};\n\tformats['auto'] = require$$13();\n\tformats['pem'] = require$$14();\n\tformats['pkcs1'] = require$$15();\n\tformats['pkcs8'] = require$$16();\n\tformats['rfc4253'] = require$$17();\n\tformats['ssh-private'] = require$$18();\n\tformats['openssh'] = formats['ssh-private'];\n\tformats['ssh'] = formats['ssh-private'];\n\tformats['dnssec'] = require$$19();\n\tformats['putty'] = require$$20();\n\n\tfunction PrivateKey(opts) {\n\t\tassert.object(opts, 'options');\n\t\tKey.call(this, opts);\n\n\t\tthis._pubCache = undefined;\n\t}\n\tutil.inherits(PrivateKey, Key);\n\n\tPrivateKey.formats = formats;\n\n\tPrivateKey.prototype.toBuffer = function (format, options) {\n\t\tif (format === undefined)\n\t\t\tformat = 'pkcs1';\n\t\tassert.string(format, 'format');\n\t\tassert.object(formats[format], 'formats[format]');\n\t\tassert.optionalObject(options, 'options');\n\n\t\treturn (formats[format].write(this, options));\n\t};\n\n\tPrivateKey.prototype.hash = function (algo, type) {\n\t\treturn (this.toPublic().hash(algo, type));\n\t};\n\n\tPrivateKey.prototype.fingerprint = function (algo, type) {\n\t\treturn (this.toPublic().fingerprint(algo, type));\n\t};\n\n\tPrivateKey.prototype.toPublic = function () {\n\t\tif (this._pubCache)\n\t\t\treturn (this._pubCache);\n\n\t\tvar algInfo = algs.info[this.type];\n\t\tvar pubParts = [];\n\t\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\t\tvar p = algInfo.parts[i];\n\t\t\tpubParts.push(this.part[p]);\n\t\t}\n\n\t\tthis._pubCache = new Key({\n\t\t\ttype: this.type,\n\t\t\tsource: this,\n\t\t\tparts: pubParts\n\t\t});\n\t\tif (this.comment)\n\t\t\tthis._pubCache.comment = this.comment;\n\t\treturn (this._pubCache);\n\t};\n\n\tPrivateKey.prototype.derive = function (newType) {\n\t\tassert.string(newType, 'type');\n\t\tvar priv, pub, pair;\n\n\t\tif (this.type === 'ed25519' && newType === 'curve25519') {\n\t\t\tpriv = this.part.k.data;\n\t\t\tif (priv[0] === 0x00)\n\t\t\t\tpriv = priv.slice(1);\n\n\t\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\n\t\t\tpub = Buffer.from(pair.publicKey);\n\n\t\t\treturn (new PrivateKey({\n\t\t\t\ttype: 'curve25519',\n\t\t\t\tparts: [\n\t\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t\t]\n\t\t\t}));\n\t\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\n\t\t\tpriv = this.part.k.data;\n\t\t\tif (priv[0] === 0x00)\n\t\t\t\tpriv = priv.slice(1);\n\n\t\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\n\t\t\tpub = Buffer.from(pair.publicKey);\n\n\t\t\treturn (new PrivateKey({\n\t\t\t\ttype: 'ed25519',\n\t\t\t\tparts: [\n\t\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\n\t\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\n\t\t\t\t]\n\t\t\t}));\n\t\t}\n\t\tthrow (new Error('Key derivation not supported from ' + this.type +\n\t\t    ' to ' + newType));\n\t};\n\n\tPrivateKey.prototype.createVerify = function (hashAlgo) {\n\t\treturn (this.toPublic().createVerify(hashAlgo));\n\t};\n\n\tPrivateKey.prototype.createSign = function (hashAlgo) {\n\t\tif (hashAlgo === undefined)\n\t\t\thashAlgo = this.defaultHashAlgorithm();\n\t\tassert.string(hashAlgo, 'hash algorithm');\n\n\t\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\t\tif (this.type === 'ed25519' && edCompat !== undefined)\n\t\t\treturn (new edCompat.Signer(this, hashAlgo));\n\t\tif (this.type === 'curve25519')\n\t\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\n\t\t\t    'signing or verification'));\n\n\t\tvar v, nm, err;\n\t\ttry {\n\t\t\tnm = hashAlgo.toUpperCase();\n\t\t\tv = crypto.createSign(nm);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t}\n\t\tif (v === undefined || (err instanceof Error &&\n\t\t    err.message.match(/Unknown message digest/))) {\n\t\t\tnm = 'RSA-';\n\t\t\tnm += hashAlgo.toUpperCase();\n\t\t\tv = crypto.createSign(nm);\n\t\t}\n\t\tassert.ok(v, 'failed to create verifier');\n\t\tvar oldSign = v.sign.bind(v);\n\t\tvar key = this.toBuffer('pkcs1');\n\t\tvar type = this.type;\n\t\tvar curve = this.curve;\n\t\tv.sign = function () {\n\t\t\tvar sig = oldSign(key);\n\t\t\tif (typeof (sig) === 'string')\n\t\t\t\tsig = Buffer.from(sig, 'binary');\n\t\t\tsig = Signature.parse(sig, type, 'asn1');\n\t\t\tsig.hashAlgorithm = hashAlgo;\n\t\t\tsig.curve = curve;\n\t\t\treturn (sig);\n\t\t};\n\t\treturn (v);\n\t};\n\n\tPrivateKey.parse = function (data, format, options) {\n\t\tif (typeof (data) !== 'string')\n\t\t\tassert.buffer(data, 'data');\n\t\tif (format === undefined)\n\t\t\tformat = 'auto';\n\t\tassert.string(format, 'format');\n\t\tif (typeof (options) === 'string')\n\t\t\toptions = { filename: options };\n\t\tassert.optionalObject(options, 'options');\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.optionalString(options.filename, 'options.filename');\n\t\tif (options.filename === undefined)\n\t\t\toptions.filename = '(unnamed)';\n\n\t\tassert.object(formats[format], 'formats[format]');\n\n\t\ttry {\n\t\t\tvar k = formats[format].read(data, options);\n\t\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\n\t\t\tif (!k.comment)\n\t\t\t\tk.comment = options.filename;\n\t\t\treturn (k);\n\t\t} catch (e) {\n\t\t\tif (e.name === 'KeyEncryptedError')\n\t\t\t\tthrow (e);\n\t\t\tthrow (new KeyParseError(options.filename, format, e));\n\t\t}\n\t};\n\n\tPrivateKey.isPrivateKey = function (obj, ver) {\n\t\treturn (utils.isCompatible(obj, PrivateKey, ver));\n\t};\n\n\tPrivateKey.generate = function (type, options) {\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\t\tassert.object(options, 'options');\n\n\t\tswitch (type) {\n\t\tcase 'ecdsa':\n\t\t\tif (options.curve === undefined)\n\t\t\t\toptions.curve = 'nistp256';\n\t\t\tassert.string(options.curve, 'options.curve');\n\t\t\treturn (generateECDSA(options.curve));\n\t\tcase 'ed25519':\n\t\t\treturn (generateED25519());\n\t\tdefault:\n\t\t\tthrow (new Error('Key generation not supported with key ' +\n\t\t\t    'type \"' + type + '\"'));\n\t\t}\n\t};\n\n\t/*\n\t * API versions for PrivateKey:\n\t * [1,0] -- initial ver\n\t * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\n\t * [1,2] -- added defaultHashAlgorithm\n\t * [1,3] -- added derive, ed, createDH\n\t * [1,4] -- first tagged version\n\t * [1,5] -- changed ed25519 part names and format\n\t * [1,6] -- type arguments for hash() and fingerprint()\n\t */\n\tPrivateKey.prototype._sshpkApiVersion = [1, 6];\n\n\tPrivateKey._oldVersionDetect = function (obj) {\n\t\tassert.func(obj.toPublic);\n\t\tassert.func(obj.createSign);\n\t\tif (obj.derive)\n\t\t\treturn ([1, 3]);\n\t\tif (obj.defaultHashAlgorithm)\n\t\t\treturn ([1, 2]);\n\t\tif (obj.formats['auto'])\n\t\t\treturn ([1, 1]);\n\t\treturn ([1, 0]);\n\t};\n\treturn privateKey;\n}\n\nexport { requirePrivateKey as __require };","start":1667202707948,"end":1667202707954,"order":"normal"}]}
