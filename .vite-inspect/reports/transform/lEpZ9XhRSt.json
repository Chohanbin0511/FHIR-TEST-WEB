{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2015 Joyent, Inc.\n\nmodule.exports = {\n\tbufferSplit: bufferSplit,\n\taddRSAMissing: addRSAMissing,\n\tcalculateDSAPublic: calculateDSAPublic,\n\tcalculateED25519Public: calculateED25519Public,\n\tcalculateX25519Public: calculateX25519Public,\n\tmpNormalize: mpNormalize,\n\tmpDenormalize: mpDenormalize,\n\tecNormalize: ecNormalize,\n\tcountZeros: countZeros,\n\tassertCompatible: assertCompatible,\n\tisCompatible: isCompatible,\n\topensslKeyDeriv: opensslKeyDeriv,\n\topensshCipherInfo: opensshCipherInfo,\n\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\n\tzeroPadToLength: zeroPadToLength,\n\twriteBitString: writeBitString,\n\treadBitString: readBitString,\n\tpbkdf2: pbkdf2\n};\n\nvar assert = require('assert-plus');\nvar Buffer = require('safer-buffer').Buffer;\nvar PrivateKey = require('./private-key');\nvar Key = require('./key');\nvar crypto = require('crypto');\nvar algs = require('./algs');\nvar asn1 = require('asn1');\n\nvar ec = require('ecc-jsbn/lib/ec');\nvar jsbn = require('jsbn').BigInteger;\nvar nacl = require('tweetnacl');\n\nvar MAX_CLASS_DEPTH = 3;\n\nfunction isCompatible(obj, klass, needVer) {\n\tif (obj === null || typeof (obj) !== 'object')\n\t\treturn (false);\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn (true);\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\n\t\t\treturn (false);\n\t}\n\tif (proto.constructor.name !== klass.name)\n\t\treturn (false);\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\n\t\treturn (false);\n\treturn (true);\n}\n\nfunction assertCompatible(obj, klass, needVer, name) {\n\tif (name === undefined)\n\t\tname = 'object';\n\tassert.ok(obj, name + ' must not be null');\n\tassert.object(obj, name + ' must be an object');\n\tif (needVer === undefined)\n\t\tneedVer = klass.prototype._sshpkApiVersion;\n\tif (obj instanceof klass &&\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\treturn;\n\tvar proto = Object.getPrototypeOf(obj);\n\tvar depth = 0;\n\twhile (proto.constructor.name !== klass.name) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\n\t\t    name + ' must be a ' + klass.name + ' instance');\n\t}\n\tassert.strictEqual(proto.constructor.name, klass.name,\n\t    name + ' must be a ' + klass.name + ' instance');\n\tvar ver = proto._sshpkApiVersion;\n\tif (ver === undefined)\n\t\tver = klass._oldVersionDetect(obj);\n\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\n\t    name + ' must be compatible with ' + klass.name + ' klass ' +\n\t    'version ' + needVer[0] + '.' + needVer[1]);\n}\n\nvar CIPHER_LEN = {\n\t'des-ede3-cbc': { key: 24, iv: 8 },\n\t'aes-128-cbc': { key: 16, iv: 16 },\n\t'aes-256-cbc': { key: 32, iv: 16 }\n};\nvar PKCS5_SALT_LEN = 8;\n\nfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\n\tassert.buffer(salt, 'salt');\n\tassert.buffer(passphrase, 'passphrase');\n\tassert.number(count, 'iteration count');\n\n\tvar clen = CIPHER_LEN[cipher];\n\tassert.object(clen, 'supported cipher');\n\n\tsalt = salt.slice(0, PKCS5_SALT_LEN);\n\n\tvar D, D_prev, bufs;\n\tvar material = Buffer.alloc(0);\n\twhile (material.length < clen.key + clen.iv) {\n\t\tbufs = [];\n\t\tif (D_prev)\n\t\t\tbufs.push(D_prev);\n\t\tbufs.push(passphrase);\n\t\tbufs.push(salt);\n\t\tD = Buffer.concat(bufs);\n\t\tfor (var j = 0; j < count; ++j)\n\t\t\tD = crypto.createHash('md5').update(D).digest();\n\t\tmaterial = Buffer.concat([material, D]);\n\t\tD_prev = D;\n\t}\n\n\treturn ({\n\t    key: material.slice(0, clen.key),\n\t    iv: material.slice(clen.key, clen.key + clen.iv)\n\t});\n}\n\n/* See: RFC2898 */\nfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\n\tvar hkey = Buffer.alloc(salt.length + 4);\n\tsalt.copy(hkey);\n\n\tvar gen = 0, ts = [];\n\tvar i = 1;\n\twhile (gen < size) {\n\t\tvar t = T(i++);\n\t\tgen += t.length;\n\t\tts.push(t);\n\t}\n\treturn (Buffer.concat(ts).slice(0, size));\n\n\tfunction T(I) {\n\t\thkey.writeUInt32BE(I, hkey.length - 4);\n\n\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\n\t\thmac.update(hkey);\n\n\t\tvar Ti = hmac.digest();\n\t\tvar Uc = Ti;\n\t\tvar c = 1;\n\t\twhile (c++ < iterations) {\n\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\thmac.update(Uc);\n\t\t\tUc = hmac.digest();\n\t\t\tfor (var x = 0; x < Ti.length; ++x)\n\t\t\t\tTi[x] ^= Uc[x];\n\t\t}\n\t\treturn (Ti);\n\t}\n}\n\n/* Count leading zero bits on a buffer */\nfunction countZeros(buf) {\n\tvar o = 0, obit = 8;\n\twhile (o < buf.length) {\n\t\tvar mask = (1 << obit);\n\t\tif ((buf[o] & mask) === mask)\n\t\t\tbreak;\n\t\tobit--;\n\t\tif (obit < 0) {\n\t\t\to++;\n\t\t\tobit = 8;\n\t\t}\n\t}\n\treturn (o*8 + (8 - obit) - 1);\n}\n\nfunction bufferSplit(buf, chr) {\n\tassert.buffer(buf);\n\tassert.string(chr);\n\n\tvar parts = [];\n\tvar lastPart = 0;\n\tvar matches = 0;\n\tfor (var i = 0; i < buf.length; ++i) {\n\t\tif (buf[i] === chr.charCodeAt(matches))\n\t\t\t++matches;\n\t\telse if (buf[i] === chr.charCodeAt(0))\n\t\t\tmatches = 1;\n\t\telse\n\t\t\tmatches = 0;\n\n\t\tif (matches >= chr.length) {\n\t\t\tvar newPart = i + 1;\n\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\n\t\t\tlastPart = newPart;\n\t\t\tmatches = 0;\n\t\t}\n\t}\n\tif (lastPart <= buf.length)\n\t\tparts.push(buf.slice(lastPart, buf.length));\n\n\treturn (parts);\n}\n\nfunction ecNormalize(buf, addZero) {\n\tassert.buffer(buf);\n\tif (buf[0] === 0x00 && buf[1] === 0x04) {\n\t\tif (addZero)\n\t\t\treturn (buf);\n\t\treturn (buf.slice(1));\n\t} else if (buf[0] === 0x04) {\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t} else {\n\t\twhile (buf[0] === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\n\t\t\tthrow (new Error('Compressed elliptic curve points ' +\n\t\t\t    'are not supported'));\n\t\tif (buf[0] !== 0x04)\n\t\t\tthrow (new Error('Not a valid elliptic curve point'));\n\t\tif (!addZero)\n\t\t\treturn (buf);\n\t}\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x0;\n\tbuf.copy(b, 1);\n\treturn (b);\n}\n\nfunction readBitString(der, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar buf = der.readString(tag, true);\n\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\n\t    'not supported (0x' + buf[0].toString(16) + ')');\n\treturn (buf.slice(1));\n}\n\nfunction writeBitString(der, buf, tag) {\n\tif (tag === undefined)\n\t\ttag = asn1.Ber.BitString;\n\tvar b = Buffer.alloc(buf.length + 1);\n\tb[0] = 0x00;\n\tbuf.copy(b, 1);\n\tder.writeBuffer(b, tag);\n}\n\nfunction mpNormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\n\t\tbuf = buf.slice(1);\n\tif ((buf[0] & 0x80) === 0x80) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction mpDenormalize(buf) {\n\tassert.buffer(buf);\n\twhile (buf.length > 1 && buf[0] === 0x00)\n\t\tbuf = buf.slice(1);\n\treturn (buf);\n}\n\nfunction zeroPadToLength(buf, len) {\n\tassert.buffer(buf);\n\tassert.number(len);\n\twhile (buf.length > len) {\n\t\tassert.equal(buf[0], 0x00);\n\t\tbuf = buf.slice(1);\n\t}\n\twhile (buf.length < len) {\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tbuf = b;\n\t}\n\treturn (buf);\n}\n\nfunction bigintToMpBuf(bigint) {\n\tvar buf = Buffer.from(bigint.toByteArray());\n\tbuf = mpNormalize(buf);\n\treturn (buf);\n}\n\nfunction calculateDSAPublic(g, p, x) {\n\tassert.buffer(g);\n\tassert.buffer(p);\n\tassert.buffer(x);\n\tg = new jsbn(g);\n\tp = new jsbn(p);\n\tx = new jsbn(x);\n\tvar y = g.modPow(x, p);\n\tvar ybuf = bigintToMpBuf(y);\n\treturn (ybuf);\n}\n\nfunction calculateED25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction calculateX25519Public(k) {\n\tassert.buffer(k);\n\n\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\n\treturn (Buffer.from(kp.publicKey));\n}\n\nfunction addRSAMissing(key) {\n\tassert.object(key);\n\tassertCompatible(key, PrivateKey, [1, 1]);\n\n\tvar d = new jsbn(key.part.d.data);\n\tvar buf;\n\n\tif (!key.part.dmodp) {\n\t\tvar p = new jsbn(key.part.p.data);\n\t\tvar dmodp = d.mod(p.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodp);\n\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\n\t\tkey.parts.push(key.part.dmodp);\n\t}\n\tif (!key.part.dmodq) {\n\t\tvar q = new jsbn(key.part.q.data);\n\t\tvar dmodq = d.mod(q.subtract(1));\n\n\t\tbuf = bigintToMpBuf(dmodq);\n\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\n\t\tkey.parts.push(key.part.dmodq);\n\t}\n}\n\nfunction publicFromPrivateECDSA(curveName, priv) {\n\tassert.string(curveName, 'curveName');\n\tassert.buffer(priv);\n\tvar params = algs.curves[curveName];\n\tvar p = new jsbn(params.p);\n\tvar a = new jsbn(params.a);\n\tvar b = new jsbn(params.b);\n\tvar curve = new ec.ECCurveFp(p, a, b);\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\tvar d = new jsbn(mpNormalize(priv));\n\tvar pub = G.multiply(d);\n\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\n\n\tvar parts = [];\n\tparts.push({name: 'curve', data: Buffer.from(curveName)});\n\tparts.push({name: 'Q', data: pub});\n\n\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\n\treturn (key);\n}\n\nfunction opensshCipherInfo(cipher) {\n\tvar inf = {};\n\tswitch (cipher) {\n\tcase '3des-cbc':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'des-ede3-cbc';\n\t\tbreak;\n\tcase 'blowfish-cbc':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 8;\n\t\tinf.opensslName = 'bf-cbc';\n\t\tbreak;\n\tcase 'aes128-cbc':\n\tcase 'aes128-ctr':\n\tcase 'aes128-gcm@openssh.com':\n\t\tinf.keySize = 16;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes192-cbc':\n\tcase 'aes192-ctr':\n\tcase 'aes192-gcm@openssh.com':\n\t\tinf.keySize = 24;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\n\t\tbreak;\n\tcase 'aes256-cbc':\n\tcase 'aes256-ctr':\n\tcase 'aes256-gcm@openssh.com':\n\t\tinf.keySize = 32;\n\t\tinf.blockSize = 16;\n\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\n\t\tbreak;\n\tdefault:\n\t\tthrow (new Error(\n\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\n\t}\n\treturn (inf);\n}\n","start":1667202706595,"end":1667202706698},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport require$$4 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/ec.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/jsbn/index.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/tweetnacl/nacl-fast.js?commonjs-wrapped\";\n\nvar utils;\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tutils = {\n\t\tbufferSplit: bufferSplit,\n\t\taddRSAMissing: addRSAMissing,\n\t\tcalculateDSAPublic: calculateDSAPublic,\n\t\tcalculateED25519Public: calculateED25519Public,\n\t\tcalculateX25519Public: calculateX25519Public,\n\t\tmpNormalize: mpNormalize,\n\t\tmpDenormalize: mpDenormalize,\n\t\tecNormalize: ecNormalize,\n\t\tcountZeros: countZeros,\n\t\tassertCompatible: assertCompatible,\n\t\tisCompatible: isCompatible,\n\t\topensslKeyDeriv: opensslKeyDeriv,\n\t\topensshCipherInfo: opensshCipherInfo,\n\t\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\n\t\tzeroPadToLength: zeroPadToLength,\n\t\twriteBitString: writeBitString,\n\t\treadBitString: readBitString,\n\t\tpbkdf2: pbkdf2\n\t};\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar PrivateKey = require$$2();\n\tvar Key = require$$3();\n\tvar crypto = require$$4;\n\tvar algs = require$$5();\n\tvar asn1 = require$$6();\n\n\tvar ec = require$$7();\n\tvar jsbn = require$$8().BigInteger;\n\tvar nacl = require$$9();\n\n\tvar MAX_CLASS_DEPTH = 3;\n\n\tfunction isCompatible(obj, klass, needVer) {\n\t\tif (obj === null || typeof (obj) !== 'object')\n\t\t\treturn (false);\n\t\tif (needVer === undefined)\n\t\t\tneedVer = klass.prototype._sshpkApiVersion;\n\t\tif (obj instanceof klass &&\n\t\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\t\treturn (true);\n\t\tvar proto = Object.getPrototypeOf(obj);\n\t\tvar depth = 0;\n\t\twhile (proto.constructor.name !== klass.name) {\n\t\t\tproto = Object.getPrototypeOf(proto);\n\t\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\n\t\t\t\treturn (false);\n\t\t}\n\t\tif (proto.constructor.name !== klass.name)\n\t\t\treturn (false);\n\t\tvar ver = proto._sshpkApiVersion;\n\t\tif (ver === undefined)\n\t\t\tver = klass._oldVersionDetect(obj);\n\t\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\n\t\t\treturn (false);\n\t\treturn (true);\n\t}\n\n\tfunction assertCompatible(obj, klass, needVer, name) {\n\t\tif (name === undefined)\n\t\t\tname = 'object';\n\t\tassert.ok(obj, name + ' must not be null');\n\t\tassert.object(obj, name + ' must be an object');\n\t\tif (needVer === undefined)\n\t\t\tneedVer = klass.prototype._sshpkApiVersion;\n\t\tif (obj instanceof klass &&\n\t\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\t\treturn;\n\t\tvar proto = Object.getPrototypeOf(obj);\n\t\tvar depth = 0;\n\t\twhile (proto.constructor.name !== klass.name) {\n\t\t\tproto = Object.getPrototypeOf(proto);\n\t\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\n\t\t\t    name + ' must be a ' + klass.name + ' instance');\n\t\t}\n\t\tassert.strictEqual(proto.constructor.name, klass.name,\n\t\t    name + ' must be a ' + klass.name + ' instance');\n\t\tvar ver = proto._sshpkApiVersion;\n\t\tif (ver === undefined)\n\t\t\tver = klass._oldVersionDetect(obj);\n\t\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\n\t\t    name + ' must be compatible with ' + klass.name + ' klass ' +\n\t\t    'version ' + needVer[0] + '.' + needVer[1]);\n\t}\n\n\tvar CIPHER_LEN = {\n\t\t'des-ede3-cbc': { key: 24, iv: 8 },\n\t\t'aes-128-cbc': { key: 16, iv: 16 },\n\t\t'aes-256-cbc': { key: 32, iv: 16 }\n\t};\n\tvar PKCS5_SALT_LEN = 8;\n\n\tfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\n\t\tassert.buffer(salt, 'salt');\n\t\tassert.buffer(passphrase, 'passphrase');\n\t\tassert.number(count, 'iteration count');\n\n\t\tvar clen = CIPHER_LEN[cipher];\n\t\tassert.object(clen, 'supported cipher');\n\n\t\tsalt = salt.slice(0, PKCS5_SALT_LEN);\n\n\t\tvar D, D_prev, bufs;\n\t\tvar material = Buffer.alloc(0);\n\t\twhile (material.length < clen.key + clen.iv) {\n\t\t\tbufs = [];\n\t\t\tif (D_prev)\n\t\t\t\tbufs.push(D_prev);\n\t\t\tbufs.push(passphrase);\n\t\t\tbufs.push(salt);\n\t\t\tD = Buffer.concat(bufs);\n\t\t\tfor (var j = 0; j < count; ++j)\n\t\t\t\tD = crypto.createHash('md5').update(D).digest();\n\t\t\tmaterial = Buffer.concat([material, D]);\n\t\t\tD_prev = D;\n\t\t}\n\n\t\treturn ({\n\t\t    key: material.slice(0, clen.key),\n\t\t    iv: material.slice(clen.key, clen.key + clen.iv)\n\t\t});\n\t}\n\n\t/* See: RFC2898 */\n\tfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\n\t\tvar hkey = Buffer.alloc(salt.length + 4);\n\t\tsalt.copy(hkey);\n\n\t\tvar gen = 0, ts = [];\n\t\tvar i = 1;\n\t\twhile (gen < size) {\n\t\t\tvar t = T(i++);\n\t\t\tgen += t.length;\n\t\t\tts.push(t);\n\t\t}\n\t\treturn (Buffer.concat(ts).slice(0, size));\n\n\t\tfunction T(I) {\n\t\t\thkey.writeUInt32BE(I, hkey.length - 4);\n\n\t\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\thmac.update(hkey);\n\n\t\t\tvar Ti = hmac.digest();\n\t\t\tvar Uc = Ti;\n\t\t\tvar c = 1;\n\t\t\twhile (c++ < iterations) {\n\t\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\t\thmac.update(Uc);\n\t\t\t\tUc = hmac.digest();\n\t\t\t\tfor (var x = 0; x < Ti.length; ++x)\n\t\t\t\t\tTi[x] ^= Uc[x];\n\t\t\t}\n\t\t\treturn (Ti);\n\t\t}\n\t}\n\n\t/* Count leading zero bits on a buffer */\n\tfunction countZeros(buf) {\n\t\tvar o = 0, obit = 8;\n\t\twhile (o < buf.length) {\n\t\t\tvar mask = (1 << obit);\n\t\t\tif ((buf[o] & mask) === mask)\n\t\t\t\tbreak;\n\t\t\tobit--;\n\t\t\tif (obit < 0) {\n\t\t\t\to++;\n\t\t\t\tobit = 8;\n\t\t\t}\n\t\t}\n\t\treturn (o*8 + (8 - obit) - 1);\n\t}\n\n\tfunction bufferSplit(buf, chr) {\n\t\tassert.buffer(buf);\n\t\tassert.string(chr);\n\n\t\tvar parts = [];\n\t\tvar lastPart = 0;\n\t\tvar matches = 0;\n\t\tfor (var i = 0; i < buf.length; ++i) {\n\t\t\tif (buf[i] === chr.charCodeAt(matches))\n\t\t\t\t++matches;\n\t\t\telse if (buf[i] === chr.charCodeAt(0))\n\t\t\t\tmatches = 1;\n\t\t\telse\n\t\t\t\tmatches = 0;\n\n\t\t\tif (matches >= chr.length) {\n\t\t\t\tvar newPart = i + 1;\n\t\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\n\t\t\t\tlastPart = newPart;\n\t\t\t\tmatches = 0;\n\t\t\t}\n\t\t}\n\t\tif (lastPart <= buf.length)\n\t\t\tparts.push(buf.slice(lastPart, buf.length));\n\n\t\treturn (parts);\n\t}\n\n\tfunction ecNormalize(buf, addZero) {\n\t\tassert.buffer(buf);\n\t\tif (buf[0] === 0x00 && buf[1] === 0x04) {\n\t\t\tif (addZero)\n\t\t\t\treturn (buf);\n\t\t\treturn (buf.slice(1));\n\t\t} else if (buf[0] === 0x04) {\n\t\t\tif (!addZero)\n\t\t\t\treturn (buf);\n\t\t} else {\n\t\t\twhile (buf[0] === 0x00)\n\t\t\t\tbuf = buf.slice(1);\n\t\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\n\t\t\t\tthrow (new Error('Compressed elliptic curve points ' +\n\t\t\t\t    'are not supported'));\n\t\t\tif (buf[0] !== 0x04)\n\t\t\t\tthrow (new Error('Not a valid elliptic curve point'));\n\t\t\tif (!addZero)\n\t\t\t\treturn (buf);\n\t\t}\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x0;\n\t\tbuf.copy(b, 1);\n\t\treturn (b);\n\t}\n\n\tfunction readBitString(der, tag) {\n\t\tif (tag === undefined)\n\t\t\ttag = asn1.Ber.BitString;\n\t\tvar buf = der.readString(tag, true);\n\t\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\n\t\t    'not supported (0x' + buf[0].toString(16) + ')');\n\t\treturn (buf.slice(1));\n\t}\n\n\tfunction writeBitString(der, buf, tag) {\n\t\tif (tag === undefined)\n\t\t\ttag = asn1.Ber.BitString;\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tder.writeBuffer(b, tag);\n\t}\n\n\tfunction mpNormalize(buf) {\n\t\tassert.buffer(buf);\n\t\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\tif ((buf[0] & 0x80) === 0x80) {\n\t\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\t\tb[0] = 0x00;\n\t\t\tbuf.copy(b, 1);\n\t\t\tbuf = b;\n\t\t}\n\t\treturn (buf);\n\t}\n\n\tfunction mpDenormalize(buf) {\n\t\tassert.buffer(buf);\n\t\twhile (buf.length > 1 && buf[0] === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\treturn (buf);\n\t}\n\n\tfunction zeroPadToLength(buf, len) {\n\t\tassert.buffer(buf);\n\t\tassert.number(len);\n\t\twhile (buf.length > len) {\n\t\t\tassert.equal(buf[0], 0x00);\n\t\t\tbuf = buf.slice(1);\n\t\t}\n\t\twhile (buf.length < len) {\n\t\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\t\tb[0] = 0x00;\n\t\t\tbuf.copy(b, 1);\n\t\t\tbuf = b;\n\t\t}\n\t\treturn (buf);\n\t}\n\n\tfunction bigintToMpBuf(bigint) {\n\t\tvar buf = Buffer.from(bigint.toByteArray());\n\t\tbuf = mpNormalize(buf);\n\t\treturn (buf);\n\t}\n\n\tfunction calculateDSAPublic(g, p, x) {\n\t\tassert.buffer(g);\n\t\tassert.buffer(p);\n\t\tassert.buffer(x);\n\t\tg = new jsbn(g);\n\t\tp = new jsbn(p);\n\t\tx = new jsbn(x);\n\t\tvar y = g.modPow(x, p);\n\t\tvar ybuf = bigintToMpBuf(y);\n\t\treturn (ybuf);\n\t}\n\n\tfunction calculateED25519Public(k) {\n\t\tassert.buffer(k);\n\n\t\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\n\t\treturn (Buffer.from(kp.publicKey));\n\t}\n\n\tfunction calculateX25519Public(k) {\n\t\tassert.buffer(k);\n\n\t\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\n\t\treturn (Buffer.from(kp.publicKey));\n\t}\n\n\tfunction addRSAMissing(key) {\n\t\tassert.object(key);\n\t\tassertCompatible(key, PrivateKey, [1, 1]);\n\n\t\tvar d = new jsbn(key.part.d.data);\n\t\tvar buf;\n\n\t\tif (!key.part.dmodp) {\n\t\t\tvar p = new jsbn(key.part.p.data);\n\t\t\tvar dmodp = d.mod(p.subtract(1));\n\n\t\t\tbuf = bigintToMpBuf(dmodp);\n\t\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\n\t\t\tkey.parts.push(key.part.dmodp);\n\t\t}\n\t\tif (!key.part.dmodq) {\n\t\t\tvar q = new jsbn(key.part.q.data);\n\t\t\tvar dmodq = d.mod(q.subtract(1));\n\n\t\t\tbuf = bigintToMpBuf(dmodq);\n\t\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\n\t\t\tkey.parts.push(key.part.dmodq);\n\t\t}\n\t}\n\n\tfunction publicFromPrivateECDSA(curveName, priv) {\n\t\tassert.string(curveName, 'curveName');\n\t\tassert.buffer(priv);\n\t\tvar params = algs.curves[curveName];\n\t\tvar p = new jsbn(params.p);\n\t\tvar a = new jsbn(params.a);\n\t\tvar b = new jsbn(params.b);\n\t\tvar curve = new ec.ECCurveFp(p, a, b);\n\t\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\t\tvar d = new jsbn(mpNormalize(priv));\n\t\tvar pub = G.multiply(d);\n\t\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\n\n\t\tvar parts = [];\n\t\tparts.push({name: 'curve', data: Buffer.from(curveName)});\n\t\tparts.push({name: 'Q', data: pub});\n\n\t\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\n\t\treturn (key);\n\t}\n\n\tfunction opensshCipherInfo(cipher) {\n\t\tvar inf = {};\n\t\tswitch (cipher) {\n\t\tcase '3des-cbc':\n\t\t\tinf.keySize = 24;\n\t\t\tinf.blockSize = 8;\n\t\t\tinf.opensslName = 'des-ede3-cbc';\n\t\t\tbreak;\n\t\tcase 'blowfish-cbc':\n\t\t\tinf.keySize = 16;\n\t\t\tinf.blockSize = 8;\n\t\t\tinf.opensslName = 'bf-cbc';\n\t\t\tbreak;\n\t\tcase 'aes128-cbc':\n\t\tcase 'aes128-ctr':\n\t\tcase 'aes128-gcm@openssh.com':\n\t\t\tinf.keySize = 16;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tcase 'aes192-cbc':\n\t\tcase 'aes192-ctr':\n\t\tcase 'aes192-gcm@openssh.com':\n\t\t\tinf.keySize = 24;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tcase 'aes256-cbc':\n\t\tcase 'aes256-ctr':\n\t\tcase 'aes256-gcm@openssh.com':\n\t\t\tinf.keySize = 32;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error(\n\t\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\n\t\t}\n\t\treturn (inf);\n\t}\n\treturn utils;\n}\n\nexport { requireUtils as __require };","start":1667202706698,"end":1667202707555,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport require$$4 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/ecc-jsbn/lib/ec.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/jsbn/index.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/tweetnacl/nacl-fast.js?commonjs-wrapped\";\n\nvar utils;\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\t// Copyright 2015 Joyent, Inc.\n\n\tutils = {\n\t\tbufferSplit: bufferSplit,\n\t\taddRSAMissing: addRSAMissing,\n\t\tcalculateDSAPublic: calculateDSAPublic,\n\t\tcalculateED25519Public: calculateED25519Public,\n\t\tcalculateX25519Public: calculateX25519Public,\n\t\tmpNormalize: mpNormalize,\n\t\tmpDenormalize: mpDenormalize,\n\t\tecNormalize: ecNormalize,\n\t\tcountZeros: countZeros,\n\t\tassertCompatible: assertCompatible,\n\t\tisCompatible: isCompatible,\n\t\topensslKeyDeriv: opensslKeyDeriv,\n\t\topensshCipherInfo: opensshCipherInfo,\n\t\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\n\t\tzeroPadToLength: zeroPadToLength,\n\t\twriteBitString: writeBitString,\n\t\treadBitString: readBitString,\n\t\tpbkdf2: pbkdf2\n\t};\n\n\tvar assert = require$$0();\n\tvar Buffer = require$$1().Buffer;\n\tvar PrivateKey = require$$2();\n\tvar Key = require$$3();\n\tvar crypto = require$$4;\n\tvar algs = require$$5();\n\tvar asn1 = require$$6();\n\n\tvar ec = require$$7();\n\tvar jsbn = require$$8().BigInteger;\n\tvar nacl = require$$9();\n\n\tvar MAX_CLASS_DEPTH = 3;\n\n\tfunction isCompatible(obj, klass, needVer) {\n\t\tif (obj === null || typeof (obj) !== 'object')\n\t\t\treturn (false);\n\t\tif (needVer === undefined)\n\t\t\tneedVer = klass.prototype._sshpkApiVersion;\n\t\tif (obj instanceof klass &&\n\t\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\t\treturn (true);\n\t\tvar proto = Object.getPrototypeOf(obj);\n\t\tvar depth = 0;\n\t\twhile (proto.constructor.name !== klass.name) {\n\t\t\tproto = Object.getPrototypeOf(proto);\n\t\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\n\t\t\t\treturn (false);\n\t\t}\n\t\tif (proto.constructor.name !== klass.name)\n\t\t\treturn (false);\n\t\tvar ver = proto._sshpkApiVersion;\n\t\tif (ver === undefined)\n\t\t\tver = klass._oldVersionDetect(obj);\n\t\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\n\t\t\treturn (false);\n\t\treturn (true);\n\t}\n\n\tfunction assertCompatible(obj, klass, needVer, name) {\n\t\tif (name === undefined)\n\t\t\tname = 'object';\n\t\tassert.ok(obj, name + ' must not be null');\n\t\tassert.object(obj, name + ' must be an object');\n\t\tif (needVer === undefined)\n\t\t\tneedVer = klass.prototype._sshpkApiVersion;\n\t\tif (obj instanceof klass &&\n\t\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\n\t\t\treturn;\n\t\tvar proto = Object.getPrototypeOf(obj);\n\t\tvar depth = 0;\n\t\twhile (proto.constructor.name !== klass.name) {\n\t\t\tproto = Object.getPrototypeOf(proto);\n\t\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\n\t\t\t    name + ' must be a ' + klass.name + ' instance');\n\t\t}\n\t\tassert.strictEqual(proto.constructor.name, klass.name,\n\t\t    name + ' must be a ' + klass.name + ' instance');\n\t\tvar ver = proto._sshpkApiVersion;\n\t\tif (ver === undefined)\n\t\t\tver = klass._oldVersionDetect(obj);\n\t\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\n\t\t    name + ' must be compatible with ' + klass.name + ' klass ' +\n\t\t    'version ' + needVer[0] + '.' + needVer[1]);\n\t}\n\n\tvar CIPHER_LEN = {\n\t\t'des-ede3-cbc': { key: 24, iv: 8 },\n\t\t'aes-128-cbc': { key: 16, iv: 16 },\n\t\t'aes-256-cbc': { key: 32, iv: 16 }\n\t};\n\tvar PKCS5_SALT_LEN = 8;\n\n\tfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\n\t\tassert.buffer(salt, 'salt');\n\t\tassert.buffer(passphrase, 'passphrase');\n\t\tassert.number(count, 'iteration count');\n\n\t\tvar clen = CIPHER_LEN[cipher];\n\t\tassert.object(clen, 'supported cipher');\n\n\t\tsalt = salt.slice(0, PKCS5_SALT_LEN);\n\n\t\tvar D, D_prev, bufs;\n\t\tvar material = Buffer.alloc(0);\n\t\twhile (material.length < clen.key + clen.iv) {\n\t\t\tbufs = [];\n\t\t\tif (D_prev)\n\t\t\t\tbufs.push(D_prev);\n\t\t\tbufs.push(passphrase);\n\t\t\tbufs.push(salt);\n\t\t\tD = Buffer.concat(bufs);\n\t\t\tfor (var j = 0; j < count; ++j)\n\t\t\t\tD = crypto.createHash('md5').update(D).digest();\n\t\t\tmaterial = Buffer.concat([material, D]);\n\t\t\tD_prev = D;\n\t\t}\n\n\t\treturn ({\n\t\t    key: material.slice(0, clen.key),\n\t\t    iv: material.slice(clen.key, clen.key + clen.iv)\n\t\t});\n\t}\n\n\t/* See: RFC2898 */\n\tfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\n\t\tvar hkey = Buffer.alloc(salt.length + 4);\n\t\tsalt.copy(hkey);\n\n\t\tvar gen = 0, ts = [];\n\t\tvar i = 1;\n\t\twhile (gen < size) {\n\t\t\tvar t = T(i++);\n\t\t\tgen += t.length;\n\t\t\tts.push(t);\n\t\t}\n\t\treturn (Buffer.concat(ts).slice(0, size));\n\n\t\tfunction T(I) {\n\t\t\thkey.writeUInt32BE(I, hkey.length - 4);\n\n\t\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\thmac.update(hkey);\n\n\t\t\tvar Ti = hmac.digest();\n\t\t\tvar Uc = Ti;\n\t\t\tvar c = 1;\n\t\t\twhile (c++ < iterations) {\n\t\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\n\t\t\t\thmac.update(Uc);\n\t\t\t\tUc = hmac.digest();\n\t\t\t\tfor (var x = 0; x < Ti.length; ++x)\n\t\t\t\t\tTi[x] ^= Uc[x];\n\t\t\t}\n\t\t\treturn (Ti);\n\t\t}\n\t}\n\n\t/* Count leading zero bits on a buffer */\n\tfunction countZeros(buf) {\n\t\tvar o = 0, obit = 8;\n\t\twhile (o < buf.length) {\n\t\t\tvar mask = (1 << obit);\n\t\t\tif ((buf[o] & mask) === mask)\n\t\t\t\tbreak;\n\t\t\tobit--;\n\t\t\tif (obit < 0) {\n\t\t\t\to++;\n\t\t\t\tobit = 8;\n\t\t\t}\n\t\t}\n\t\treturn (o*8 + (8 - obit) - 1);\n\t}\n\n\tfunction bufferSplit(buf, chr) {\n\t\tassert.buffer(buf);\n\t\tassert.string(chr);\n\n\t\tvar parts = [];\n\t\tvar lastPart = 0;\n\t\tvar matches = 0;\n\t\tfor (var i = 0; i < buf.length; ++i) {\n\t\t\tif (buf[i] === chr.charCodeAt(matches))\n\t\t\t\t++matches;\n\t\t\telse if (buf[i] === chr.charCodeAt(0))\n\t\t\t\tmatches = 1;\n\t\t\telse\n\t\t\t\tmatches = 0;\n\n\t\t\tif (matches >= chr.length) {\n\t\t\t\tvar newPart = i + 1;\n\t\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\n\t\t\t\tlastPart = newPart;\n\t\t\t\tmatches = 0;\n\t\t\t}\n\t\t}\n\t\tif (lastPart <= buf.length)\n\t\t\tparts.push(buf.slice(lastPart, buf.length));\n\n\t\treturn (parts);\n\t}\n\n\tfunction ecNormalize(buf, addZero) {\n\t\tassert.buffer(buf);\n\t\tif (buf[0] === 0x00 && buf[1] === 0x04) {\n\t\t\tif (addZero)\n\t\t\t\treturn (buf);\n\t\t\treturn (buf.slice(1));\n\t\t} else if (buf[0] === 0x04) {\n\t\t\tif (!addZero)\n\t\t\t\treturn (buf);\n\t\t} else {\n\t\t\twhile (buf[0] === 0x00)\n\t\t\t\tbuf = buf.slice(1);\n\t\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\n\t\t\t\tthrow (new Error('Compressed elliptic curve points ' +\n\t\t\t\t    'are not supported'));\n\t\t\tif (buf[0] !== 0x04)\n\t\t\t\tthrow (new Error('Not a valid elliptic curve point'));\n\t\t\tif (!addZero)\n\t\t\t\treturn (buf);\n\t\t}\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x0;\n\t\tbuf.copy(b, 1);\n\t\treturn (b);\n\t}\n\n\tfunction readBitString(der, tag) {\n\t\tif (tag === undefined)\n\t\t\ttag = asn1.Ber.BitString;\n\t\tvar buf = der.readString(tag, true);\n\t\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\n\t\t    'not supported (0x' + buf[0].toString(16) + ')');\n\t\treturn (buf.slice(1));\n\t}\n\n\tfunction writeBitString(der, buf, tag) {\n\t\tif (tag === undefined)\n\t\t\ttag = asn1.Ber.BitString;\n\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\tb[0] = 0x00;\n\t\tbuf.copy(b, 1);\n\t\tder.writeBuffer(b, tag);\n\t}\n\n\tfunction mpNormalize(buf) {\n\t\tassert.buffer(buf);\n\t\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\tif ((buf[0] & 0x80) === 0x80) {\n\t\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\t\tb[0] = 0x00;\n\t\t\tbuf.copy(b, 1);\n\t\t\tbuf = b;\n\t\t}\n\t\treturn (buf);\n\t}\n\n\tfunction mpDenormalize(buf) {\n\t\tassert.buffer(buf);\n\t\twhile (buf.length > 1 && buf[0] === 0x00)\n\t\t\tbuf = buf.slice(1);\n\t\treturn (buf);\n\t}\n\n\tfunction zeroPadToLength(buf, len) {\n\t\tassert.buffer(buf);\n\t\tassert.number(len);\n\t\twhile (buf.length > len) {\n\t\t\tassert.equal(buf[0], 0x00);\n\t\t\tbuf = buf.slice(1);\n\t\t}\n\t\twhile (buf.length < len) {\n\t\t\tvar b = Buffer.alloc(buf.length + 1);\n\t\t\tb[0] = 0x00;\n\t\t\tbuf.copy(b, 1);\n\t\t\tbuf = b;\n\t\t}\n\t\treturn (buf);\n\t}\n\n\tfunction bigintToMpBuf(bigint) {\n\t\tvar buf = Buffer.from(bigint.toByteArray());\n\t\tbuf = mpNormalize(buf);\n\t\treturn (buf);\n\t}\n\n\tfunction calculateDSAPublic(g, p, x) {\n\t\tassert.buffer(g);\n\t\tassert.buffer(p);\n\t\tassert.buffer(x);\n\t\tg = new jsbn(g);\n\t\tp = new jsbn(p);\n\t\tx = new jsbn(x);\n\t\tvar y = g.modPow(x, p);\n\t\tvar ybuf = bigintToMpBuf(y);\n\t\treturn (ybuf);\n\t}\n\n\tfunction calculateED25519Public(k) {\n\t\tassert.buffer(k);\n\n\t\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\n\t\treturn (Buffer.from(kp.publicKey));\n\t}\n\n\tfunction calculateX25519Public(k) {\n\t\tassert.buffer(k);\n\n\t\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\n\t\treturn (Buffer.from(kp.publicKey));\n\t}\n\n\tfunction addRSAMissing(key) {\n\t\tassert.object(key);\n\t\tassertCompatible(key, PrivateKey, [1, 1]);\n\n\t\tvar d = new jsbn(key.part.d.data);\n\t\tvar buf;\n\n\t\tif (!key.part.dmodp) {\n\t\t\tvar p = new jsbn(key.part.p.data);\n\t\t\tvar dmodp = d.mod(p.subtract(1));\n\n\t\t\tbuf = bigintToMpBuf(dmodp);\n\t\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\n\t\t\tkey.parts.push(key.part.dmodp);\n\t\t}\n\t\tif (!key.part.dmodq) {\n\t\t\tvar q = new jsbn(key.part.q.data);\n\t\t\tvar dmodq = d.mod(q.subtract(1));\n\n\t\t\tbuf = bigintToMpBuf(dmodq);\n\t\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\n\t\t\tkey.parts.push(key.part.dmodq);\n\t\t}\n\t}\n\n\tfunction publicFromPrivateECDSA(curveName, priv) {\n\t\tassert.string(curveName, 'curveName');\n\t\tassert.buffer(priv);\n\t\tvar params = algs.curves[curveName];\n\t\tvar p = new jsbn(params.p);\n\t\tvar a = new jsbn(params.a);\n\t\tvar b = new jsbn(params.b);\n\t\tvar curve = new ec.ECCurveFp(p, a, b);\n\t\tvar G = curve.decodePointHex(params.G.toString('hex'));\n\n\t\tvar d = new jsbn(mpNormalize(priv));\n\t\tvar pub = G.multiply(d);\n\t\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\n\n\t\tvar parts = [];\n\t\tparts.push({name: 'curve', data: Buffer.from(curveName)});\n\t\tparts.push({name: 'Q', data: pub});\n\n\t\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\n\t\treturn (key);\n\t}\n\n\tfunction opensshCipherInfo(cipher) {\n\t\tvar inf = {};\n\t\tswitch (cipher) {\n\t\tcase '3des-cbc':\n\t\t\tinf.keySize = 24;\n\t\t\tinf.blockSize = 8;\n\t\t\tinf.opensslName = 'des-ede3-cbc';\n\t\t\tbreak;\n\t\tcase 'blowfish-cbc':\n\t\t\tinf.keySize = 16;\n\t\t\tinf.blockSize = 8;\n\t\t\tinf.opensslName = 'bf-cbc';\n\t\t\tbreak;\n\t\tcase 'aes128-cbc':\n\t\tcase 'aes128-ctr':\n\t\tcase 'aes128-gcm@openssh.com':\n\t\t\tinf.keySize = 16;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tcase 'aes192-cbc':\n\t\tcase 'aes192-ctr':\n\t\tcase 'aes192-gcm@openssh.com':\n\t\t\tinf.keySize = 24;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tcase 'aes256-cbc':\n\t\tcase 'aes256-ctr':\n\t\tcase 'aes256-gcm@openssh.com':\n\t\t\tinf.keySize = 32;\n\t\t\tinf.blockSize = 16;\n\t\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow (new Error(\n\t\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\n\t\t}\n\t\treturn (inf);\n\t}\n\treturn utils;\n}\n\nexport { requireUtils as __require };","start":1667202707562,"end":1667202707594,"order":"normal"}]}
