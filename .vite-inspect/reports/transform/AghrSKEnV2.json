{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/openssh-cert.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2017 Joyent, Inc.\n\nmodule.exports = {\n\tread: read,\n\tverify: verify,\n\tsign: sign,\n\tsignAsync: signAsync,\n\twrite: write,\n\n\t/* Internal private API */\n\tfromBuffer: fromBuffer,\n\ttoBuffer: toBuffer\n};\n\nvar assert = require('assert-plus');\nvar SSHBuffer = require('../ssh-buffer');\nvar crypto = require('crypto');\nvar Buffer = require('safer-buffer').Buffer;\nvar algs = require('../algs');\nvar Key = require('../key');\nvar PrivateKey = require('../private-key');\nvar Identity = require('../identity');\nvar rfc4253 = require('./rfc4253');\nvar Signature = require('../signature');\nvar utils = require('../utils');\nvar Certificate = require('../certificate');\n\nfunction verify(cert, key) {\n\t/*\n\t * We always give an issuerKey, so if our verify() is being called then\n\t * there was no signature. Return false.\n\t */\n\treturn (false);\n}\n\nvar TYPES = {\n\t'user': 1,\n\t'host': 2\n};\nObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\n\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\n\nfunction read(buf, options) {\n\tif (Buffer.isBuffer(buf))\n\t\tbuf = buf.toString('ascii');\n\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\n\tif (parts.length < 2 || parts.length > 3)\n\t\tthrow (new Error('Not a valid SSH certificate line'));\n\n\tvar algo = parts[0];\n\tvar data = parts[1];\n\n\tdata = Buffer.from(data, 'base64');\n\treturn (fromBuffer(data, algo));\n}\n\nfunction fromBuffer(data, algo, partial) {\n\tvar sshbuf = new SSHBuffer({ buffer: data });\n\tvar innerAlgo = sshbuf.readString();\n\tif (algo !== undefined && innerAlgo !== algo)\n\t\tthrow (new Error('SSH certificate algorithm mismatch'));\n\tif (algo === undefined)\n\t\talgo = innerAlgo;\n\n\tvar cert = {};\n\tcert.signatures = {};\n\tcert.signatures.openssh = {};\n\n\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\n\n\tvar key = {};\n\tvar parts = (key.parts = []);\n\tkey.type = getAlg(algo);\n\n\tvar partCount = algs.info[key.type].parts.length;\n\twhile (parts.length < partCount)\n\t\tparts.push(sshbuf.readPart());\n\tassert.ok(parts.length >= 1, 'key must have at least one part');\n\n\tvar algInfo = algs.info[key.type];\n\tif (key.type === 'ecdsa') {\n\t\tvar res = ECDSA_ALGO.exec(algo);\n\t\tassert.ok(res !== null);\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t}\n\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\tparts[i].name = algInfo.parts[i];\n\t\tif (parts[i].name !== 'curve' &&\n\t\t    algInfo.normalize !== false) {\n\t\t\tvar p = parts[i];\n\t\t\tp.data = utils.mpNormalize(p.data);\n\t\t}\n\t}\n\n\tcert.subjectKey = new Key(key);\n\n\tcert.serial = sshbuf.readInt64();\n\n\tvar type = TYPES[sshbuf.readInt()];\n\tassert.string(type, 'valid cert type');\n\n\tcert.signatures.openssh.keyId = sshbuf.readString();\n\n\tvar principals = [];\n\tvar pbuf = sshbuf.readBuffer();\n\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\n\twhile (!psshbuf.atEnd())\n\t\tprincipals.push(psshbuf.readString());\n\tif (principals.length === 0)\n\t\tprincipals = ['*'];\n\n\tcert.subjects = principals.map(function (pr) {\n\t\tif (type === 'user')\n\t\t\treturn (Identity.forUser(pr));\n\t\telse if (type === 'host')\n\t\t\treturn (Identity.forHost(pr));\n\t\tthrow (new Error('Unknown identity type ' + type));\n\t});\n\n\tcert.validFrom = int64ToDate(sshbuf.readInt64());\n\tcert.validUntil = int64ToDate(sshbuf.readInt64());\n\n\tvar exts = [];\n\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\tvar ext;\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: true };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\twhile (!extbuf.atEnd()) {\n\t\text = { critical: false };\n\t\text.name = extbuf.readString();\n\t\text.data = extbuf.readBuffer();\n\t\texts.push(ext);\n\t}\n\tcert.signatures.openssh.exts = exts;\n\n\t/* reserved */\n\tsshbuf.readBuffer();\n\n\tvar signingKeyBuf = sshbuf.readBuffer();\n\tcert.issuerKey = rfc4253.read(signingKeyBuf);\n\n\t/*\n\t * OpenSSH certs don't give the identity of the issuer, just their\n\t * public key. So, we use an Identity that matches anything. The\n\t * isSignedBy() function will later tell you if the key matches.\n\t */\n\tcert.issuer = Identity.forHost('**');\n\n\tvar sigBuf = sshbuf.readBuffer();\n\tcert.signatures.openssh.signature =\n\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n\n\tif (partial !== undefined) {\n\t\tpartial.remainder = sshbuf.remainder();\n\t\tpartial.consumed = sshbuf._offset;\n\t}\n\n\treturn (new Certificate(cert));\n}\n\nfunction int64ToDate(buf) {\n\tvar i = buf.readUInt32BE(0) * 4294967296;\n\ti += buf.readUInt32BE(4);\n\tvar d = new Date();\n\td.setTime(i * 1000);\n\td.sourceInt64 = buf;\n\treturn (d);\n}\n\nfunction dateToInt64(date) {\n\tif (date.sourceInt64 !== undefined)\n\t\treturn (date.sourceInt64);\n\tvar i = Math.round(date.getTime() / 1000);\n\tvar upper = Math.floor(i / 4294967296);\n\tvar lower = Math.floor(i % 4294967296);\n\tvar buf = Buffer.alloc(8);\n\tbuf.writeUInt32BE(upper, 0);\n\tbuf.writeUInt32BE(lower, 4);\n\treturn (buf);\n}\n\nfunction sign(cert, key) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\treturn (false);\n\t}\n\tvar sig = cert.signatures.openssh;\n\tvar hashAlgo = undefined;\n\tif (key.type === 'rsa' || key.type === 'dsa')\n\t\thashAlgo = 'sha1';\n\tvar signer = key.createSign(hashAlgo);\n\tsigner.write(blob);\n\tsig.signature = signer.sign();\n\treturn (true);\n}\n\nfunction signAsync(cert, signer, done) {\n\tif (cert.signatures.openssh === undefined)\n\t\tcert.signatures.openssh = {};\n\ttry {\n\t\tvar blob = toBuffer(cert, true);\n\t} catch (e) {\n\t\tdelete (cert.signatures.openssh);\n\t\tdone(e);\n\t\treturn;\n\t}\n\tvar sig = cert.signatures.openssh;\n\n\tsigner(blob, function (err, signature) {\n\t\tif (err) {\n\t\t\tdone(err);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t/*\n\t\t\t * This will throw if the signature isn't of a\n\t\t\t * type/algo that can be used for SSH.\n\t\t\t */\n\t\t\tsignature.toBuffer('ssh');\n\t\t} catch (e) {\n\t\t\tdone(e);\n\t\t\treturn;\n\t\t}\n\t\tsig.signature = signature;\n\t\tdone();\n\t});\n}\n\nfunction write(cert, options) {\n\tif (options === undefined)\n\t\toptions = {};\n\n\tvar blob = toBuffer(cert);\n\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n\tif (options.comment)\n\t\tout = out + ' ' + options.comment;\n\treturn (out);\n}\n\n\nfunction toBuffer(cert, noSig) {\n\tassert.object(cert.signatures.openssh, 'signature for openssh format');\n\tvar sig = cert.signatures.openssh;\n\n\tif (sig.nonce === undefined)\n\t\tsig.nonce = crypto.randomBytes(16);\n\tvar buf = new SSHBuffer({});\n\tbuf.writeString(getCertType(cert.subjectKey));\n\tbuf.writeBuffer(sig.nonce);\n\n\tvar key = cert.subjectKey;\n\tvar algInfo = algs.info[key.type];\n\talgInfo.parts.forEach(function (part) {\n\t\tbuf.writePart(key.part[part]);\n\t});\n\n\tbuf.writeInt64(cert.serial);\n\n\tvar type = cert.subjects[0].type;\n\tassert.notStrictEqual(type, 'unknown');\n\tcert.subjects.forEach(function (id) {\n\t\tassert.strictEqual(id.type, type);\n\t});\n\ttype = TYPES[type];\n\tbuf.writeInt(type);\n\n\tif (sig.keyId === undefined) {\n\t\tsig.keyId = cert.subjects[0].type + '_' +\n\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\n\t}\n\tbuf.writeString(sig.keyId);\n\n\tvar sub = new SSHBuffer({});\n\tcert.subjects.forEach(function (id) {\n\t\tif (type === TYPES.host)\n\t\t\tsub.writeString(id.hostname);\n\t\telse if (type === TYPES.user)\n\t\t\tsub.writeString(id.uid);\n\t});\n\tbuf.writeBuffer(sub.toBuffer());\n\n\tbuf.writeInt64(dateToInt64(cert.validFrom));\n\tbuf.writeInt64(dateToInt64(cert.validUntil));\n\n\tvar exts = sig.exts;\n\tif (exts === undefined)\n\t\texts = [];\n\n\tvar extbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical !== true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\textbuf = new SSHBuffer({});\n\texts.forEach(function (ext) {\n\t\tif (ext.critical === true)\n\t\t\treturn;\n\t\textbuf.writeString(ext.name);\n\t\textbuf.writeBuffer(ext.data);\n\t});\n\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t/* reserved */\n\tbuf.writeBuffer(Buffer.alloc(0));\n\n\tsub = rfc4253.write(cert.issuerKey);\n\tbuf.writeBuffer(sub);\n\n\tif (!noSig)\n\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\n\n\treturn (buf.toBuffer());\n}\n\nfunction getAlg(certType) {\n\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\n\t\treturn ('rsa');\n\tif (certType === 'ssh-dss-cert-v01@openssh.com')\n\t\treturn ('dsa');\n\tif (certType.match(ECDSA_ALGO))\n\t\treturn ('ecdsa');\n\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\n\t\treturn ('ed25519');\n\tthrow (new Error('Unsupported cert type ' + certType));\n}\n\nfunction getCertType(key) {\n\tif (key.type === 'rsa')\n\t\treturn ('ssh-rsa-cert-v01@openssh.com');\n\tif (key.type === 'dsa')\n\t\treturn ('ssh-dss-cert-v01@openssh.com');\n\tif (key.type === 'ecdsa')\n\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\n\tif (key.type === 'ed25519')\n\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\n\tthrow (new Error('Unsupported key type ' + key.type));\n}\n","start":1667202983873,"end":1667202984161},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/assert-plus/assert.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/ssh-buffer.js?commonjs-wrapped\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/algs.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/key.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/private-key.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/identity.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/formats/rfc4253.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/signature.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/utils.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/sshpk/lib/certificate.js?commonjs-wrapped\";\n\nvar opensshCert;\nvar hasRequiredOpensshCert;\n\nfunction requireOpensshCert () {\n\tif (hasRequiredOpensshCert) return opensshCert;\n\thasRequiredOpensshCert = 1;\n\t// Copyright 2017 Joyent, Inc.\n\n\topensshCert = {\n\t\tread: read,\n\t\tverify: verify,\n\t\tsign: sign,\n\t\tsignAsync: signAsync,\n\t\twrite: write,\n\n\t\t/* Internal private API */\n\t\tfromBuffer: fromBuffer,\n\t\ttoBuffer: toBuffer\n\t};\n\n\tvar assert = require$$0();\n\tvar SSHBuffer = require$$1();\n\tvar crypto = require$$2;\n\tvar Buffer = require$$3().Buffer;\n\tvar algs = require$$4();\n\tvar Key = require$$5();\n\tvar PrivateKey = require$$6();\n\tvar Identity = require$$7();\n\tvar rfc4253 = require$$8();\n\tvar Signature = require$$9();\n\tvar utils = require$$10();\n\tvar Certificate = require$$11();\n\n\tfunction verify(cert, key) {\n\t\t/*\n\t\t * We always give an issuerKey, so if our verify() is being called then\n\t\t * there was no signature. Return false.\n\t\t */\n\t\treturn (false);\n\t}\n\n\tvar TYPES = {\n\t\t'user': 1,\n\t\t'host': 2\n\t};\n\tObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\n\n\tvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\n\n\tfunction read(buf, options) {\n\t\tif (Buffer.isBuffer(buf))\n\t\t\tbuf = buf.toString('ascii');\n\t\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\n\t\tif (parts.length < 2 || parts.length > 3)\n\t\t\tthrow (new Error('Not a valid SSH certificate line'));\n\n\t\tvar algo = parts[0];\n\t\tvar data = parts[1];\n\n\t\tdata = Buffer.from(data, 'base64');\n\t\treturn (fromBuffer(data, algo));\n\t}\n\n\tfunction fromBuffer(data, algo, partial) {\n\t\tvar sshbuf = new SSHBuffer({ buffer: data });\n\t\tvar innerAlgo = sshbuf.readString();\n\t\tif (algo !== undefined && innerAlgo !== algo)\n\t\t\tthrow (new Error('SSH certificate algorithm mismatch'));\n\t\tif (algo === undefined)\n\t\t\talgo = innerAlgo;\n\n\t\tvar cert = {};\n\t\tcert.signatures = {};\n\t\tcert.signatures.openssh = {};\n\n\t\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\n\n\t\tvar key = {};\n\t\tvar parts = (key.parts = []);\n\t\tkey.type = getAlg(algo);\n\n\t\tvar partCount = algs.info[key.type].parts.length;\n\t\twhile (parts.length < partCount)\n\t\t\tparts.push(sshbuf.readPart());\n\t\tassert.ok(parts.length >= 1, 'key must have at least one part');\n\n\t\tvar algInfo = algs.info[key.type];\n\t\tif (key.type === 'ecdsa') {\n\t\t\tvar res = ECDSA_ALGO.exec(algo);\n\t\t\tassert.ok(res !== null);\n\t\t\tassert.strictEqual(res[1], parts[0].data.toString());\n\t\t}\n\n\t\tfor (var i = 0; i < algInfo.parts.length; ++i) {\n\t\t\tparts[i].name = algInfo.parts[i];\n\t\t\tif (parts[i].name !== 'curve' &&\n\t\t\t    algInfo.normalize !== false) {\n\t\t\t\tvar p = parts[i];\n\t\t\t\tp.data = utils.mpNormalize(p.data);\n\t\t\t}\n\t\t}\n\n\t\tcert.subjectKey = new Key(key);\n\n\t\tcert.serial = sshbuf.readInt64();\n\n\t\tvar type = TYPES[sshbuf.readInt()];\n\t\tassert.string(type, 'valid cert type');\n\n\t\tcert.signatures.openssh.keyId = sshbuf.readString();\n\n\t\tvar principals = [];\n\t\tvar pbuf = sshbuf.readBuffer();\n\t\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\n\t\twhile (!psshbuf.atEnd())\n\t\t\tprincipals.push(psshbuf.readString());\n\t\tif (principals.length === 0)\n\t\t\tprincipals = ['*'];\n\n\t\tcert.subjects = principals.map(function (pr) {\n\t\t\tif (type === 'user')\n\t\t\t\treturn (Identity.forUser(pr));\n\t\t\telse if (type === 'host')\n\t\t\t\treturn (Identity.forHost(pr));\n\t\t\tthrow (new Error('Unknown identity type ' + type));\n\t\t});\n\n\t\tcert.validFrom = int64ToDate(sshbuf.readInt64());\n\t\tcert.validUntil = int64ToDate(sshbuf.readInt64());\n\n\t\tvar exts = [];\n\t\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\t\tvar ext;\n\t\twhile (!extbuf.atEnd()) {\n\t\t\text = { critical: true };\n\t\t\text.name = extbuf.readString();\n\t\t\text.data = extbuf.readBuffer();\n\t\t\texts.push(ext);\n\t\t}\n\t\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\n\t\twhile (!extbuf.atEnd()) {\n\t\t\text = { critical: false };\n\t\t\text.name = extbuf.readString();\n\t\t\text.data = extbuf.readBuffer();\n\t\t\texts.push(ext);\n\t\t}\n\t\tcert.signatures.openssh.exts = exts;\n\n\t\t/* reserved */\n\t\tsshbuf.readBuffer();\n\n\t\tvar signingKeyBuf = sshbuf.readBuffer();\n\t\tcert.issuerKey = rfc4253.read(signingKeyBuf);\n\n\t\t/*\n\t\t * OpenSSH certs don't give the identity of the issuer, just their\n\t\t * public key. So, we use an Identity that matches anything. The\n\t\t * isSignedBy() function will later tell you if the key matches.\n\t\t */\n\t\tcert.issuer = Identity.forHost('**');\n\n\t\tvar sigBuf = sshbuf.readBuffer();\n\t\tcert.signatures.openssh.signature =\n\t\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\n\n\t\tif (partial !== undefined) {\n\t\t\tpartial.remainder = sshbuf.remainder();\n\t\t\tpartial.consumed = sshbuf._offset;\n\t\t}\n\n\t\treturn (new Certificate(cert));\n\t}\n\n\tfunction int64ToDate(buf) {\n\t\tvar i = buf.readUInt32BE(0) * 4294967296;\n\t\ti += buf.readUInt32BE(4);\n\t\tvar d = new Date();\n\t\td.setTime(i * 1000);\n\t\td.sourceInt64 = buf;\n\t\treturn (d);\n\t}\n\n\tfunction dateToInt64(date) {\n\t\tif (date.sourceInt64 !== undefined)\n\t\t\treturn (date.sourceInt64);\n\t\tvar i = Math.round(date.getTime() / 1000);\n\t\tvar upper = Math.floor(i / 4294967296);\n\t\tvar lower = Math.floor(i % 4294967296);\n\t\tvar buf = Buffer.alloc(8);\n\t\tbuf.writeUInt32BE(upper, 0);\n\t\tbuf.writeUInt32BE(lower, 4);\n\t\treturn (buf);\n\t}\n\n\tfunction sign(cert, key) {\n\t\tif (cert.signatures.openssh === undefined)\n\t\t\tcert.signatures.openssh = {};\n\t\ttry {\n\t\t\tvar blob = toBuffer(cert, true);\n\t\t} catch (e) {\n\t\t\tdelete (cert.signatures.openssh);\n\t\t\treturn (false);\n\t\t}\n\t\tvar sig = cert.signatures.openssh;\n\t\tvar hashAlgo = undefined;\n\t\tif (key.type === 'rsa' || key.type === 'dsa')\n\t\t\thashAlgo = 'sha1';\n\t\tvar signer = key.createSign(hashAlgo);\n\t\tsigner.write(blob);\n\t\tsig.signature = signer.sign();\n\t\treturn (true);\n\t}\n\n\tfunction signAsync(cert, signer, done) {\n\t\tif (cert.signatures.openssh === undefined)\n\t\t\tcert.signatures.openssh = {};\n\t\ttry {\n\t\t\tvar blob = toBuffer(cert, true);\n\t\t} catch (e) {\n\t\t\tdelete (cert.signatures.openssh);\n\t\t\tdone(e);\n\t\t\treturn;\n\t\t}\n\t\tvar sig = cert.signatures.openssh;\n\n\t\tsigner(blob, function (err, signature) {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t/*\n\t\t\t\t * This will throw if the signature isn't of a\n\t\t\t\t * type/algo that can be used for SSH.\n\t\t\t\t */\n\t\t\t\tsignature.toBuffer('ssh');\n\t\t\t} catch (e) {\n\t\t\t\tdone(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsig.signature = signature;\n\t\t\tdone();\n\t\t});\n\t}\n\n\tfunction write(cert, options) {\n\t\tif (options === undefined)\n\t\t\toptions = {};\n\n\t\tvar blob = toBuffer(cert);\n\t\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\n\t\tif (options.comment)\n\t\t\tout = out + ' ' + options.comment;\n\t\treturn (out);\n\t}\n\n\n\tfunction toBuffer(cert, noSig) {\n\t\tassert.object(cert.signatures.openssh, 'signature for openssh format');\n\t\tvar sig = cert.signatures.openssh;\n\n\t\tif (sig.nonce === undefined)\n\t\t\tsig.nonce = crypto.randomBytes(16);\n\t\tvar buf = new SSHBuffer({});\n\t\tbuf.writeString(getCertType(cert.subjectKey));\n\t\tbuf.writeBuffer(sig.nonce);\n\n\t\tvar key = cert.subjectKey;\n\t\tvar algInfo = algs.info[key.type];\n\t\talgInfo.parts.forEach(function (part) {\n\t\t\tbuf.writePart(key.part[part]);\n\t\t});\n\n\t\tbuf.writeInt64(cert.serial);\n\n\t\tvar type = cert.subjects[0].type;\n\t\tassert.notStrictEqual(type, 'unknown');\n\t\tcert.subjects.forEach(function (id) {\n\t\t\tassert.strictEqual(id.type, type);\n\t\t});\n\t\ttype = TYPES[type];\n\t\tbuf.writeInt(type);\n\n\t\tif (sig.keyId === undefined) {\n\t\t\tsig.keyId = cert.subjects[0].type + '_' +\n\t\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\n\t\t}\n\t\tbuf.writeString(sig.keyId);\n\n\t\tvar sub = new SSHBuffer({});\n\t\tcert.subjects.forEach(function (id) {\n\t\t\tif (type === TYPES.host)\n\t\t\t\tsub.writeString(id.hostname);\n\t\t\telse if (type === TYPES.user)\n\t\t\t\tsub.writeString(id.uid);\n\t\t});\n\t\tbuf.writeBuffer(sub.toBuffer());\n\n\t\tbuf.writeInt64(dateToInt64(cert.validFrom));\n\t\tbuf.writeInt64(dateToInt64(cert.validUntil));\n\n\t\tvar exts = sig.exts;\n\t\tif (exts === undefined)\n\t\t\texts = [];\n\n\t\tvar extbuf = new SSHBuffer({});\n\t\texts.forEach(function (ext) {\n\t\t\tif (ext.critical !== true)\n\t\t\t\treturn;\n\t\t\textbuf.writeString(ext.name);\n\t\t\textbuf.writeBuffer(ext.data);\n\t\t});\n\t\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t\textbuf = new SSHBuffer({});\n\t\texts.forEach(function (ext) {\n\t\t\tif (ext.critical === true)\n\t\t\t\treturn;\n\t\t\textbuf.writeString(ext.name);\n\t\t\textbuf.writeBuffer(ext.data);\n\t\t});\n\t\tbuf.writeBuffer(extbuf.toBuffer());\n\n\t\t/* reserved */\n\t\tbuf.writeBuffer(Buffer.alloc(0));\n\n\t\tsub = rfc4253.write(cert.issuerKey);\n\t\tbuf.writeBuffer(sub);\n\n\t\tif (!noSig)\n\t\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\n\n\t\treturn (buf.toBuffer());\n\t}\n\n\tfunction getAlg(certType) {\n\t\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\n\t\t\treturn ('rsa');\n\t\tif (certType === 'ssh-dss-cert-v01@openssh.com')\n\t\t\treturn ('dsa');\n\t\tif (certType.match(ECDSA_ALGO))\n\t\t\treturn ('ecdsa');\n\t\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\n\t\t\treturn ('ed25519');\n\t\tthrow (new Error('Unsupported cert type ' + certType));\n\t}\n\n\tfunction getCertType(key) {\n\t\tif (key.type === 'rsa')\n\t\t\treturn ('ssh-rsa-cert-v01@openssh.com');\n\t\tif (key.type === 'dsa')\n\t\t\treturn ('ssh-dss-cert-v01@openssh.com');\n\t\tif (key.type === 'ecdsa')\n\t\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\n\t\tif (key.type === 'ed25519')\n\t\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\n\t\tthrow (new Error('Unsupported key type ' + key.type));\n\t}\n\treturn opensshCert;\n}\n\nexport { requireOpensshCert as __require };","start":1667202984161,"end":1667202984904,"order":"normal"}]}
