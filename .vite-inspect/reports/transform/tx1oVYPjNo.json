{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/ber/writer.js","transforms":[{"name":"vite:load-fallback","result":"// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n","start":1667202984646,"end":1667202984950},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$1 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safer-buffer/safer.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/ber/types.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/asn1/lib/ber/errors.js?commonjs-wrapped\";\n\nvar writer;\nvar hasRequiredWriter;\n\nfunction requireWriter () {\n\tif (hasRequiredWriter) return writer;\n\thasRequiredWriter = 1;\n\t// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\tvar assert = require$$0;\n\tvar Buffer = require$$1().Buffer;\n\tvar ASN1 = require$$2();\n\tvar errors = require$$3();\n\n\n\t// --- Globals\n\n\tvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\tvar DEFAULT_OPTS = {\n\t  size: 1024,\n\t  growthFactor: 8\n\t};\n\n\n\t// --- Helpers\n\n\tfunction merge(from, to) {\n\t  assert.ok(from);\n\t  assert.equal(typeof (from), 'object');\n\t  assert.ok(to);\n\t  assert.equal(typeof (to), 'object');\n\n\t  var keys = Object.getOwnPropertyNames(from);\n\t  keys.forEach(function (key) {\n\t    if (to[key])\n\t      return;\n\n\t    var value = Object.getOwnPropertyDescriptor(from, key);\n\t    Object.defineProperty(to, key, value);\n\t  });\n\n\t  return to;\n\t}\n\n\n\n\t// --- API\n\n\tfunction Writer(options) {\n\t  options = merge(DEFAULT_OPTS, options || {});\n\n\t  this._buf = Buffer.alloc(options.size || 1024);\n\t  this._size = this._buf.length;\n\t  this._offset = 0;\n\t  this._options = options;\n\n\t  // A list of offsets in the buffer where we need to insert\n\t  // sequence tag/len pairs.\n\t  this._seq = [];\n\t}\n\n\tObject.defineProperty(Writer.prototype, 'buffer', {\n\t  get: function () {\n\t    if (this._seq.length)\n\t      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n\t    return (this._buf.slice(0, this._offset));\n\t  }\n\t});\n\n\tWriter.prototype.writeByte = function (b) {\n\t  if (typeof (b) !== 'number')\n\t    throw new TypeError('argument must be a Number');\n\n\t  this._ensure(1);\n\t  this._buf[this._offset++] = b;\n\t};\n\n\n\tWriter.prototype.writeInt = function (i, tag) {\n\t  if (typeof (i) !== 'number')\n\t    throw new TypeError('argument must be a Number');\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.Integer;\n\n\t  var sz = 4;\n\n\t  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n\t        (sz > 1)) {\n\t    sz--;\n\t    i <<= 8;\n\t  }\n\n\t  if (sz > 4)\n\t    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n\t  this._ensure(2 + sz);\n\t  this._buf[this._offset++] = tag;\n\t  this._buf[this._offset++] = sz;\n\n\t  while (sz-- > 0) {\n\t    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n\t    i <<= 8;\n\t  }\n\n\t};\n\n\n\tWriter.prototype.writeNull = function () {\n\t  this.writeByte(ASN1.Null);\n\t  this.writeByte(0x00);\n\t};\n\n\n\tWriter.prototype.writeEnumeration = function (i, tag) {\n\t  if (typeof (i) !== 'number')\n\t    throw new TypeError('argument must be a Number');\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.Enumeration;\n\n\t  return this.writeInt(i, tag);\n\t};\n\n\n\tWriter.prototype.writeBoolean = function (b, tag) {\n\t  if (typeof (b) !== 'boolean')\n\t    throw new TypeError('argument must be a Boolean');\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.Boolean;\n\n\t  this._ensure(3);\n\t  this._buf[this._offset++] = tag;\n\t  this._buf[this._offset++] = 0x01;\n\t  this._buf[this._offset++] = b ? 0xff : 0x00;\n\t};\n\n\n\tWriter.prototype.writeString = function (s, tag) {\n\t  if (typeof (s) !== 'string')\n\t    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.OctetString;\n\n\t  var len = Buffer.byteLength(s);\n\t  this.writeByte(tag);\n\t  this.writeLength(len);\n\t  if (len) {\n\t    this._ensure(len);\n\t    this._buf.write(s, this._offset);\n\t    this._offset += len;\n\t  }\n\t};\n\n\n\tWriter.prototype.writeBuffer = function (buf, tag) {\n\t  if (typeof (tag) !== 'number')\n\t    throw new TypeError('tag must be a number');\n\t  if (!Buffer.isBuffer(buf))\n\t    throw new TypeError('argument must be a buffer');\n\n\t  this.writeByte(tag);\n\t  this.writeLength(buf.length);\n\t  this._ensure(buf.length);\n\t  buf.copy(this._buf, this._offset, 0, buf.length);\n\t  this._offset += buf.length;\n\t};\n\n\n\tWriter.prototype.writeStringArray = function (strings) {\n\t  if ((!strings instanceof Array))\n\t    throw new TypeError('argument must be an Array[String]');\n\n\t  var self = this;\n\t  strings.forEach(function (s) {\n\t    self.writeString(s);\n\t  });\n\t};\n\n\t// This is really to solve DER cases, but whatever for now\n\tWriter.prototype.writeOID = function (s, tag) {\n\t  if (typeof (s) !== 'string')\n\t    throw new TypeError('argument must be a string');\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.OID;\n\n\t  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n\t    throw new Error('argument is not a valid OID string');\n\n\t  function encodeOctet(bytes, octet) {\n\t    if (octet < 128) {\n\t        bytes.push(octet);\n\t    } else if (octet < 16384) {\n\t        bytes.push((octet >>> 7) | 0x80);\n\t        bytes.push(octet & 0x7F);\n\t    } else if (octet < 2097152) {\n\t      bytes.push((octet >>> 14) | 0x80);\n\t      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n\t      bytes.push(octet & 0x7F);\n\t    } else if (octet < 268435456) {\n\t      bytes.push((octet >>> 21) | 0x80);\n\t      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n\t      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n\t      bytes.push(octet & 0x7F);\n\t    } else {\n\t      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n\t      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n\t      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n\t      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n\t      bytes.push(octet & 0x7F);\n\t    }\n\t  }\n\n\t  var tmp = s.split('.');\n\t  var bytes = [];\n\t  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n\t  tmp.slice(2).forEach(function (b) {\n\t    encodeOctet(bytes, parseInt(b, 10));\n\t  });\n\n\t  var self = this;\n\t  this._ensure(2 + bytes.length);\n\t  this.writeByte(tag);\n\t  this.writeLength(bytes.length);\n\t  bytes.forEach(function (b) {\n\t    self.writeByte(b);\n\t  });\n\t};\n\n\n\tWriter.prototype.writeLength = function (len) {\n\t  if (typeof (len) !== 'number')\n\t    throw new TypeError('argument must be a Number');\n\n\t  this._ensure(4);\n\n\t  if (len <= 0x7f) {\n\t    this._buf[this._offset++] = len;\n\t  } else if (len <= 0xff) {\n\t    this._buf[this._offset++] = 0x81;\n\t    this._buf[this._offset++] = len;\n\t  } else if (len <= 0xffff) {\n\t    this._buf[this._offset++] = 0x82;\n\t    this._buf[this._offset++] = len >> 8;\n\t    this._buf[this._offset++] = len;\n\t  } else if (len <= 0xffffff) {\n\t    this._buf[this._offset++] = 0x83;\n\t    this._buf[this._offset++] = len >> 16;\n\t    this._buf[this._offset++] = len >> 8;\n\t    this._buf[this._offset++] = len;\n\t  } else {\n\t    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n\t  }\n\t};\n\n\tWriter.prototype.startSequence = function (tag) {\n\t  if (typeof (tag) !== 'number')\n\t    tag = ASN1.Sequence | ASN1.Constructor;\n\n\t  this.writeByte(tag);\n\t  this._seq.push(this._offset);\n\t  this._ensure(3);\n\t  this._offset += 3;\n\t};\n\n\n\tWriter.prototype.endSequence = function () {\n\t  var seq = this._seq.pop();\n\t  var start = seq + 3;\n\t  var len = this._offset - start;\n\n\t  if (len <= 0x7f) {\n\t    this._shift(start, len, -2);\n\t    this._buf[seq] = len;\n\t  } else if (len <= 0xff) {\n\t    this._shift(start, len, -1);\n\t    this._buf[seq] = 0x81;\n\t    this._buf[seq + 1] = len;\n\t  } else if (len <= 0xffff) {\n\t    this._buf[seq] = 0x82;\n\t    this._buf[seq + 1] = len >> 8;\n\t    this._buf[seq + 2] = len;\n\t  } else if (len <= 0xffffff) {\n\t    this._shift(start, len, 1);\n\t    this._buf[seq] = 0x83;\n\t    this._buf[seq + 1] = len >> 16;\n\t    this._buf[seq + 2] = len >> 8;\n\t    this._buf[seq + 3] = len;\n\t  } else {\n\t    throw newInvalidAsn1Error('Sequence too long');\n\t  }\n\t};\n\n\n\tWriter.prototype._shift = function (start, len, shift) {\n\t  assert.ok(start !== undefined);\n\t  assert.ok(len !== undefined);\n\t  assert.ok(shift);\n\n\t  this._buf.copy(this._buf, start + shift, start, start + len);\n\t  this._offset += shift;\n\t};\n\n\tWriter.prototype._ensure = function (len) {\n\t  assert.ok(len);\n\n\t  if (this._size - this._offset < len) {\n\t    var sz = this._size * this._options.growthFactor;\n\t    if (sz - this._offset < len)\n\t      sz += len;\n\n\t    var buf = Buffer.alloc(sz);\n\n\t    this._buf.copy(buf, 0, 0, this._offset);\n\t    this._buf = buf;\n\t    this._size = sz;\n\t  }\n\t};\n\n\n\n\t// --- Exported API\n\n\twriter = Writer;\n\treturn writer;\n}\n\nexport { requireWriter as __require };","start":1667202984950,"end":1667202984961,"order":"normal"}]}
