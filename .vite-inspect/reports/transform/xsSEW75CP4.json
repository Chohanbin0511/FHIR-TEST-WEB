{"resolvedId":"C:/chohbin/Fhir-Test-Web/node_modules/request/request.js","transforms":[{"name":"vite:load-fallback","result":"'use strict'\n\nvar http = require('http')\nvar https = require('https')\nvar url = require('url')\nvar util = require('util')\nvar stream = require('stream')\nvar zlib = require('zlib')\nvar aws2 = require('aws-sign2')\nvar aws4 = require('aws4')\nvar httpSignature = require('http-signature')\nvar mime = require('mime-types')\nvar caseless = require('caseless')\nvar ForeverAgent = require('forever-agent')\nvar FormData = require('form-data')\nvar extend = require('extend')\nvar isstream = require('isstream')\nvar isTypedArray = require('is-typedarray').strict\nvar helpers = require('./lib/helpers')\nvar cookies = require('./lib/cookies')\nvar getProxyFromURI = require('./lib/getProxyFromURI')\nvar Querystring = require('./lib/querystring').Querystring\nvar Har = require('./lib/har').Har\nvar Auth = require('./lib/auth').Auth\nvar OAuth = require('./lib/oauth').OAuth\nvar hawk = require('./lib/hawk')\nvar Multipart = require('./lib/multipart').Multipart\nvar Redirect = require('./lib/redirect').Redirect\nvar Tunnel = require('./lib/tunnel').Tunnel\nvar now = require('performance-now')\nvar Buffer = require('safe-buffer').Buffer\n\nvar safeStringify = helpers.safeStringify\nvar isReadStream = helpers.isReadStream\nvar toBase64 = helpers.toBase64\nvar defer = helpers.defer\nvar copy = helpers.copy\nvar version = helpers.version\nvar globalCookieJar = cookies.jar()\n\nvar globalPool = {}\n\nfunction filterForNonReserved (reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions (reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON () {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON () {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\nfunction debug () {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.host)\n    // Drop :port suffix from Host header if known protocol.\n    if (self.uri.port) {\n      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n        self.setHeader(hostHeaderName, self.uri.hostname)\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n\n    // NOTE: elapsedTime is deprecated in favor of .timings\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = Buffer.from(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      } else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n      } else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n  var defaultModules = {'http:': http, 'https:': https}\n  var httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n  // self.on('pipe', function () {\n  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n  // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self.timing) {\n    // All timings will be relative to this request's startTime.  In order to do this,\n    // we need to capture the wall-clock start time (via Date), immediately followed\n    // by the high-resolution timer (via now()).  While these two won't be set\n    // at the _exact_ same time, they should be close enough to be able to calculate\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n    var startTime = new Date().getTime()\n    var startTimeNow = now()\n  }\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n  // should delete it for now since we handle timeouts manually for better\n  // consistency with node versions before v6.8.0\n  delete reqOptions.timeout\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = startTime\n    self.startTimeNow = startTimeNow\n\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\n    // so we have an accurate clock)\n    self.timings = {}\n  }\n\n  var timeout\n  if (self.timeout && !self.timeoutTimer) {\n    if (self.timeout < 0) {\n      timeout = 0\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n      timeout = self.timeout\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function () {\n    self.emit('drain')\n  })\n\n  self.req.on('socket', function (socket) {\n    // `._connecting` was the old property which was made public in node v6.1.0\n    var isConnecting = socket._connecting || socket.connecting\n    if (self.timing) {\n      self.timings.socket = now() - self.startTimeNow\n\n      if (isConnecting) {\n        var onLookupTiming = function () {\n          self.timings.lookup = now() - self.startTimeNow\n        }\n\n        var onConnectTiming = function () {\n          self.timings.connect = now() - self.startTimeNow\n        }\n\n        socket.once('lookup', onLookupTiming)\n        socket.once('connect', onConnectTiming)\n\n        // clean up timing event listeners if needed on error\n        self.req.once('error', function () {\n          socket.removeListener('lookup', onLookupTiming)\n          socket.removeListener('connect', onConnectTiming)\n        })\n      }\n    }\n\n    var setReqTimeout = function () {\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server once connected.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n    if (timeout !== undefined) {\n      // Only start the connection timer if we're actually connecting a new\n      // socket, otherwise if we're already connected (because this is a\n      // keep-alive connection) do not bother. This is important since we won't\n      // get a 'connect' event for an already connected socket.\n      if (isConnecting) {\n        var onReqSockConnect = function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.clearTimeout()\n          setReqTimeout()\n        }\n\n        socket.on('connect', onReqSockConnect)\n\n        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n          socket.removeListener('connect', onReqSockConnect)\n        })\n\n        // Set a timeout in memory - this block will throw if the server takes more\n        // than `timeout` to write the HTTP status and headers (corresponding to\n        // the on('response') event on the client). NB: this measures wall-clock\n        // time, not the time between bytes sent by the server.\n        self.timeoutTimer = setTimeout(function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.abort()\n          var e = new Error('ETIMEDOUT')\n          e.code = 'ETIMEDOUT'\n          e.connect = true\n          self.emit('error', e)\n        }, timeout)\n      } else {\n        // We're already connected\n        setReqTimeout()\n      }\n    }\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n    self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  self.clearTimeout()\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n\n  if (self.timing) {\n    self.timings.response = now() - self.startTimeNow\n  }\n\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function () {\n    if (self.timing) {\n      self.timings.end = now() - self.startTimeNow\n      response.timingStart = self.startTime\n\n      // fill in the blanks for any periods that didn't trigger, such as\n      // no lookup or connect due to keep alive\n      if (!self.timings.socket) {\n        self.timings.socket = 0\n      }\n      if (!self.timings.lookup) {\n        self.timings.lookup = self.timings.socket\n      }\n      if (!self.timings.connect) {\n        self.timings.connect = self.timings.lookup\n      }\n      if (!self.timings.response) {\n        self.timings.response = self.timings.connect\n      }\n\n      debug('elapsed time', self.timings.end)\n\n      // elapsedTime includes all redirects\n      self.elapsedTime += Math.round(self.timings.end)\n\n      // NOTE: elapsedTime is deprecated in favor of .timings\n      response.elapsedTime = self.elapsedTime\n\n      // timings is just for the final fetch\n      response.timings = self.timings\n\n      // pre-calculate phase timings as well\n      response.timingPhases = {\n        wait: self.timings.socket,\n        dns: self.timings.lookup - self.timings.socket,\n        tcp: self.timings.connect - self.timings.lookup,\n        firstByte: self.timings.response - self.timings.connect,\n        download: self.timings.end - self.timings.response,\n        total: self.timings.end\n      }\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n    self.strictSSL && (!response.hasOwnProperty('socket') ||\n    !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  self.clearTimeout()\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    // set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.once('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD' ||\n        // Informational\n        (code >= 100 && code < 200) ||\n        // No Content\n        code === 204 ||\n        // Not Modified\n        code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      // Be more lenient with decoding compressed responses, since (very rarely)\n      // servers send slightly invalid gzip responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip(zlibOptions)\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate(zlibOptions)\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else {\n        responseContent.setEncoding(self.encoding)\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      if (self.timing && !self.responseStarted) {\n        self.responseStartTime = (new Date()).getTime()\n\n        // NOTE: responseStartTime is deprecated in favor of .timings\n        response.responseStartTime = self.responseStartTime\n      }\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.once('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () { self.emit('close') })\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    } else { // if no callback\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug(\"reading response's body\")\n  var buffers = []\n  var bufferLength = 0\n  var strings = []\n\n  self.on('data', function (chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      strings.push(chunk)\n    } else if (chunk.length) {\n      bufferLength += chunk.length\n      buffers.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n      return\n    }\n\n    if (bufferLength) {\n      debug('has body', self.uri.href, bufferLength)\n      response.body = Buffer.concat(buffers, bufferLength)\n      if (self.encoding !== null) {\n        response.body = response.body.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.clearTimeout()\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      } else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function (err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n  var host = unixParts[0]\n  var path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: self.headers,\n      body: self.body\n    }\n    if (opts.service) {\n      options.service = opts.service\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret,\n      sessionToken: opts.session\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n    if (signRes.headers['X-Amz-Security-Token']) {\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n    }\n  } else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth = {\n      key: opts.key,\n      secret: opts.secret,\n      verb: self.method.toUpperCase(),\n      date: date,\n      contentType: self.getHeader('content-type') || '',\n      md5: self.getHeader('content-md5') || '',\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n    }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function (header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n    var urihref = self.uri.href\n    // fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  // if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) { return }\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) { return }\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  this.clearTimeout()\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.prototype.clearTimeout = function () {\n  if (this.timeoutTimer) {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n","start":1667202704315,"end":1667202704399},{"name":"vite:define","result":"'use strict'\n\nvar http = require('http')\nvar https = require('https')\nvar url = require('url')\nvar util = require('util')\nvar stream = require('stream')\nvar zlib = require('zlib')\nvar aws2 = require('aws-sign2')\nvar aws4 = require('aws4')\nvar httpSignature = require('http-signature')\nvar mime = require('mime-types')\nvar caseless = require('caseless')\nvar ForeverAgent = require('forever-agent')\nvar FormData = require('form-data')\nvar extend = require('extend')\nvar isstream = require('isstream')\nvar isTypedArray = require('is-typedarray').strict\nvar helpers = require('./lib/helpers')\nvar cookies = require('./lib/cookies')\nvar getProxyFromURI = require('./lib/getProxyFromURI')\nvar Querystring = require('./lib/querystring').Querystring\nvar Har = require('./lib/har').Har\nvar Auth = require('./lib/auth').Auth\nvar OAuth = require('./lib/oauth').OAuth\nvar hawk = require('./lib/hawk')\nvar Multipart = require('./lib/multipart').Multipart\nvar Redirect = require('./lib/redirect').Redirect\nvar Tunnel = require('./lib/tunnel').Tunnel\nvar now = require('performance-now')\nvar Buffer = require('safe-buffer').Buffer\n\nvar safeStringify = helpers.safeStringify\nvar isReadStream = helpers.isReadStream\nvar toBase64 = helpers.toBase64\nvar defer = helpers.defer\nvar copy = helpers.copy\nvar version = helpers.version\nvar globalCookieJar = cookies.jar()\n\nvar globalPool = {}\n\nfunction filterForNonReserved (reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions (reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON () {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON () {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = {}.NODE_DEBUG && /\\brequest\\b/.test({}.NODE_DEBUG)\nfunction debug () {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.host)\n    // Drop :port suffix from Host header if known protocol.\n    if (self.uri.port) {\n      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n        self.setHeader(hostHeaderName, self.uri.hostname)\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n\n    // NOTE: elapsedTime is deprecated in favor of .timings\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = Buffer.from(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      } else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n      } else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n  var defaultModules = {'http:': http, 'https:': https}\n  var httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n  // self.on('pipe', function () {\n  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n  // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self.timing) {\n    // All timings will be relative to this request's startTime.  In order to do this,\n    // we need to capture the wall-clock start time (via Date), immediately followed\n    // by the high-resolution timer (via now()).  While these two won't be set\n    // at the _exact_ same time, they should be close enough to be able to calculate\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n    var startTime = new Date().getTime()\n    var startTimeNow = now()\n  }\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n  // should delete it for now since we handle timeouts manually for better\n  // consistency with node versions before v6.8.0\n  delete reqOptions.timeout\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = startTime\n    self.startTimeNow = startTimeNow\n\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\n    // so we have an accurate clock)\n    self.timings = {}\n  }\n\n  var timeout\n  if (self.timeout && !self.timeoutTimer) {\n    if (self.timeout < 0) {\n      timeout = 0\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n      timeout = self.timeout\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function () {\n    self.emit('drain')\n  })\n\n  self.req.on('socket', function (socket) {\n    // `._connecting` was the old property which was made public in node v6.1.0\n    var isConnecting = socket._connecting || socket.connecting\n    if (self.timing) {\n      self.timings.socket = now() - self.startTimeNow\n\n      if (isConnecting) {\n        var onLookupTiming = function () {\n          self.timings.lookup = now() - self.startTimeNow\n        }\n\n        var onConnectTiming = function () {\n          self.timings.connect = now() - self.startTimeNow\n        }\n\n        socket.once('lookup', onLookupTiming)\n        socket.once('connect', onConnectTiming)\n\n        // clean up timing event listeners if needed on error\n        self.req.once('error', function () {\n          socket.removeListener('lookup', onLookupTiming)\n          socket.removeListener('connect', onConnectTiming)\n        })\n      }\n    }\n\n    var setReqTimeout = function () {\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server once connected.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n    if (timeout !== undefined) {\n      // Only start the connection timer if we're actually connecting a new\n      // socket, otherwise if we're already connected (because this is a\n      // keep-alive connection) do not bother. This is important since we won't\n      // get a 'connect' event for an already connected socket.\n      if (isConnecting) {\n        var onReqSockConnect = function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.clearTimeout()\n          setReqTimeout()\n        }\n\n        socket.on('connect', onReqSockConnect)\n\n        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n          socket.removeListener('connect', onReqSockConnect)\n        })\n\n        // Set a timeout in memory - this block will throw if the server takes more\n        // than `timeout` to write the HTTP status and headers (corresponding to\n        // the on('response') event on the client). NB: this measures wall-clock\n        // time, not the time between bytes sent by the server.\n        self.timeoutTimer = setTimeout(function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.abort()\n          var e = new Error('ETIMEDOUT')\n          e.code = 'ETIMEDOUT'\n          e.connect = true\n          self.emit('error', e)\n        }, timeout)\n      } else {\n        // We're already connected\n        setReqTimeout()\n      }\n    }\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n    self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  self.clearTimeout()\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n\n  if (self.timing) {\n    self.timings.response = now() - self.startTimeNow\n  }\n\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function () {\n    if (self.timing) {\n      self.timings.end = now() - self.startTimeNow\n      response.timingStart = self.startTime\n\n      // fill in the blanks for any periods that didn't trigger, such as\n      // no lookup or connect due to keep alive\n      if (!self.timings.socket) {\n        self.timings.socket = 0\n      }\n      if (!self.timings.lookup) {\n        self.timings.lookup = self.timings.socket\n      }\n      if (!self.timings.connect) {\n        self.timings.connect = self.timings.lookup\n      }\n      if (!self.timings.response) {\n        self.timings.response = self.timings.connect\n      }\n\n      debug('elapsed time', self.timings.end)\n\n      // elapsedTime includes all redirects\n      self.elapsedTime += Math.round(self.timings.end)\n\n      // NOTE: elapsedTime is deprecated in favor of .timings\n      response.elapsedTime = self.elapsedTime\n\n      // timings is just for the final fetch\n      response.timings = self.timings\n\n      // pre-calculate phase timings as well\n      response.timingPhases = {\n        wait: self.timings.socket,\n        dns: self.timings.lookup - self.timings.socket,\n        tcp: self.timings.connect - self.timings.lookup,\n        firstByte: self.timings.response - self.timings.connect,\n        download: self.timings.end - self.timings.response,\n        total: self.timings.end\n      }\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n    self.strictSSL && (!response.hasOwnProperty('socket') ||\n    !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  self.clearTimeout()\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    // set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.once('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD' ||\n        // Informational\n        (code >= 100 && code < 200) ||\n        // No Content\n        code === 204 ||\n        // Not Modified\n        code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      // Be more lenient with decoding compressed responses, since (very rarely)\n      // servers send slightly invalid gzip responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip(zlibOptions)\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate(zlibOptions)\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else {\n        responseContent.setEncoding(self.encoding)\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      if (self.timing && !self.responseStarted) {\n        self.responseStartTime = (new Date()).getTime()\n\n        // NOTE: responseStartTime is deprecated in favor of .timings\n        response.responseStartTime = self.responseStartTime\n      }\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.once('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () { self.emit('close') })\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    } else { // if no callback\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug(\"reading response's body\")\n  var buffers = []\n  var bufferLength = 0\n  var strings = []\n\n  self.on('data', function (chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      strings.push(chunk)\n    } else if (chunk.length) {\n      bufferLength += chunk.length\n      buffers.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n      return\n    }\n\n    if (bufferLength) {\n      debug('has body', self.uri.href, bufferLength)\n      response.body = Buffer.concat(buffers, bufferLength)\n      if (self.encoding !== null) {\n        response.body = response.body.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.clearTimeout()\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      } else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function (err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n  var host = unixParts[0]\n  var path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: self.headers,\n      body: self.body\n    }\n    if (opts.service) {\n      options.service = opts.service\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret,\n      sessionToken: opts.session\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n    if (signRes.headers['X-Amz-Security-Token']) {\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n    }\n  } else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth = {\n      key: opts.key,\n      secret: opts.secret,\n      verb: self.method.toUpperCase(),\n      date: date,\n      contentType: self.getHeader('content-type') || '',\n      md5: self.getHeader('content-md5') || '',\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n    }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function (header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n    var urihref = self.uri.href\n    // fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  // if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) { return }\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) { return }\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  this.clearTimeout()\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.prototype.clearTimeout = function () {\n  if (this.timeoutTimer) {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n","start":1667202704399,"end":1667202704399,"order":"normal"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport require$$4 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/rollup-plugin-node-polyfills/polyfills/stream.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws-sign2/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/aws4.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/http-signature/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/mime-types/index.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/caseless/index.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/forever-agent/index.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/form-data/lib/browser.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/extend/index.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/isstream/isstream.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/is-typedarray/index.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/helpers.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/cookies.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/getProxyFromURI.js?commonjs-wrapped\";\nimport { __require as require$$19 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/querystring.js?commonjs-wrapped\";\nimport { __require as require$$20 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/har.js?commonjs-wrapped\";\nimport { __require as require$$21 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/auth.js?commonjs-wrapped\";\nimport { __require as require$$22 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/oauth.js?commonjs-wrapped\";\nimport { __require as require$$23 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/hawk.js?commonjs-wrapped\";\nimport { __require as require$$24 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/multipart.js?commonjs-wrapped\";\nimport { __require as require$$25 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/redirect.js?commonjs-wrapped\";\nimport { __require as require$$26 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/tunnel.js?commonjs-wrapped\";\nimport { __require as require$$27 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/performance-now/lib/performance-now.js?commonjs-wrapped\";\nimport { __require as require$$28 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safe-buffer/index.js?commonjs-wrapped\";\n\nvar request;\nvar hasRequiredRequest;\n\nfunction requireRequest () {\n\tif (hasRequiredRequest) return request;\n\thasRequiredRequest = 1;\n\t'use strict'\n\n\tvar http = require$$0\n\tvar https = require$$1\n\tvar url = require$$2\n\tvar util = require$$3()\n\tvar stream = require$$4\n\tvar zlib = require$$5\n\tvar aws2 = require$$6()\n\tvar aws4 = require$$7()\n\tvar httpSignature = require$$8()\n\tvar mime = require$$9()\n\tvar caseless = require$$10()\n\tvar ForeverAgent = require$$11()\n\tvar FormData = require$$12()\n\tvar extend = require$$13()\n\tvar isstream = require$$14()\n\tvar isTypedArray = require$$15().strict\n\tvar helpers = require$$16()\n\tvar cookies = require$$17()\n\tvar getProxyFromURI = require$$18()\n\tvar Querystring = require$$19().Querystring\n\tvar Har = require$$20().Har\n\tvar Auth = require$$21().Auth\n\tvar OAuth = require$$22().OAuth\n\tvar hawk = require$$23()\n\tvar Multipart = require$$24().Multipart\n\tvar Redirect = require$$25().Redirect\n\tvar Tunnel = require$$26().Tunnel\n\tvar now = require$$27()\n\tvar Buffer = require$$28().Buffer\n\n\tvar safeStringify = helpers.safeStringify\n\tvar isReadStream = helpers.isReadStream\n\tvar toBase64 = helpers.toBase64\n\tvar defer = helpers.defer\n\tvar copy = helpers.copy\n\tvar version = helpers.version\n\tvar globalCookieJar = cookies.jar()\n\n\tvar globalPool = {}\n\n\tfunction filterForNonReserved (reserved, options) {\n\t  // Filter out properties that are not reserved.\n\t  // Reserved values are passed in at call site.\n\n\t  var object = {}\n\t  for (var i in options) {\n\t    var notReserved = (reserved.indexOf(i) === -1)\n\t    if (notReserved) {\n\t      object[i] = options[i]\n\t    }\n\t  }\n\t  return object\n\t}\n\n\tfunction filterOutReservedFunctions (reserved, options) {\n\t  // Filter out properties that are functions and are reserved.\n\t  // Reserved values are passed in at call site.\n\n\t  var object = {}\n\t  for (var i in options) {\n\t    var isReserved = !(reserved.indexOf(i) === -1)\n\t    var isFunction = (typeof options[i] === 'function')\n\t    if (!(isReserved && isFunction)) {\n\t      object[i] = options[i]\n\t    }\n\t  }\n\t  return object\n\t}\n\n\t// Return a simpler request object to allow serialization\n\tfunction requestToJSON () {\n\t  var self = this\n\t  return {\n\t    uri: self.uri,\n\t    method: self.method,\n\t    headers: self.headers\n\t  }\n\t}\n\n\t// Return a simpler response object to allow serialization\n\tfunction responseToJSON () {\n\t  var self = this\n\t  return {\n\t    statusCode: self.statusCode,\n\t    body: self.body,\n\t    headers: self.headers,\n\t    request: requestToJSON.call(self.request)\n\t  }\n\t}\n\n\tfunction Request (options) {\n\t  // if given the method property in options, set property explicitMethod to true\n\n\t  // extend the Request instance with any non-reserved properties\n\t  // remove any reserved functions from the options object\n\t  // set Request instance to be readable and writable\n\t  // call init\n\n\t  var self = this\n\n\t  // start with HAR, then override with additional options\n\t  if (options.har) {\n\t    self._har = new Har(self)\n\t    options = self._har.options(options)\n\t  }\n\n\t  stream.Stream.call(self)\n\t  var reserved = Object.keys(Request.prototype)\n\t  var nonReserved = filterForNonReserved(reserved, options)\n\n\t  extend(self, nonReserved)\n\t  options = filterOutReservedFunctions(reserved, options)\n\n\t  self.readable = true\n\t  self.writable = true\n\t  if (options.method) {\n\t    self.explicitMethod = true\n\t  }\n\t  self._qs = new Querystring(self)\n\t  self._auth = new Auth(self)\n\t  self._oauth = new OAuth(self)\n\t  self._multipart = new Multipart(self)\n\t  self._redirect = new Redirect(self)\n\t  self._tunnel = new Tunnel(self)\n\t  self.init(options)\n\t}\n\n\tutil.inherits(Request, stream.Stream)\n\n\t// Debugging\n\tRequest.debug = {}.NODE_DEBUG && /\\brequest\\b/.test({}.NODE_DEBUG)\n\tfunction debug () {\n\t  if (Request.debug) {\n\t    console.error('REQUEST %s', util.format.apply(util, arguments))\n\t  }\n\t}\n\tRequest.prototype.debug = debug\n\n\tRequest.prototype.init = function (options) {\n\t  // init() contains all the code to setup the request object.\n\t  // the actual outgoing request is not started until start() is called\n\t  // this function is called from both the constructor and on redirect.\n\t  var self = this\n\t  if (!options) {\n\t    options = {}\n\t  }\n\t  self.headers = self.headers ? copy(self.headers) : {}\n\n\t  // Delete headers with value undefined since they break\n\t  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n\t  for (var headerName in self.headers) {\n\t    if (typeof self.headers[headerName] === 'undefined') {\n\t      delete self.headers[headerName]\n\t    }\n\t  }\n\n\t  caseless.httpify(self, self.headers)\n\n\t  if (!self.method) {\n\t    self.method = options.method || 'GET'\n\t  }\n\t  if (!self.localAddress) {\n\t    self.localAddress = options.localAddress\n\t  }\n\n\t  self._qs.init(options)\n\n\t  debug(options)\n\t  if (!self.pool && self.pool !== false) {\n\t    self.pool = globalPool\n\t  }\n\t  self.dests = self.dests || []\n\t  self.__isRequestRequest = true\n\n\t  // Protect against double callback\n\t  if (!self._callback && self.callback) {\n\t    self._callback = self.callback\n\t    self.callback = function () {\n\t      if (self._callbackCalled) {\n\t        return // Print a warning maybe?\n\t      }\n\t      self._callbackCalled = true\n\t      self._callback.apply(self, arguments)\n\t    }\n\t    self.on('error', self.callback.bind())\n\t    self.on('complete', self.callback.bind(self, null))\n\t  }\n\n\t  // People use this property instead all the time, so support it\n\t  if (!self.uri && self.url) {\n\t    self.uri = self.url\n\t    delete self.url\n\t  }\n\n\t  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n\t  // specified as a relative path and is appended to baseUrl).\n\t  if (self.baseUrl) {\n\t    if (typeof self.baseUrl !== 'string') {\n\t      return self.emit('error', new Error('options.baseUrl must be a string'))\n\t    }\n\n\t    if (typeof self.uri !== 'string') {\n\t      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n\t    }\n\n\t    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n\t      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n\t    }\n\n\t    // Handle all cases to make sure that there's only one slash between\n\t    // baseUrl and uri.\n\t    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n\t    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n\t    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n\t      self.uri = self.baseUrl + self.uri.slice(1)\n\t    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n\t      self.uri = self.baseUrl + self.uri\n\t    } else if (self.uri === '') {\n\t      self.uri = self.baseUrl\n\t    } else {\n\t      self.uri = self.baseUrl + '/' + self.uri\n\t    }\n\t    delete self.baseUrl\n\t  }\n\n\t  // A URI is needed by this point, emit error if we haven't been able to get one\n\t  if (!self.uri) {\n\t    return self.emit('error', new Error('options.uri is a required argument'))\n\t  }\n\n\t  // If a string URI/URL was given, parse it into a URL object\n\t  if (typeof self.uri === 'string') {\n\t    self.uri = url.parse(self.uri)\n\t  }\n\n\t  // Some URL objects are not from a URL parsed string and need href added\n\t  if (!self.uri.href) {\n\t    self.uri.href = url.format(self.uri)\n\t  }\n\n\t  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n\t  if (self.uri.protocol === 'unix:') {\n\t    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n\t  }\n\n\t  // Support Unix Sockets\n\t  if (self.uri.host === 'unix') {\n\t    self.enableUnixSocket()\n\t  }\n\n\t  if (self.strictSSL === false) {\n\t    self.rejectUnauthorized = false\n\t  }\n\n\t  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n\t  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n\t    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n\t    // Detect and reject it as soon as possible\n\t    var faultyUri = url.format(self.uri)\n\t    var message = 'Invalid URI \"' + faultyUri + '\"'\n\t    if (Object.keys(options).length === 0) {\n\t      // No option ? This can be the sign of a redirect\n\t      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n\t      // they should be warned that it can be caused by a redirection (can save some hair)\n\t      message += '. This can be caused by a crappy redirection.'\n\t    }\n\t    // This error was fatal\n\t    self.abort()\n\t    return self.emit('error', new Error(message))\n\t  }\n\n\t  if (!self.hasOwnProperty('proxy')) {\n\t    self.proxy = getProxyFromURI(self.uri)\n\t  }\n\n\t  self.tunnel = self._tunnel.isEnabled()\n\t  if (self.proxy) {\n\t    self._tunnel.setup(options)\n\t  }\n\n\t  self._redirect.onRequest(options)\n\n\t  self.setHost = false\n\t  if (!self.hasHeader('host')) {\n\t    var hostHeaderName = self.originalHostHeaderName || 'host'\n\t    self.setHeader(hostHeaderName, self.uri.host)\n\t    // Drop :port suffix from Host header if known protocol.\n\t    if (self.uri.port) {\n\t      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n\t          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n\t        self.setHeader(hostHeaderName, self.uri.hostname)\n\t      }\n\t    }\n\t    self.setHost = true\n\t  }\n\n\t  self.jar(self._jar || options.jar)\n\n\t  if (!self.uri.port) {\n\t    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n\t  }\n\n\t  if (self.proxy && !self.tunnel) {\n\t    self.port = self.proxy.port\n\t    self.host = self.proxy.hostname\n\t  } else {\n\t    self.port = self.uri.port\n\t    self.host = self.uri.hostname\n\t  }\n\n\t  if (options.form) {\n\t    self.form(options.form)\n\t  }\n\n\t  if (options.formData) {\n\t    var formData = options.formData\n\t    var requestForm = self.form()\n\t    var appendFormValue = function (key, value) {\n\t      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n\t        requestForm.append(key, value.value, value.options)\n\t      } else {\n\t        requestForm.append(key, value)\n\t      }\n\t    }\n\t    for (var formKey in formData) {\n\t      if (formData.hasOwnProperty(formKey)) {\n\t        var formValue = formData[formKey]\n\t        if (formValue instanceof Array) {\n\t          for (var j = 0; j < formValue.length; j++) {\n\t            appendFormValue(formKey, formValue[j])\n\t          }\n\t        } else {\n\t          appendFormValue(formKey, formValue)\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  if (options.qs) {\n\t    self.qs(options.qs)\n\t  }\n\n\t  if (self.uri.path) {\n\t    self.path = self.uri.path\n\t  } else {\n\t    self.path = self.uri.pathname + (self.uri.search || '')\n\t  }\n\n\t  if (self.path.length === 0) {\n\t    self.path = '/'\n\t  }\n\n\t  // Auth must happen last in case signing is dependent on other headers\n\t  if (options.aws) {\n\t    self.aws(options.aws)\n\t  }\n\n\t  if (options.hawk) {\n\t    self.hawk(options.hawk)\n\t  }\n\n\t  if (options.httpSignature) {\n\t    self.httpSignature(options.httpSignature)\n\t  }\n\n\t  if (options.auth) {\n\t    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n\t      options.auth.user = options.auth.username\n\t    }\n\t    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n\t      options.auth.pass = options.auth.password\n\t    }\n\n\t    self.auth(\n\t      options.auth.user,\n\t      options.auth.pass,\n\t      options.auth.sendImmediately,\n\t      options.auth.bearer\n\t    )\n\t  }\n\n\t  if (self.gzip && !self.hasHeader('accept-encoding')) {\n\t    self.setHeader('accept-encoding', 'gzip, deflate')\n\t  }\n\n\t  if (self.uri.auth && !self.hasHeader('authorization')) {\n\t    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n\t    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n\t  }\n\n\t  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n\t    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n\t    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n\t    self.setHeader('proxy-authorization', authHeader)\n\t  }\n\n\t  if (self.proxy && !self.tunnel) {\n\t    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n\t  }\n\n\t  if (options.json) {\n\t    self.json(options.json)\n\t  }\n\t  if (options.multipart) {\n\t    self.multipart(options.multipart)\n\t  }\n\n\t  if (options.time) {\n\t    self.timing = true\n\n\t    // NOTE: elapsedTime is deprecated in favor of .timings\n\t    self.elapsedTime = self.elapsedTime || 0\n\t  }\n\n\t  function setContentLength () {\n\t    if (isTypedArray(self.body)) {\n\t      self.body = Buffer.from(self.body)\n\t    }\n\n\t    if (!self.hasHeader('content-length')) {\n\t      var length\n\t      if (typeof self.body === 'string') {\n\t        length = Buffer.byteLength(self.body)\n\t      } else if (Array.isArray(self.body)) {\n\t        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n\t      } else {\n\t        length = self.body.length\n\t      }\n\n\t      if (length) {\n\t        self.setHeader('content-length', length)\n\t      } else {\n\t        self.emit('error', new Error('Argument error, options.body.'))\n\t      }\n\t    }\n\t  }\n\t  if (self.body && !isstream(self.body)) {\n\t    setContentLength()\n\t  }\n\n\t  if (options.oauth) {\n\t    self.oauth(options.oauth)\n\t  } else if (self._oauth.params && self.hasHeader('authorization')) {\n\t    self.oauth(self._oauth.params)\n\t  }\n\n\t  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n\t  var defaultModules = {'http:': http, 'https:': https}\n\t  var httpModules = self.httpModules || {}\n\n\t  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n\t  if (!self.httpModule) {\n\t    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n\t  }\n\n\t  if (options.ca) {\n\t    self.ca = options.ca\n\t  }\n\n\t  if (!self.agent) {\n\t    if (options.agentOptions) {\n\t      self.agentOptions = options.agentOptions\n\t    }\n\n\t    if (options.agentClass) {\n\t      self.agentClass = options.agentClass\n\t    } else if (options.forever) {\n\t      var v = version()\n\t      // use ForeverAgent in node 0.10- only\n\t      if (v.major === 0 && v.minor <= 10) {\n\t        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n\t      } else {\n\t        self.agentClass = self.httpModule.Agent\n\t        self.agentOptions = self.agentOptions || {}\n\t        self.agentOptions.keepAlive = true\n\t      }\n\t    } else {\n\t      self.agentClass = self.httpModule.Agent\n\t    }\n\t  }\n\n\t  if (self.pool === false) {\n\t    self.agent = false\n\t  } else {\n\t    self.agent = self.agent || self.getNewAgent()\n\t  }\n\n\t  self.on('pipe', function (src) {\n\t    if (self.ntick && self._started) {\n\t      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n\t    }\n\t    self.src = src\n\t    if (isReadStream(src)) {\n\t      if (!self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', mime.lookup(src.path))\n\t      }\n\t    } else {\n\t      if (src.headers) {\n\t        for (var i in src.headers) {\n\t          if (!self.hasHeader(i)) {\n\t            self.setHeader(i, src.headers[i])\n\t          }\n\t        }\n\t      }\n\t      if (self._json && !self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', 'application/json')\n\t      }\n\t      if (src.method && !self.explicitMethod) {\n\t        self.method = src.method\n\t      }\n\t    }\n\n\t  // self.on('pipe', function () {\n\t  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n\t  // })\n\t  })\n\n\t  defer(function () {\n\t    if (self._aborted) {\n\t      return\n\t    }\n\n\t    var end = function () {\n\t      if (self._form) {\n\t        if (!self._auth.hasAuth) {\n\t          self._form.pipe(self)\n\t        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n\t          self._form.pipe(self)\n\t        }\n\t      }\n\t      if (self._multipart && self._multipart.chunked) {\n\t        self._multipart.body.pipe(self)\n\t      }\n\t      if (self.body) {\n\t        if (isstream(self.body)) {\n\t          self.body.pipe(self)\n\t        } else {\n\t          setContentLength()\n\t          if (Array.isArray(self.body)) {\n\t            self.body.forEach(function (part) {\n\t              self.write(part)\n\t            })\n\t          } else {\n\t            self.write(self.body)\n\t          }\n\t          self.end()\n\t        }\n\t      } else if (self.requestBodyStream) {\n\t        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n\t        self.requestBodyStream.pipe(self)\n\t      } else if (!self.src) {\n\t        if (self._auth.hasAuth && !self._auth.sentAuth) {\n\t          self.end()\n\t          return\n\t        }\n\t        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n\t          self.setHeader('content-length', 0)\n\t        }\n\t        self.end()\n\t      }\n\t    }\n\n\t    if (self._form && !self.hasHeader('content-length')) {\n\t      // Before ending the request, we had to compute the length of the whole form, asyncly\n\t      self.setHeader(self._form.getHeaders(), true)\n\t      self._form.getLength(function (err, length) {\n\t        if (!err && !isNaN(length)) {\n\t          self.setHeader('content-length', length)\n\t        }\n\t        end()\n\t      })\n\t    } else {\n\t      end()\n\t    }\n\n\t    self.ntick = true\n\t  })\n\t}\n\n\tRequest.prototype.getNewAgent = function () {\n\t  var self = this\n\t  var Agent = self.agentClass\n\t  var options = {}\n\t  if (self.agentOptions) {\n\t    for (var i in self.agentOptions) {\n\t      options[i] = self.agentOptions[i]\n\t    }\n\t  }\n\t  if (self.ca) {\n\t    options.ca = self.ca\n\t  }\n\t  if (self.ciphers) {\n\t    options.ciphers = self.ciphers\n\t  }\n\t  if (self.secureProtocol) {\n\t    options.secureProtocol = self.secureProtocol\n\t  }\n\t  if (self.secureOptions) {\n\t    options.secureOptions = self.secureOptions\n\t  }\n\t  if (typeof self.rejectUnauthorized !== 'undefined') {\n\t    options.rejectUnauthorized = self.rejectUnauthorized\n\t  }\n\n\t  if (self.cert && self.key) {\n\t    options.key = self.key\n\t    options.cert = self.cert\n\t  }\n\n\t  if (self.pfx) {\n\t    options.pfx = self.pfx\n\t  }\n\n\t  if (self.passphrase) {\n\t    options.passphrase = self.passphrase\n\t  }\n\n\t  var poolKey = ''\n\n\t  // different types of agents are in different pools\n\t  if (Agent !== self.httpModule.Agent) {\n\t    poolKey += Agent.name\n\t  }\n\n\t  // ca option is only relevant if proxy or destination are https\n\t  var proxy = self.proxy\n\t  if (typeof proxy === 'string') {\n\t    proxy = url.parse(proxy)\n\t  }\n\t  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n\t  if (isHttps) {\n\t    if (options.ca) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.ca\n\t    }\n\n\t    if (typeof options.rejectUnauthorized !== 'undefined') {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.rejectUnauthorized\n\t    }\n\n\t    if (options.cert) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n\t    }\n\n\t    if (options.pfx) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.pfx.toString('ascii')\n\t    }\n\n\t    if (options.ciphers) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.ciphers\n\t    }\n\n\t    if (options.secureProtocol) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.secureProtocol\n\t    }\n\n\t    if (options.secureOptions) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.secureOptions\n\t    }\n\t  }\n\n\t  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n\t    // not doing anything special.  Use the globalAgent\n\t    return self.httpModule.globalAgent\n\t  }\n\n\t  // we're using a stored agent.  Make sure it's protocol-specific\n\t  poolKey = self.uri.protocol + poolKey\n\n\t  // generate a new agent for this setting if none yet exists\n\t  if (!self.pool[poolKey]) {\n\t    self.pool[poolKey] = new Agent(options)\n\t    // properly set maxSockets on new agents\n\t    if (self.pool.maxSockets) {\n\t      self.pool[poolKey].maxSockets = self.pool.maxSockets\n\t    }\n\t  }\n\n\t  return self.pool[poolKey]\n\t}\n\n\tRequest.prototype.start = function () {\n\t  // start() is called once we are ready to send the outgoing HTTP request.\n\t  // this is usually called on the first write(), end() or on nextTick()\n\t  var self = this\n\n\t  if (self.timing) {\n\t    // All timings will be relative to this request's startTime.  In order to do this,\n\t    // we need to capture the wall-clock start time (via Date), immediately followed\n\t    // by the high-resolution timer (via now()).  While these two won't be set\n\t    // at the _exact_ same time, they should be close enough to be able to calculate\n\t    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n\t    var startTime = new Date().getTime()\n\t    var startTimeNow = now()\n\t  }\n\n\t  if (self._aborted) {\n\t    return\n\t  }\n\n\t  self._started = true\n\t  self.method = self.method || 'GET'\n\t  self.href = self.uri.href\n\n\t  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n\t    self.setHeader('content-length', self.src.stat.size)\n\t  }\n\t  if (self._aws) {\n\t    self.aws(self._aws, true)\n\t  }\n\n\t  // We have a method named auth, which is completely different from the http.request\n\t  // auth option.  If we don't remove it, we're gonna have a bad time.\n\t  var reqOptions = copy(self)\n\t  delete reqOptions.auth\n\n\t  debug('make request', self.uri.href)\n\n\t  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n\t  // should delete it for now since we handle timeouts manually for better\n\t  // consistency with node versions before v6.8.0\n\t  delete reqOptions.timeout\n\n\t  try {\n\t    self.req = self.httpModule.request(reqOptions)\n\t  } catch (err) {\n\t    self.emit('error', err)\n\t    return\n\t  }\n\n\t  if (self.timing) {\n\t    self.startTime = startTime\n\t    self.startTimeNow = startTimeNow\n\n\t    // Timing values will all be relative to startTime (by comparing to startTimeNow\n\t    // so we have an accurate clock)\n\t    self.timings = {}\n\t  }\n\n\t  var timeout\n\t  if (self.timeout && !self.timeoutTimer) {\n\t    if (self.timeout < 0) {\n\t      timeout = 0\n\t    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n\t      timeout = self.timeout\n\t    }\n\t  }\n\n\t  self.req.on('response', self.onRequestResponse.bind(self))\n\t  self.req.on('error', self.onRequestError.bind(self))\n\t  self.req.on('drain', function () {\n\t    self.emit('drain')\n\t  })\n\n\t  self.req.on('socket', function (socket) {\n\t    // `._connecting` was the old property which was made public in node v6.1.0\n\t    var isConnecting = socket._connecting || socket.connecting\n\t    if (self.timing) {\n\t      self.timings.socket = now() - self.startTimeNow\n\n\t      if (isConnecting) {\n\t        var onLookupTiming = function () {\n\t          self.timings.lookup = now() - self.startTimeNow\n\t        }\n\n\t        var onConnectTiming = function () {\n\t          self.timings.connect = now() - self.startTimeNow\n\t        }\n\n\t        socket.once('lookup', onLookupTiming)\n\t        socket.once('connect', onConnectTiming)\n\n\t        // clean up timing event listeners if needed on error\n\t        self.req.once('error', function () {\n\t          socket.removeListener('lookup', onLookupTiming)\n\t          socket.removeListener('connect', onConnectTiming)\n\t        })\n\t      }\n\t    }\n\n\t    var setReqTimeout = function () {\n\t      // This timeout sets the amount of time to wait *between* bytes sent\n\t      // from the server once connected.\n\t      //\n\t      // In particular, it's useful for erroring if the server fails to send\n\t      // data halfway through streaming a response.\n\t      self.req.setTimeout(timeout, function () {\n\t        if (self.req) {\n\t          self.abort()\n\t          var e = new Error('ESOCKETTIMEDOUT')\n\t          e.code = 'ESOCKETTIMEDOUT'\n\t          e.connect = false\n\t          self.emit('error', e)\n\t        }\n\t      })\n\t    }\n\t    if (timeout !== undefined) {\n\t      // Only start the connection timer if we're actually connecting a new\n\t      // socket, otherwise if we're already connected (because this is a\n\t      // keep-alive connection) do not bother. This is important since we won't\n\t      // get a 'connect' event for an already connected socket.\n\t      if (isConnecting) {\n\t        var onReqSockConnect = function () {\n\t          socket.removeListener('connect', onReqSockConnect)\n\t          self.clearTimeout()\n\t          setReqTimeout()\n\t        }\n\n\t        socket.on('connect', onReqSockConnect)\n\n\t        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n\t          socket.removeListener('connect', onReqSockConnect)\n\t        })\n\n\t        // Set a timeout in memory - this block will throw if the server takes more\n\t        // than `timeout` to write the HTTP status and headers (corresponding to\n\t        // the on('response') event on the client). NB: this measures wall-clock\n\t        // time, not the time between bytes sent by the server.\n\t        self.timeoutTimer = setTimeout(function () {\n\t          socket.removeListener('connect', onReqSockConnect)\n\t          self.abort()\n\t          var e = new Error('ETIMEDOUT')\n\t          e.code = 'ETIMEDOUT'\n\t          e.connect = true\n\t          self.emit('error', e)\n\t        }, timeout)\n\t      } else {\n\t        // We're already connected\n\t        setReqTimeout()\n\t      }\n\t    }\n\t    self.emit('socket', socket)\n\t  })\n\n\t  self.emit('request', self.req)\n\t}\n\n\tRequest.prototype.onRequestError = function (error) {\n\t  var self = this\n\t  if (self._aborted) {\n\t    return\n\t  }\n\t  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n\t    self.agent.addRequestNoreuse) {\n\t    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n\t    self.start()\n\t    self.req.end()\n\t    return\n\t  }\n\t  self.clearTimeout()\n\t  self.emit('error', error)\n\t}\n\n\tRequest.prototype.onRequestResponse = function (response) {\n\t  var self = this\n\n\t  if (self.timing) {\n\t    self.timings.response = now() - self.startTimeNow\n\t  }\n\n\t  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n\t  response.on('end', function () {\n\t    if (self.timing) {\n\t      self.timings.end = now() - self.startTimeNow\n\t      response.timingStart = self.startTime\n\n\t      // fill in the blanks for any periods that didn't trigger, such as\n\t      // no lookup or connect due to keep alive\n\t      if (!self.timings.socket) {\n\t        self.timings.socket = 0\n\t      }\n\t      if (!self.timings.lookup) {\n\t        self.timings.lookup = self.timings.socket\n\t      }\n\t      if (!self.timings.connect) {\n\t        self.timings.connect = self.timings.lookup\n\t      }\n\t      if (!self.timings.response) {\n\t        self.timings.response = self.timings.connect\n\t      }\n\n\t      debug('elapsed time', self.timings.end)\n\n\t      // elapsedTime includes all redirects\n\t      self.elapsedTime += Math.round(self.timings.end)\n\n\t      // NOTE: elapsedTime is deprecated in favor of .timings\n\t      response.elapsedTime = self.elapsedTime\n\n\t      // timings is just for the final fetch\n\t      response.timings = self.timings\n\n\t      // pre-calculate phase timings as well\n\t      response.timingPhases = {\n\t        wait: self.timings.socket,\n\t        dns: self.timings.lookup - self.timings.socket,\n\t        tcp: self.timings.connect - self.timings.lookup,\n\t        firstByte: self.timings.response - self.timings.connect,\n\t        download: self.timings.end - self.timings.response,\n\t        total: self.timings.end\n\t      }\n\t    }\n\t    debug('response end', self.uri.href, response.statusCode, response.headers)\n\t  })\n\n\t  if (self._aborted) {\n\t    debug('aborted', self.uri.href)\n\t    response.resume()\n\t    return\n\t  }\n\n\t  self.response = response\n\t  response.request = self\n\t  response.toJSON = responseToJSON\n\n\t  // XXX This is different on 0.10, because SSL is strict by default\n\t  if (self.httpModule === https &&\n\t    self.strictSSL && (!response.hasOwnProperty('socket') ||\n\t    !response.socket.authorized)) {\n\t    debug('strict ssl error', self.uri.href)\n\t    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n\t    self.emit('error', new Error('SSL Error: ' + sslErr))\n\t    return\n\t  }\n\n\t  // Save the original host before any redirect (if it changes, we need to\n\t  // remove any authorization headers).  Also remember the case of the header\n\t  // name because lots of broken servers expect Host instead of host and we\n\t  // want the caller to be able to specify this.\n\t  self.originalHost = self.getHeader('host')\n\t  if (!self.originalHostHeaderName) {\n\t    self.originalHostHeaderName = self.hasHeader('host')\n\t  }\n\t  if (self.setHost) {\n\t    self.removeHeader('host')\n\t  }\n\t  self.clearTimeout()\n\n\t  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n\t  var addCookie = function (cookie) {\n\t    // set the cookie if it's domain in the href's domain.\n\t    try {\n\t      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n\t    } catch (e) {\n\t      self.emit('error', e)\n\t    }\n\t  }\n\n\t  response.caseless = caseless(response.headers)\n\n\t  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n\t    var headerName = response.caseless.has('set-cookie')\n\t    if (Array.isArray(response.headers[headerName])) {\n\t      response.headers[headerName].forEach(addCookie)\n\t    } else {\n\t      addCookie(response.headers[headerName])\n\t    }\n\t  }\n\n\t  if (self._redirect.onResponse(response)) {\n\t    return // Ignore the rest of the response\n\t  } else {\n\t    // Be a good stream and emit end when the response is finished.\n\t    // Hack to emit end on close because of a core bug that never fires end\n\t    response.on('close', function () {\n\t      if (!self._ended) {\n\t        self.response.emit('end')\n\t      }\n\t    })\n\n\t    response.once('end', function () {\n\t      self._ended = true\n\t    })\n\n\t    var noBody = function (code) {\n\t      return (\n\t        self.method === 'HEAD' ||\n\t        // Informational\n\t        (code >= 100 && code < 200) ||\n\t        // No Content\n\t        code === 204 ||\n\t        // Not Modified\n\t        code === 304\n\t      )\n\t    }\n\n\t    var responseContent\n\t    if (self.gzip && !noBody(response.statusCode)) {\n\t      var contentEncoding = response.headers['content-encoding'] || 'identity'\n\t      contentEncoding = contentEncoding.trim().toLowerCase()\n\n\t      // Be more lenient with decoding compressed responses, since (very rarely)\n\t      // servers send slightly invalid gzip responses that are still accepted\n\t      // by common browsers.\n\t      // Always using Z_SYNC_FLUSH is what cURL does.\n\t      var zlibOptions = {\n\t        flush: zlib.Z_SYNC_FLUSH,\n\t        finishFlush: zlib.Z_SYNC_FLUSH\n\t      }\n\n\t      if (contentEncoding === 'gzip') {\n\t        responseContent = zlib.createGunzip(zlibOptions)\n\t        response.pipe(responseContent)\n\t      } else if (contentEncoding === 'deflate') {\n\t        responseContent = zlib.createInflate(zlibOptions)\n\t        response.pipe(responseContent)\n\t      } else {\n\t        // Since previous versions didn't check for Content-Encoding header,\n\t        // ignore any invalid values to preserve backwards-compatibility\n\t        if (contentEncoding !== 'identity') {\n\t          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n\t        }\n\t        responseContent = response\n\t      }\n\t    } else {\n\t      responseContent = response\n\t    }\n\n\t    if (self.encoding) {\n\t      if (self.dests.length !== 0) {\n\t        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n\t      } else {\n\t        responseContent.setEncoding(self.encoding)\n\t      }\n\t    }\n\n\t    if (self._paused) {\n\t      responseContent.pause()\n\t    }\n\n\t    self.responseContent = responseContent\n\n\t    self.emit('response', response)\n\n\t    self.dests.forEach(function (dest) {\n\t      self.pipeDest(dest)\n\t    })\n\n\t    responseContent.on('data', function (chunk) {\n\t      if (self.timing && !self.responseStarted) {\n\t        self.responseStartTime = (new Date()).getTime()\n\n\t        // NOTE: responseStartTime is deprecated in favor of .timings\n\t        response.responseStartTime = self.responseStartTime\n\t      }\n\t      self._destdata = true\n\t      self.emit('data', chunk)\n\t    })\n\t    responseContent.once('end', function (chunk) {\n\t      self.emit('end', chunk)\n\t    })\n\t    responseContent.on('error', function (error) {\n\t      self.emit('error', error)\n\t    })\n\t    responseContent.on('close', function () { self.emit('close') })\n\n\t    if (self.callback) {\n\t      self.readResponseBody(response)\n\t    } else { // if no callback\n\t      self.on('end', function () {\n\t        if (self._aborted) {\n\t          debug('aborted', self.uri.href)\n\t          return\n\t        }\n\t        self.emit('complete', response)\n\t      })\n\t    }\n\t  }\n\t  debug('finish init function', self.uri.href)\n\t}\n\n\tRequest.prototype.readResponseBody = function (response) {\n\t  var self = this\n\t  debug(\"reading response's body\")\n\t  var buffers = []\n\t  var bufferLength = 0\n\t  var strings = []\n\n\t  self.on('data', function (chunk) {\n\t    if (!Buffer.isBuffer(chunk)) {\n\t      strings.push(chunk)\n\t    } else if (chunk.length) {\n\t      bufferLength += chunk.length\n\t      buffers.push(chunk)\n\t    }\n\t  })\n\t  self.on('end', function () {\n\t    debug('end event', self.uri.href)\n\t    if (self._aborted) {\n\t      debug('aborted', self.uri.href)\n\t      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n\t      // This can lead to leaky behavior if the user retains a reference to the request object.\n\t      buffers = []\n\t      bufferLength = 0\n\t      return\n\t    }\n\n\t    if (bufferLength) {\n\t      debug('has body', self.uri.href, bufferLength)\n\t      response.body = Buffer.concat(buffers, bufferLength)\n\t      if (self.encoding !== null) {\n\t        response.body = response.body.toString(self.encoding)\n\t      }\n\t      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n\t      // This can lead to leaky behavior if the user retains a reference to the request object.\n\t      buffers = []\n\t      bufferLength = 0\n\t    } else if (strings.length) {\n\t      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n\t      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n\t      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n\t        strings[0] = strings[0].substring(1)\n\t      }\n\t      response.body = strings.join('')\n\t    }\n\n\t    if (self._json) {\n\t      try {\n\t        response.body = JSON.parse(response.body, self._jsonReviver)\n\t      } catch (e) {\n\t        debug('invalid JSON received', self.uri.href)\n\t      }\n\t    }\n\t    debug('emitting complete', self.uri.href)\n\t    if (typeof response.body === 'undefined' && !self._json) {\n\t      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n\t    }\n\t    self.emit('complete', response, response.body)\n\t  })\n\t}\n\n\tRequest.prototype.abort = function () {\n\t  var self = this\n\t  self._aborted = true\n\n\t  if (self.req) {\n\t    self.req.abort()\n\t  } else if (self.response) {\n\t    self.response.destroy()\n\t  }\n\n\t  self.clearTimeout()\n\t  self.emit('abort')\n\t}\n\n\tRequest.prototype.pipeDest = function (dest) {\n\t  var self = this\n\t  var response = self.response\n\t  // Called after the response is received\n\t  if (dest.headers && !dest.headersSent) {\n\t    if (response.caseless.has('content-type')) {\n\t      var ctname = response.caseless.has('content-type')\n\t      if (dest.setHeader) {\n\t        dest.setHeader(ctname, response.headers[ctname])\n\t      } else {\n\t        dest.headers[ctname] = response.headers[ctname]\n\t      }\n\t    }\n\n\t    if (response.caseless.has('content-length')) {\n\t      var clname = response.caseless.has('content-length')\n\t      if (dest.setHeader) {\n\t        dest.setHeader(clname, response.headers[clname])\n\t      } else {\n\t        dest.headers[clname] = response.headers[clname]\n\t      }\n\t    }\n\t  }\n\t  if (dest.setHeader && !dest.headersSent) {\n\t    for (var i in response.headers) {\n\t      // If the response content is being decoded, the Content-Encoding header\n\t      // of the response doesn't represent the piped content, so don't pass it.\n\t      if (!self.gzip || i !== 'content-encoding') {\n\t        dest.setHeader(i, response.headers[i])\n\t      }\n\t    }\n\t    dest.statusCode = response.statusCode\n\t  }\n\t  if (self.pipefilter) {\n\t    self.pipefilter(response, dest)\n\t  }\n\t}\n\n\tRequest.prototype.qs = function (q, clobber) {\n\t  var self = this\n\t  var base\n\t  if (!clobber && self.uri.query) {\n\t    base = self._qs.parse(self.uri.query)\n\t  } else {\n\t    base = {}\n\t  }\n\n\t  for (var i in q) {\n\t    base[i] = q[i]\n\t  }\n\n\t  var qs = self._qs.stringify(base)\n\n\t  if (qs === '') {\n\t    return self\n\t  }\n\n\t  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n\t  self.url = self.uri\n\t  self.path = self.uri.path\n\n\t  if (self.uri.host === 'unix') {\n\t    self.enableUnixSocket()\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.form = function (form) {\n\t  var self = this\n\t  if (form) {\n\t    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n\t      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n\t    }\n\t    self.body = (typeof form === 'string')\n\t      ? self._qs.rfc3986(form.toString('utf8'))\n\t      : self._qs.stringify(form).toString('utf8')\n\t    return self\n\t  }\n\t  // create form-data object\n\t  self._form = new FormData()\n\t  self._form.on('error', function (err) {\n\t    err.message = 'form-data: ' + err.message\n\t    self.emit('error', err)\n\t    self.abort()\n\t  })\n\t  return self._form\n\t}\n\tRequest.prototype.multipart = function (multipart) {\n\t  var self = this\n\n\t  self._multipart.onRequest(multipart)\n\n\t  if (!self._multipart.chunked) {\n\t    self.body = self._multipart.body\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.json = function (val) {\n\t  var self = this\n\n\t  if (!self.hasHeader('accept')) {\n\t    self.setHeader('accept', 'application/json')\n\t  }\n\n\t  if (typeof self.jsonReplacer === 'function') {\n\t    self._jsonReplacer = self.jsonReplacer\n\t  }\n\n\t  self._json = true\n\t  if (typeof val === 'boolean') {\n\t    if (self.body !== undefined) {\n\t      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n\t        self.body = safeStringify(self.body, self._jsonReplacer)\n\t      } else {\n\t        self.body = self._qs.rfc3986(self.body)\n\t      }\n\t      if (!self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', 'application/json')\n\t      }\n\t    }\n\t  } else {\n\t    self.body = safeStringify(val, self._jsonReplacer)\n\t    if (!self.hasHeader('content-type')) {\n\t      self.setHeader('content-type', 'application/json')\n\t    }\n\t  }\n\n\t  if (typeof self.jsonReviver === 'function') {\n\t    self._jsonReviver = self.jsonReviver\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.getHeader = function (name, headers) {\n\t  var self = this\n\t  var result, re, match\n\t  if (!headers) {\n\t    headers = self.headers\n\t  }\n\t  Object.keys(headers).forEach(function (key) {\n\t    if (key.length !== name.length) {\n\t      return\n\t    }\n\t    re = new RegExp(name, 'i')\n\t    match = key.match(re)\n\t    if (match) {\n\t      result = headers[key]\n\t    }\n\t  })\n\t  return result\n\t}\n\tRequest.prototype.enableUnixSocket = function () {\n\t  // Get the socket & request paths from the URL\n\t  var unixParts = this.uri.path.split(':')\n\t  var host = unixParts[0]\n\t  var path = unixParts[1]\n\t  // Apply unix properties to request\n\t  this.socketPath = host\n\t  this.uri.pathname = path\n\t  this.uri.path = path\n\t  this.uri.host = host\n\t  this.uri.hostname = host\n\t  this.uri.isUnix = true\n\t}\n\n\tRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n\t  var self = this\n\n\t  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n\t  return self\n\t}\n\tRequest.prototype.aws = function (opts, now) {\n\t  var self = this\n\n\t  if (!now) {\n\t    self._aws = opts\n\t    return self\n\t  }\n\n\t  if (opts.sign_version === 4 || opts.sign_version === '4') {\n\t    // use aws4\n\t    var options = {\n\t      host: self.uri.host,\n\t      path: self.uri.path,\n\t      method: self.method,\n\t      headers: self.headers,\n\t      body: self.body\n\t    }\n\t    if (opts.service) {\n\t      options.service = opts.service\n\t    }\n\t    var signRes = aws4.sign(options, {\n\t      accessKeyId: opts.key,\n\t      secretAccessKey: opts.secret,\n\t      sessionToken: opts.session\n\t    })\n\t    self.setHeader('authorization', signRes.headers.Authorization)\n\t    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n\t    if (signRes.headers['X-Amz-Security-Token']) {\n\t      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n\t    }\n\t  } else {\n\t    // default: use aws-sign2\n\t    var date = new Date()\n\t    self.setHeader('date', date.toUTCString())\n\t    var auth = {\n\t      key: opts.key,\n\t      secret: opts.secret,\n\t      verb: self.method.toUpperCase(),\n\t      date: date,\n\t      contentType: self.getHeader('content-type') || '',\n\t      md5: self.getHeader('content-md5') || '',\n\t      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n\t    }\n\t    var path = self.uri.path\n\t    if (opts.bucket && path) {\n\t      auth.resource = '/' + opts.bucket + path\n\t    } else if (opts.bucket && !path) {\n\t      auth.resource = '/' + opts.bucket\n\t    } else if (!opts.bucket && path) {\n\t      auth.resource = path\n\t    } else if (!opts.bucket && !path) {\n\t      auth.resource = '/'\n\t    }\n\t    auth.resource = aws2.canonicalizeResource(auth.resource)\n\t    self.setHeader('authorization', aws2.authorization(auth))\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.httpSignature = function (opts) {\n\t  var self = this\n\t  httpSignature.signRequest({\n\t    getHeader: function (header) {\n\t      return self.getHeader(header, self.headers)\n\t    },\n\t    setHeader: function (header, value) {\n\t      self.setHeader(header, value)\n\t    },\n\t    method: self.method,\n\t    path: self.path\n\t  }, opts)\n\t  debug('httpSignature authorization', self.getHeader('authorization'))\n\n\t  return self\n\t}\n\tRequest.prototype.hawk = function (opts) {\n\t  var self = this\n\t  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n\t}\n\tRequest.prototype.oauth = function (_oauth) {\n\t  var self = this\n\n\t  self._oauth.onRequest(_oauth)\n\n\t  return self\n\t}\n\n\tRequest.prototype.jar = function (jar) {\n\t  var self = this\n\t  var cookies\n\n\t  if (self._redirect.redirectsFollowed === 0) {\n\t    self.originalCookieHeader = self.getHeader('cookie')\n\t  }\n\n\t  if (!jar) {\n\t    // disable cookies\n\t    cookies = false\n\t    self._disableCookies = true\n\t  } else {\n\t    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n\t    var urihref = self.uri.href\n\t    // fetch cookie in the Specified host\n\t    if (targetCookieJar) {\n\t      cookies = targetCookieJar.getCookieString(urihref)\n\t    }\n\t  }\n\n\t  // if need cookie and cookie is not empty\n\t  if (cookies && cookies.length) {\n\t    if (self.originalCookieHeader) {\n\t      // Don't overwrite existing Cookie header\n\t      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n\t    } else {\n\t      self.setHeader('cookie', cookies)\n\t    }\n\t  }\n\t  self._jar = jar\n\t  return self\n\t}\n\n\t// Stream API\n\tRequest.prototype.pipe = function (dest, opts) {\n\t  var self = this\n\n\t  if (self.response) {\n\t    if (self._destdata) {\n\t      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n\t    } else if (self._ended) {\n\t      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n\t    } else {\n\t      stream.Stream.prototype.pipe.call(self, dest, opts)\n\t      self.pipeDest(dest)\n\t      return dest\n\t    }\n\t  } else {\n\t    self.dests.push(dest)\n\t    stream.Stream.prototype.pipe.call(self, dest, opts)\n\t    return dest\n\t  }\n\t}\n\tRequest.prototype.write = function () {\n\t  var self = this\n\t  if (self._aborted) { return }\n\n\t  if (!self._started) {\n\t    self.start()\n\t  }\n\t  if (self.req) {\n\t    return self.req.write.apply(self.req, arguments)\n\t  }\n\t}\n\tRequest.prototype.end = function (chunk) {\n\t  var self = this\n\t  if (self._aborted) { return }\n\n\t  if (chunk) {\n\t    self.write(chunk)\n\t  }\n\t  if (!self._started) {\n\t    self.start()\n\t  }\n\t  if (self.req) {\n\t    self.req.end()\n\t  }\n\t}\n\tRequest.prototype.pause = function () {\n\t  var self = this\n\t  if (!self.responseContent) {\n\t    self._paused = true\n\t  } else {\n\t    self.responseContent.pause.apply(self.responseContent, arguments)\n\t  }\n\t}\n\tRequest.prototype.resume = function () {\n\t  var self = this\n\t  if (!self.responseContent) {\n\t    self._paused = false\n\t  } else {\n\t    self.responseContent.resume.apply(self.responseContent, arguments)\n\t  }\n\t}\n\tRequest.prototype.destroy = function () {\n\t  var self = this\n\t  this.clearTimeout()\n\t  if (!self._ended) {\n\t    self.end()\n\t  } else if (self.response) {\n\t    self.response.destroy()\n\t  }\n\t}\n\n\tRequest.prototype.clearTimeout = function () {\n\t  if (this.timeoutTimer) {\n\t    clearTimeout(this.timeoutTimer)\n\t    this.timeoutTimer = null\n\t  }\n\t}\n\n\tRequest.defaultProxyHeaderWhiteList =\n\t  Tunnel.defaultProxyHeaderWhiteList.slice()\n\n\tRequest.defaultProxyHeaderExclusiveList =\n\t  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n\t// Exports\n\n\tRequest.prototype.toJSON = requestToJSON\n\trequest = Request\n\treturn request;\n}\n\nexport { requireRequest as __require };","start":1667202704400,"end":1667202708035,"order":"normal"},{"name":"node-polyfills","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport require$$2 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$3 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/util/util.js?commonjs-wrapped\";\nimport require$$4 from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/rollup-plugin-node-polyfills/polyfills/stream.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000__vite-browser-external?commonjs-proxy\";\nimport { __require as require$$6 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws-sign2/index.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/aws4/aws4.js?commonjs-wrapped\";\nimport { __require as require$$8 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/http-signature/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$9 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/mime-types/index.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/caseless/index.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/forever-agent/index.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/form-data/lib/browser.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/extend/index.js?commonjs-wrapped\";\nimport { __require as require$$14 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/isstream/isstream.js?commonjs-wrapped\";\nimport { __require as require$$15 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/is-typedarray/index.js?commonjs-wrapped\";\nimport { __require as require$$16 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/helpers.js?commonjs-wrapped\";\nimport { __require as require$$17 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/cookies.js?commonjs-wrapped\";\nimport { __require as require$$18 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/getProxyFromURI.js?commonjs-wrapped\";\nimport { __require as require$$19 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/querystring.js?commonjs-wrapped\";\nimport { __require as require$$20 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/har.js?commonjs-wrapped\";\nimport { __require as require$$21 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/auth.js?commonjs-wrapped\";\nimport { __require as require$$22 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/oauth.js?commonjs-wrapped\";\nimport { __require as require$$23 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/hawk.js?commonjs-wrapped\";\nimport { __require as require$$24 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/multipart.js?commonjs-wrapped\";\nimport { __require as require$$25 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/redirect.js?commonjs-wrapped\";\nimport { __require as require$$26 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/request/lib/tunnel.js?commonjs-wrapped\";\nimport { __require as require$$27 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/performance-now/lib/performance-now.js?commonjs-wrapped\";\nimport { __require as require$$28 } from \"\\u0000C:/chohbin/Fhir-Test-Web/node_modules/safe-buffer/index.js?commonjs-wrapped\";\n\nvar request;\nvar hasRequiredRequest;\n\nfunction requireRequest () {\n\tif (hasRequiredRequest) return request;\n\thasRequiredRequest = 1;\n\t'use strict'\n\n\tvar http = require$$0\n\tvar https = require$$1\n\tvar url = require$$2\n\tvar util = require$$3()\n\tvar stream = require$$4\n\tvar zlib = require$$5\n\tvar aws2 = require$$6()\n\tvar aws4 = require$$7()\n\tvar httpSignature = require$$8()\n\tvar mime = require$$9()\n\tvar caseless = require$$10()\n\tvar ForeverAgent = require$$11()\n\tvar FormData = require$$12()\n\tvar extend = require$$13()\n\tvar isstream = require$$14()\n\tvar isTypedArray = require$$15().strict\n\tvar helpers = require$$16()\n\tvar cookies = require$$17()\n\tvar getProxyFromURI = require$$18()\n\tvar Querystring = require$$19().Querystring\n\tvar Har = require$$20().Har\n\tvar Auth = require$$21().Auth\n\tvar OAuth = require$$22().OAuth\n\tvar hawk = require$$23()\n\tvar Multipart = require$$24().Multipart\n\tvar Redirect = require$$25().Redirect\n\tvar Tunnel = require$$26().Tunnel\n\tvar now = require$$27()\n\tvar Buffer = require$$28().Buffer\n\n\tvar safeStringify = helpers.safeStringify\n\tvar isReadStream = helpers.isReadStream\n\tvar toBase64 = helpers.toBase64\n\tvar defer = helpers.defer\n\tvar copy = helpers.copy\n\tvar version = helpers.version\n\tvar globalCookieJar = cookies.jar()\n\n\tvar globalPool = {}\n\n\tfunction filterForNonReserved (reserved, options) {\n\t  // Filter out properties that are not reserved.\n\t  // Reserved values are passed in at call site.\n\n\t  var object = {}\n\t  for (var i in options) {\n\t    var notReserved = (reserved.indexOf(i) === -1)\n\t    if (notReserved) {\n\t      object[i] = options[i]\n\t    }\n\t  }\n\t  return object\n\t}\n\n\tfunction filterOutReservedFunctions (reserved, options) {\n\t  // Filter out properties that are functions and are reserved.\n\t  // Reserved values are passed in at call site.\n\n\t  var object = {}\n\t  for (var i in options) {\n\t    var isReserved = !(reserved.indexOf(i) === -1)\n\t    var isFunction = (typeof options[i] === 'function')\n\t    if (!(isReserved && isFunction)) {\n\t      object[i] = options[i]\n\t    }\n\t  }\n\t  return object\n\t}\n\n\t// Return a simpler request object to allow serialization\n\tfunction requestToJSON () {\n\t  var self = this\n\t  return {\n\t    uri: self.uri,\n\t    method: self.method,\n\t    headers: self.headers\n\t  }\n\t}\n\n\t// Return a simpler response object to allow serialization\n\tfunction responseToJSON () {\n\t  var self = this\n\t  return {\n\t    statusCode: self.statusCode,\n\t    body: self.body,\n\t    headers: self.headers,\n\t    request: requestToJSON.call(self.request)\n\t  }\n\t}\n\n\tfunction Request (options) {\n\t  // if given the method property in options, set property explicitMethod to true\n\n\t  // extend the Request instance with any non-reserved properties\n\t  // remove any reserved functions from the options object\n\t  // set Request instance to be readable and writable\n\t  // call init\n\n\t  var self = this\n\n\t  // start with HAR, then override with additional options\n\t  if (options.har) {\n\t    self._har = new Har(self)\n\t    options = self._har.options(options)\n\t  }\n\n\t  stream.Stream.call(self)\n\t  var reserved = Object.keys(Request.prototype)\n\t  var nonReserved = filterForNonReserved(reserved, options)\n\n\t  extend(self, nonReserved)\n\t  options = filterOutReservedFunctions(reserved, options)\n\n\t  self.readable = true\n\t  self.writable = true\n\t  if (options.method) {\n\t    self.explicitMethod = true\n\t  }\n\t  self._qs = new Querystring(self)\n\t  self._auth = new Auth(self)\n\t  self._oauth = new OAuth(self)\n\t  self._multipart = new Multipart(self)\n\t  self._redirect = new Redirect(self)\n\t  self._tunnel = new Tunnel(self)\n\t  self.init(options)\n\t}\n\n\tutil.inherits(Request, stream.Stream)\n\n\t// Debugging\n\tRequest.debug = {}.NODE_DEBUG && /\\brequest\\b/.test({}.NODE_DEBUG)\n\tfunction debug () {\n\t  if (Request.debug) {\n\t    console.error('REQUEST %s', util.format.apply(util, arguments))\n\t  }\n\t}\n\tRequest.prototype.debug = debug\n\n\tRequest.prototype.init = function (options) {\n\t  // init() contains all the code to setup the request object.\n\t  // the actual outgoing request is not started until start() is called\n\t  // this function is called from both the constructor and on redirect.\n\t  var self = this\n\t  if (!options) {\n\t    options = {}\n\t  }\n\t  self.headers = self.headers ? copy(self.headers) : {}\n\n\t  // Delete headers with value undefined since they break\n\t  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n\t  for (var headerName in self.headers) {\n\t    if (typeof self.headers[headerName] === 'undefined') {\n\t      delete self.headers[headerName]\n\t    }\n\t  }\n\n\t  caseless.httpify(self, self.headers)\n\n\t  if (!self.method) {\n\t    self.method = options.method || 'GET'\n\t  }\n\t  if (!self.localAddress) {\n\t    self.localAddress = options.localAddress\n\t  }\n\n\t  self._qs.init(options)\n\n\t  debug(options)\n\t  if (!self.pool && self.pool !== false) {\n\t    self.pool = globalPool\n\t  }\n\t  self.dests = self.dests || []\n\t  self.__isRequestRequest = true\n\n\t  // Protect against double callback\n\t  if (!self._callback && self.callback) {\n\t    self._callback = self.callback\n\t    self.callback = function () {\n\t      if (self._callbackCalled) {\n\t        return // Print a warning maybe?\n\t      }\n\t      self._callbackCalled = true\n\t      self._callback.apply(self, arguments)\n\t    }\n\t    self.on('error', self.callback.bind())\n\t    self.on('complete', self.callback.bind(self, null))\n\t  }\n\n\t  // People use this property instead all the time, so support it\n\t  if (!self.uri && self.url) {\n\t    self.uri = self.url\n\t    delete self.url\n\t  }\n\n\t  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n\t  // specified as a relative path and is appended to baseUrl).\n\t  if (self.baseUrl) {\n\t    if (typeof self.baseUrl !== 'string') {\n\t      return self.emit('error', new Error('options.baseUrl must be a string'))\n\t    }\n\n\t    if (typeof self.uri !== 'string') {\n\t      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n\t    }\n\n\t    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n\t      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n\t    }\n\n\t    // Handle all cases to make sure that there's only one slash between\n\t    // baseUrl and uri.\n\t    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n\t    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n\t    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n\t      self.uri = self.baseUrl + self.uri.slice(1)\n\t    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n\t      self.uri = self.baseUrl + self.uri\n\t    } else if (self.uri === '') {\n\t      self.uri = self.baseUrl\n\t    } else {\n\t      self.uri = self.baseUrl + '/' + self.uri\n\t    }\n\t    delete self.baseUrl\n\t  }\n\n\t  // A URI is needed by this point, emit error if we haven't been able to get one\n\t  if (!self.uri) {\n\t    return self.emit('error', new Error('options.uri is a required argument'))\n\t  }\n\n\t  // If a string URI/URL was given, parse it into a URL object\n\t  if (typeof self.uri === 'string') {\n\t    self.uri = url.parse(self.uri)\n\t  }\n\n\t  // Some URL objects are not from a URL parsed string and need href added\n\t  if (!self.uri.href) {\n\t    self.uri.href = url.format(self.uri)\n\t  }\n\n\t  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n\t  if (self.uri.protocol === 'unix:') {\n\t    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n\t  }\n\n\t  // Support Unix Sockets\n\t  if (self.uri.host === 'unix') {\n\t    self.enableUnixSocket()\n\t  }\n\n\t  if (self.strictSSL === false) {\n\t    self.rejectUnauthorized = false\n\t  }\n\n\t  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n\t  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n\t    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n\t    // Detect and reject it as soon as possible\n\t    var faultyUri = url.format(self.uri)\n\t    var message = 'Invalid URI \"' + faultyUri + '\"'\n\t    if (Object.keys(options).length === 0) {\n\t      // No option ? This can be the sign of a redirect\n\t      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n\t      // they should be warned that it can be caused by a redirection (can save some hair)\n\t      message += '. This can be caused by a crappy redirection.'\n\t    }\n\t    // This error was fatal\n\t    self.abort()\n\t    return self.emit('error', new Error(message))\n\t  }\n\n\t  if (!self.hasOwnProperty('proxy')) {\n\t    self.proxy = getProxyFromURI(self.uri)\n\t  }\n\n\t  self.tunnel = self._tunnel.isEnabled()\n\t  if (self.proxy) {\n\t    self._tunnel.setup(options)\n\t  }\n\n\t  self._redirect.onRequest(options)\n\n\t  self.setHost = false\n\t  if (!self.hasHeader('host')) {\n\t    var hostHeaderName = self.originalHostHeaderName || 'host'\n\t    self.setHeader(hostHeaderName, self.uri.host)\n\t    // Drop :port suffix from Host header if known protocol.\n\t    if (self.uri.port) {\n\t      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n\t          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n\t        self.setHeader(hostHeaderName, self.uri.hostname)\n\t      }\n\t    }\n\t    self.setHost = true\n\t  }\n\n\t  self.jar(self._jar || options.jar)\n\n\t  if (!self.uri.port) {\n\t    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n\t  }\n\n\t  if (self.proxy && !self.tunnel) {\n\t    self.port = self.proxy.port\n\t    self.host = self.proxy.hostname\n\t  } else {\n\t    self.port = self.uri.port\n\t    self.host = self.uri.hostname\n\t  }\n\n\t  if (options.form) {\n\t    self.form(options.form)\n\t  }\n\n\t  if (options.formData) {\n\t    var formData = options.formData\n\t    var requestForm = self.form()\n\t    var appendFormValue = function (key, value) {\n\t      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n\t        requestForm.append(key, value.value, value.options)\n\t      } else {\n\t        requestForm.append(key, value)\n\t      }\n\t    }\n\t    for (var formKey in formData) {\n\t      if (formData.hasOwnProperty(formKey)) {\n\t        var formValue = formData[formKey]\n\t        if (formValue instanceof Array) {\n\t          for (var j = 0; j < formValue.length; j++) {\n\t            appendFormValue(formKey, formValue[j])\n\t          }\n\t        } else {\n\t          appendFormValue(formKey, formValue)\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  if (options.qs) {\n\t    self.qs(options.qs)\n\t  }\n\n\t  if (self.uri.path) {\n\t    self.path = self.uri.path\n\t  } else {\n\t    self.path = self.uri.pathname + (self.uri.search || '')\n\t  }\n\n\t  if (self.path.length === 0) {\n\t    self.path = '/'\n\t  }\n\n\t  // Auth must happen last in case signing is dependent on other headers\n\t  if (options.aws) {\n\t    self.aws(options.aws)\n\t  }\n\n\t  if (options.hawk) {\n\t    self.hawk(options.hawk)\n\t  }\n\n\t  if (options.httpSignature) {\n\t    self.httpSignature(options.httpSignature)\n\t  }\n\n\t  if (options.auth) {\n\t    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n\t      options.auth.user = options.auth.username\n\t    }\n\t    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n\t      options.auth.pass = options.auth.password\n\t    }\n\n\t    self.auth(\n\t      options.auth.user,\n\t      options.auth.pass,\n\t      options.auth.sendImmediately,\n\t      options.auth.bearer\n\t    )\n\t  }\n\n\t  if (self.gzip && !self.hasHeader('accept-encoding')) {\n\t    self.setHeader('accept-encoding', 'gzip, deflate')\n\t  }\n\n\t  if (self.uri.auth && !self.hasHeader('authorization')) {\n\t    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n\t    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n\t  }\n\n\t  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n\t    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n\t    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n\t    self.setHeader('proxy-authorization', authHeader)\n\t  }\n\n\t  if (self.proxy && !self.tunnel) {\n\t    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n\t  }\n\n\t  if (options.json) {\n\t    self.json(options.json)\n\t  }\n\t  if (options.multipart) {\n\t    self.multipart(options.multipart)\n\t  }\n\n\t  if (options.time) {\n\t    self.timing = true\n\n\t    // NOTE: elapsedTime is deprecated in favor of .timings\n\t    self.elapsedTime = self.elapsedTime || 0\n\t  }\n\n\t  function setContentLength () {\n\t    if (isTypedArray(self.body)) {\n\t      self.body = Buffer.from(self.body)\n\t    }\n\n\t    if (!self.hasHeader('content-length')) {\n\t      var length\n\t      if (typeof self.body === 'string') {\n\t        length = Buffer.byteLength(self.body)\n\t      } else if (Array.isArray(self.body)) {\n\t        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n\t      } else {\n\t        length = self.body.length\n\t      }\n\n\t      if (length) {\n\t        self.setHeader('content-length', length)\n\t      } else {\n\t        self.emit('error', new Error('Argument error, options.body.'))\n\t      }\n\t    }\n\t  }\n\t  if (self.body && !isstream(self.body)) {\n\t    setContentLength()\n\t  }\n\n\t  if (options.oauth) {\n\t    self.oauth(options.oauth)\n\t  } else if (self._oauth.params && self.hasHeader('authorization')) {\n\t    self.oauth(self._oauth.params)\n\t  }\n\n\t  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n\t  var defaultModules = {'http:': http, 'https:': https}\n\t  var httpModules = self.httpModules || {}\n\n\t  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n\t  if (!self.httpModule) {\n\t    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n\t  }\n\n\t  if (options.ca) {\n\t    self.ca = options.ca\n\t  }\n\n\t  if (!self.agent) {\n\t    if (options.agentOptions) {\n\t      self.agentOptions = options.agentOptions\n\t    }\n\n\t    if (options.agentClass) {\n\t      self.agentClass = options.agentClass\n\t    } else if (options.forever) {\n\t      var v = version()\n\t      // use ForeverAgent in node 0.10- only\n\t      if (v.major === 0 && v.minor <= 10) {\n\t        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n\t      } else {\n\t        self.agentClass = self.httpModule.Agent\n\t        self.agentOptions = self.agentOptions || {}\n\t        self.agentOptions.keepAlive = true\n\t      }\n\t    } else {\n\t      self.agentClass = self.httpModule.Agent\n\t    }\n\t  }\n\n\t  if (self.pool === false) {\n\t    self.agent = false\n\t  } else {\n\t    self.agent = self.agent || self.getNewAgent()\n\t  }\n\n\t  self.on('pipe', function (src) {\n\t    if (self.ntick && self._started) {\n\t      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n\t    }\n\t    self.src = src\n\t    if (isReadStream(src)) {\n\t      if (!self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', mime.lookup(src.path))\n\t      }\n\t    } else {\n\t      if (src.headers) {\n\t        for (var i in src.headers) {\n\t          if (!self.hasHeader(i)) {\n\t            self.setHeader(i, src.headers[i])\n\t          }\n\t        }\n\t      }\n\t      if (self._json && !self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', 'application/json')\n\t      }\n\t      if (src.method && !self.explicitMethod) {\n\t        self.method = src.method\n\t      }\n\t    }\n\n\t  // self.on('pipe', function () {\n\t  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n\t  // })\n\t  })\n\n\t  defer(function () {\n\t    if (self._aborted) {\n\t      return\n\t    }\n\n\t    var end = function () {\n\t      if (self._form) {\n\t        if (!self._auth.hasAuth) {\n\t          self._form.pipe(self)\n\t        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n\t          self._form.pipe(self)\n\t        }\n\t      }\n\t      if (self._multipart && self._multipart.chunked) {\n\t        self._multipart.body.pipe(self)\n\t      }\n\t      if (self.body) {\n\t        if (isstream(self.body)) {\n\t          self.body.pipe(self)\n\t        } else {\n\t          setContentLength()\n\t          if (Array.isArray(self.body)) {\n\t            self.body.forEach(function (part) {\n\t              self.write(part)\n\t            })\n\t          } else {\n\t            self.write(self.body)\n\t          }\n\t          self.end()\n\t        }\n\t      } else if (self.requestBodyStream) {\n\t        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n\t        self.requestBodyStream.pipe(self)\n\t      } else if (!self.src) {\n\t        if (self._auth.hasAuth && !self._auth.sentAuth) {\n\t          self.end()\n\t          return\n\t        }\n\t        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n\t          self.setHeader('content-length', 0)\n\t        }\n\t        self.end()\n\t      }\n\t    }\n\n\t    if (self._form && !self.hasHeader('content-length')) {\n\t      // Before ending the request, we had to compute the length of the whole form, asyncly\n\t      self.setHeader(self._form.getHeaders(), true)\n\t      self._form.getLength(function (err, length) {\n\t        if (!err && !isNaN(length)) {\n\t          self.setHeader('content-length', length)\n\t        }\n\t        end()\n\t      })\n\t    } else {\n\t      end()\n\t    }\n\n\t    self.ntick = true\n\t  })\n\t}\n\n\tRequest.prototype.getNewAgent = function () {\n\t  var self = this\n\t  var Agent = self.agentClass\n\t  var options = {}\n\t  if (self.agentOptions) {\n\t    for (var i in self.agentOptions) {\n\t      options[i] = self.agentOptions[i]\n\t    }\n\t  }\n\t  if (self.ca) {\n\t    options.ca = self.ca\n\t  }\n\t  if (self.ciphers) {\n\t    options.ciphers = self.ciphers\n\t  }\n\t  if (self.secureProtocol) {\n\t    options.secureProtocol = self.secureProtocol\n\t  }\n\t  if (self.secureOptions) {\n\t    options.secureOptions = self.secureOptions\n\t  }\n\t  if (typeof self.rejectUnauthorized !== 'undefined') {\n\t    options.rejectUnauthorized = self.rejectUnauthorized\n\t  }\n\n\t  if (self.cert && self.key) {\n\t    options.key = self.key\n\t    options.cert = self.cert\n\t  }\n\n\t  if (self.pfx) {\n\t    options.pfx = self.pfx\n\t  }\n\n\t  if (self.passphrase) {\n\t    options.passphrase = self.passphrase\n\t  }\n\n\t  var poolKey = ''\n\n\t  // different types of agents are in different pools\n\t  if (Agent !== self.httpModule.Agent) {\n\t    poolKey += Agent.name\n\t  }\n\n\t  // ca option is only relevant if proxy or destination are https\n\t  var proxy = self.proxy\n\t  if (typeof proxy === 'string') {\n\t    proxy = url.parse(proxy)\n\t  }\n\t  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n\t  if (isHttps) {\n\t    if (options.ca) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.ca\n\t    }\n\n\t    if (typeof options.rejectUnauthorized !== 'undefined') {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.rejectUnauthorized\n\t    }\n\n\t    if (options.cert) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n\t    }\n\n\t    if (options.pfx) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.pfx.toString('ascii')\n\t    }\n\n\t    if (options.ciphers) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.ciphers\n\t    }\n\n\t    if (options.secureProtocol) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.secureProtocol\n\t    }\n\n\t    if (options.secureOptions) {\n\t      if (poolKey) {\n\t        poolKey += ':'\n\t      }\n\t      poolKey += options.secureOptions\n\t    }\n\t  }\n\n\t  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n\t    // not doing anything special.  Use the globalAgent\n\t    return self.httpModule.globalAgent\n\t  }\n\n\t  // we're using a stored agent.  Make sure it's protocol-specific\n\t  poolKey = self.uri.protocol + poolKey\n\n\t  // generate a new agent for this setting if none yet exists\n\t  if (!self.pool[poolKey]) {\n\t    self.pool[poolKey] = new Agent(options)\n\t    // properly set maxSockets on new agents\n\t    if (self.pool.maxSockets) {\n\t      self.pool[poolKey].maxSockets = self.pool.maxSockets\n\t    }\n\t  }\n\n\t  return self.pool[poolKey]\n\t}\n\n\tRequest.prototype.start = function () {\n\t  // start() is called once we are ready to send the outgoing HTTP request.\n\t  // this is usually called on the first write(), end() or on nextTick()\n\t  var self = this\n\n\t  if (self.timing) {\n\t    // All timings will be relative to this request's startTime.  In order to do this,\n\t    // we need to capture the wall-clock start time (via Date), immediately followed\n\t    // by the high-resolution timer (via now()).  While these two won't be set\n\t    // at the _exact_ same time, they should be close enough to be able to calculate\n\t    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n\t    var startTime = new Date().getTime()\n\t    var startTimeNow = now()\n\t  }\n\n\t  if (self._aborted) {\n\t    return\n\t  }\n\n\t  self._started = true\n\t  self.method = self.method || 'GET'\n\t  self.href = self.uri.href\n\n\t  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n\t    self.setHeader('content-length', self.src.stat.size)\n\t  }\n\t  if (self._aws) {\n\t    self.aws(self._aws, true)\n\t  }\n\n\t  // We have a method named auth, which is completely different from the http.request\n\t  // auth option.  If we don't remove it, we're gonna have a bad time.\n\t  var reqOptions = copy(self)\n\t  delete reqOptions.auth\n\n\t  debug('make request', self.uri.href)\n\n\t  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n\t  // should delete it for now since we handle timeouts manually for better\n\t  // consistency with node versions before v6.8.0\n\t  delete reqOptions.timeout\n\n\t  try {\n\t    self.req = self.httpModule.request(reqOptions)\n\t  } catch (err) {\n\t    self.emit('error', err)\n\t    return\n\t  }\n\n\t  if (self.timing) {\n\t    self.startTime = startTime\n\t    self.startTimeNow = startTimeNow\n\n\t    // Timing values will all be relative to startTime (by comparing to startTimeNow\n\t    // so we have an accurate clock)\n\t    self.timings = {}\n\t  }\n\n\t  var timeout\n\t  if (self.timeout && !self.timeoutTimer) {\n\t    if (self.timeout < 0) {\n\t      timeout = 0\n\t    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n\t      timeout = self.timeout\n\t    }\n\t  }\n\n\t  self.req.on('response', self.onRequestResponse.bind(self))\n\t  self.req.on('error', self.onRequestError.bind(self))\n\t  self.req.on('drain', function () {\n\t    self.emit('drain')\n\t  })\n\n\t  self.req.on('socket', function (socket) {\n\t    // `._connecting` was the old property which was made public in node v6.1.0\n\t    var isConnecting = socket._connecting || socket.connecting\n\t    if (self.timing) {\n\t      self.timings.socket = now() - self.startTimeNow\n\n\t      if (isConnecting) {\n\t        var onLookupTiming = function () {\n\t          self.timings.lookup = now() - self.startTimeNow\n\t        }\n\n\t        var onConnectTiming = function () {\n\t          self.timings.connect = now() - self.startTimeNow\n\t        }\n\n\t        socket.once('lookup', onLookupTiming)\n\t        socket.once('connect', onConnectTiming)\n\n\t        // clean up timing event listeners if needed on error\n\t        self.req.once('error', function () {\n\t          socket.removeListener('lookup', onLookupTiming)\n\t          socket.removeListener('connect', onConnectTiming)\n\t        })\n\t      }\n\t    }\n\n\t    var setReqTimeout = function () {\n\t      // This timeout sets the amount of time to wait *between* bytes sent\n\t      // from the server once connected.\n\t      //\n\t      // In particular, it's useful for erroring if the server fails to send\n\t      // data halfway through streaming a response.\n\t      self.req.setTimeout(timeout, function () {\n\t        if (self.req) {\n\t          self.abort()\n\t          var e = new Error('ESOCKETTIMEDOUT')\n\t          e.code = 'ESOCKETTIMEDOUT'\n\t          e.connect = false\n\t          self.emit('error', e)\n\t        }\n\t      })\n\t    }\n\t    if (timeout !== undefined) {\n\t      // Only start the connection timer if we're actually connecting a new\n\t      // socket, otherwise if we're already connected (because this is a\n\t      // keep-alive connection) do not bother. This is important since we won't\n\t      // get a 'connect' event for an already connected socket.\n\t      if (isConnecting) {\n\t        var onReqSockConnect = function () {\n\t          socket.removeListener('connect', onReqSockConnect)\n\t          self.clearTimeout()\n\t          setReqTimeout()\n\t        }\n\n\t        socket.on('connect', onReqSockConnect)\n\n\t        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n\t          socket.removeListener('connect', onReqSockConnect)\n\t        })\n\n\t        // Set a timeout in memory - this block will throw if the server takes more\n\t        // than `timeout` to write the HTTP status and headers (corresponding to\n\t        // the on('response') event on the client). NB: this measures wall-clock\n\t        // time, not the time between bytes sent by the server.\n\t        self.timeoutTimer = setTimeout(function () {\n\t          socket.removeListener('connect', onReqSockConnect)\n\t          self.abort()\n\t          var e = new Error('ETIMEDOUT')\n\t          e.code = 'ETIMEDOUT'\n\t          e.connect = true\n\t          self.emit('error', e)\n\t        }, timeout)\n\t      } else {\n\t        // We're already connected\n\t        setReqTimeout()\n\t      }\n\t    }\n\t    self.emit('socket', socket)\n\t  })\n\n\t  self.emit('request', self.req)\n\t}\n\n\tRequest.prototype.onRequestError = function (error) {\n\t  var self = this\n\t  if (self._aborted) {\n\t    return\n\t  }\n\t  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n\t    self.agent.addRequestNoreuse) {\n\t    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n\t    self.start()\n\t    self.req.end()\n\t    return\n\t  }\n\t  self.clearTimeout()\n\t  self.emit('error', error)\n\t}\n\n\tRequest.prototype.onRequestResponse = function (response) {\n\t  var self = this\n\n\t  if (self.timing) {\n\t    self.timings.response = now() - self.startTimeNow\n\t  }\n\n\t  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n\t  response.on('end', function () {\n\t    if (self.timing) {\n\t      self.timings.end = now() - self.startTimeNow\n\t      response.timingStart = self.startTime\n\n\t      // fill in the blanks for any periods that didn't trigger, such as\n\t      // no lookup or connect due to keep alive\n\t      if (!self.timings.socket) {\n\t        self.timings.socket = 0\n\t      }\n\t      if (!self.timings.lookup) {\n\t        self.timings.lookup = self.timings.socket\n\t      }\n\t      if (!self.timings.connect) {\n\t        self.timings.connect = self.timings.lookup\n\t      }\n\t      if (!self.timings.response) {\n\t        self.timings.response = self.timings.connect\n\t      }\n\n\t      debug('elapsed time', self.timings.end)\n\n\t      // elapsedTime includes all redirects\n\t      self.elapsedTime += Math.round(self.timings.end)\n\n\t      // NOTE: elapsedTime is deprecated in favor of .timings\n\t      response.elapsedTime = self.elapsedTime\n\n\t      // timings is just for the final fetch\n\t      response.timings = self.timings\n\n\t      // pre-calculate phase timings as well\n\t      response.timingPhases = {\n\t        wait: self.timings.socket,\n\t        dns: self.timings.lookup - self.timings.socket,\n\t        tcp: self.timings.connect - self.timings.lookup,\n\t        firstByte: self.timings.response - self.timings.connect,\n\t        download: self.timings.end - self.timings.response,\n\t        total: self.timings.end\n\t      }\n\t    }\n\t    debug('response end', self.uri.href, response.statusCode, response.headers)\n\t  })\n\n\t  if (self._aborted) {\n\t    debug('aborted', self.uri.href)\n\t    response.resume()\n\t    return\n\t  }\n\n\t  self.response = response\n\t  response.request = self\n\t  response.toJSON = responseToJSON\n\n\t  // XXX This is different on 0.10, because SSL is strict by default\n\t  if (self.httpModule === https &&\n\t    self.strictSSL && (!response.hasOwnProperty('socket') ||\n\t    !response.socket.authorized)) {\n\t    debug('strict ssl error', self.uri.href)\n\t    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n\t    self.emit('error', new Error('SSL Error: ' + sslErr))\n\t    return\n\t  }\n\n\t  // Save the original host before any redirect (if it changes, we need to\n\t  // remove any authorization headers).  Also remember the case of the header\n\t  // name because lots of broken servers expect Host instead of host and we\n\t  // want the caller to be able to specify this.\n\t  self.originalHost = self.getHeader('host')\n\t  if (!self.originalHostHeaderName) {\n\t    self.originalHostHeaderName = self.hasHeader('host')\n\t  }\n\t  if (self.setHost) {\n\t    self.removeHeader('host')\n\t  }\n\t  self.clearTimeout()\n\n\t  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n\t  var addCookie = function (cookie) {\n\t    // set the cookie if it's domain in the href's domain.\n\t    try {\n\t      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n\t    } catch (e) {\n\t      self.emit('error', e)\n\t    }\n\t  }\n\n\t  response.caseless = caseless(response.headers)\n\n\t  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n\t    var headerName = response.caseless.has('set-cookie')\n\t    if (Array.isArray(response.headers[headerName])) {\n\t      response.headers[headerName].forEach(addCookie)\n\t    } else {\n\t      addCookie(response.headers[headerName])\n\t    }\n\t  }\n\n\t  if (self._redirect.onResponse(response)) {\n\t    return // Ignore the rest of the response\n\t  } else {\n\t    // Be a good stream and emit end when the response is finished.\n\t    // Hack to emit end on close because of a core bug that never fires end\n\t    response.on('close', function () {\n\t      if (!self._ended) {\n\t        self.response.emit('end')\n\t      }\n\t    })\n\n\t    response.once('end', function () {\n\t      self._ended = true\n\t    })\n\n\t    var noBody = function (code) {\n\t      return (\n\t        self.method === 'HEAD' ||\n\t        // Informational\n\t        (code >= 100 && code < 200) ||\n\t        // No Content\n\t        code === 204 ||\n\t        // Not Modified\n\t        code === 304\n\t      )\n\t    }\n\n\t    var responseContent\n\t    if (self.gzip && !noBody(response.statusCode)) {\n\t      var contentEncoding = response.headers['content-encoding'] || 'identity'\n\t      contentEncoding = contentEncoding.trim().toLowerCase()\n\n\t      // Be more lenient with decoding compressed responses, since (very rarely)\n\t      // servers send slightly invalid gzip responses that are still accepted\n\t      // by common browsers.\n\t      // Always using Z_SYNC_FLUSH is what cURL does.\n\t      var zlibOptions = {\n\t        flush: zlib.Z_SYNC_FLUSH,\n\t        finishFlush: zlib.Z_SYNC_FLUSH\n\t      }\n\n\t      if (contentEncoding === 'gzip') {\n\t        responseContent = zlib.createGunzip(zlibOptions)\n\t        response.pipe(responseContent)\n\t      } else if (contentEncoding === 'deflate') {\n\t        responseContent = zlib.createInflate(zlibOptions)\n\t        response.pipe(responseContent)\n\t      } else {\n\t        // Since previous versions didn't check for Content-Encoding header,\n\t        // ignore any invalid values to preserve backwards-compatibility\n\t        if (contentEncoding !== 'identity') {\n\t          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n\t        }\n\t        responseContent = response\n\t      }\n\t    } else {\n\t      responseContent = response\n\t    }\n\n\t    if (self.encoding) {\n\t      if (self.dests.length !== 0) {\n\t        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n\t      } else {\n\t        responseContent.setEncoding(self.encoding)\n\t      }\n\t    }\n\n\t    if (self._paused) {\n\t      responseContent.pause()\n\t    }\n\n\t    self.responseContent = responseContent\n\n\t    self.emit('response', response)\n\n\t    self.dests.forEach(function (dest) {\n\t      self.pipeDest(dest)\n\t    })\n\n\t    responseContent.on('data', function (chunk) {\n\t      if (self.timing && !self.responseStarted) {\n\t        self.responseStartTime = (new Date()).getTime()\n\n\t        // NOTE: responseStartTime is deprecated in favor of .timings\n\t        response.responseStartTime = self.responseStartTime\n\t      }\n\t      self._destdata = true\n\t      self.emit('data', chunk)\n\t    })\n\t    responseContent.once('end', function (chunk) {\n\t      self.emit('end', chunk)\n\t    })\n\t    responseContent.on('error', function (error) {\n\t      self.emit('error', error)\n\t    })\n\t    responseContent.on('close', function () { self.emit('close') })\n\n\t    if (self.callback) {\n\t      self.readResponseBody(response)\n\t    } else { // if no callback\n\t      self.on('end', function () {\n\t        if (self._aborted) {\n\t          debug('aborted', self.uri.href)\n\t          return\n\t        }\n\t        self.emit('complete', response)\n\t      })\n\t    }\n\t  }\n\t  debug('finish init function', self.uri.href)\n\t}\n\n\tRequest.prototype.readResponseBody = function (response) {\n\t  var self = this\n\t  debug(\"reading response's body\")\n\t  var buffers = []\n\t  var bufferLength = 0\n\t  var strings = []\n\n\t  self.on('data', function (chunk) {\n\t    if (!Buffer.isBuffer(chunk)) {\n\t      strings.push(chunk)\n\t    } else if (chunk.length) {\n\t      bufferLength += chunk.length\n\t      buffers.push(chunk)\n\t    }\n\t  })\n\t  self.on('end', function () {\n\t    debug('end event', self.uri.href)\n\t    if (self._aborted) {\n\t      debug('aborted', self.uri.href)\n\t      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n\t      // This can lead to leaky behavior if the user retains a reference to the request object.\n\t      buffers = []\n\t      bufferLength = 0\n\t      return\n\t    }\n\n\t    if (bufferLength) {\n\t      debug('has body', self.uri.href, bufferLength)\n\t      response.body = Buffer.concat(buffers, bufferLength)\n\t      if (self.encoding !== null) {\n\t        response.body = response.body.toString(self.encoding)\n\t      }\n\t      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n\t      // This can lead to leaky behavior if the user retains a reference to the request object.\n\t      buffers = []\n\t      bufferLength = 0\n\t    } else if (strings.length) {\n\t      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n\t      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n\t      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n\t        strings[0] = strings[0].substring(1)\n\t      }\n\t      response.body = strings.join('')\n\t    }\n\n\t    if (self._json) {\n\t      try {\n\t        response.body = JSON.parse(response.body, self._jsonReviver)\n\t      } catch (e) {\n\t        debug('invalid JSON received', self.uri.href)\n\t      }\n\t    }\n\t    debug('emitting complete', self.uri.href)\n\t    if (typeof response.body === 'undefined' && !self._json) {\n\t      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n\t    }\n\t    self.emit('complete', response, response.body)\n\t  })\n\t}\n\n\tRequest.prototype.abort = function () {\n\t  var self = this\n\t  self._aborted = true\n\n\t  if (self.req) {\n\t    self.req.abort()\n\t  } else if (self.response) {\n\t    self.response.destroy()\n\t  }\n\n\t  self.clearTimeout()\n\t  self.emit('abort')\n\t}\n\n\tRequest.prototype.pipeDest = function (dest) {\n\t  var self = this\n\t  var response = self.response\n\t  // Called after the response is received\n\t  if (dest.headers && !dest.headersSent) {\n\t    if (response.caseless.has('content-type')) {\n\t      var ctname = response.caseless.has('content-type')\n\t      if (dest.setHeader) {\n\t        dest.setHeader(ctname, response.headers[ctname])\n\t      } else {\n\t        dest.headers[ctname] = response.headers[ctname]\n\t      }\n\t    }\n\n\t    if (response.caseless.has('content-length')) {\n\t      var clname = response.caseless.has('content-length')\n\t      if (dest.setHeader) {\n\t        dest.setHeader(clname, response.headers[clname])\n\t      } else {\n\t        dest.headers[clname] = response.headers[clname]\n\t      }\n\t    }\n\t  }\n\t  if (dest.setHeader && !dest.headersSent) {\n\t    for (var i in response.headers) {\n\t      // If the response content is being decoded, the Content-Encoding header\n\t      // of the response doesn't represent the piped content, so don't pass it.\n\t      if (!self.gzip || i !== 'content-encoding') {\n\t        dest.setHeader(i, response.headers[i])\n\t      }\n\t    }\n\t    dest.statusCode = response.statusCode\n\t  }\n\t  if (self.pipefilter) {\n\t    self.pipefilter(response, dest)\n\t  }\n\t}\n\n\tRequest.prototype.qs = function (q, clobber) {\n\t  var self = this\n\t  var base\n\t  if (!clobber && self.uri.query) {\n\t    base = self._qs.parse(self.uri.query)\n\t  } else {\n\t    base = {}\n\t  }\n\n\t  for (var i in q) {\n\t    base[i] = q[i]\n\t  }\n\n\t  var qs = self._qs.stringify(base)\n\n\t  if (qs === '') {\n\t    return self\n\t  }\n\n\t  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n\t  self.url = self.uri\n\t  self.path = self.uri.path\n\n\t  if (self.uri.host === 'unix') {\n\t    self.enableUnixSocket()\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.form = function (form) {\n\t  var self = this\n\t  if (form) {\n\t    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n\t      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n\t    }\n\t    self.body = (typeof form === 'string')\n\t      ? self._qs.rfc3986(form.toString('utf8'))\n\t      : self._qs.stringify(form).toString('utf8')\n\t    return self\n\t  }\n\t  // create form-data object\n\t  self._form = new FormData()\n\t  self._form.on('error', function (err) {\n\t    err.message = 'form-data: ' + err.message\n\t    self.emit('error', err)\n\t    self.abort()\n\t  })\n\t  return self._form\n\t}\n\tRequest.prototype.multipart = function (multipart) {\n\t  var self = this\n\n\t  self._multipart.onRequest(multipart)\n\n\t  if (!self._multipart.chunked) {\n\t    self.body = self._multipart.body\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.json = function (val) {\n\t  var self = this\n\n\t  if (!self.hasHeader('accept')) {\n\t    self.setHeader('accept', 'application/json')\n\t  }\n\n\t  if (typeof self.jsonReplacer === 'function') {\n\t    self._jsonReplacer = self.jsonReplacer\n\t  }\n\n\t  self._json = true\n\t  if (typeof val === 'boolean') {\n\t    if (self.body !== undefined) {\n\t      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n\t        self.body = safeStringify(self.body, self._jsonReplacer)\n\t      } else {\n\t        self.body = self._qs.rfc3986(self.body)\n\t      }\n\t      if (!self.hasHeader('content-type')) {\n\t        self.setHeader('content-type', 'application/json')\n\t      }\n\t    }\n\t  } else {\n\t    self.body = safeStringify(val, self._jsonReplacer)\n\t    if (!self.hasHeader('content-type')) {\n\t      self.setHeader('content-type', 'application/json')\n\t    }\n\t  }\n\n\t  if (typeof self.jsonReviver === 'function') {\n\t    self._jsonReviver = self.jsonReviver\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.getHeader = function (name, headers) {\n\t  var self = this\n\t  var result, re, match\n\t  if (!headers) {\n\t    headers = self.headers\n\t  }\n\t  Object.keys(headers).forEach(function (key) {\n\t    if (key.length !== name.length) {\n\t      return\n\t    }\n\t    re = new RegExp(name, 'i')\n\t    match = key.match(re)\n\t    if (match) {\n\t      result = headers[key]\n\t    }\n\t  })\n\t  return result\n\t}\n\tRequest.prototype.enableUnixSocket = function () {\n\t  // Get the socket & request paths from the URL\n\t  var unixParts = this.uri.path.split(':')\n\t  var host = unixParts[0]\n\t  var path = unixParts[1]\n\t  // Apply unix properties to request\n\t  this.socketPath = host\n\t  this.uri.pathname = path\n\t  this.uri.path = path\n\t  this.uri.host = host\n\t  this.uri.hostname = host\n\t  this.uri.isUnix = true\n\t}\n\n\tRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n\t  var self = this\n\n\t  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n\t  return self\n\t}\n\tRequest.prototype.aws = function (opts, now) {\n\t  var self = this\n\n\t  if (!now) {\n\t    self._aws = opts\n\t    return self\n\t  }\n\n\t  if (opts.sign_version === 4 || opts.sign_version === '4') {\n\t    // use aws4\n\t    var options = {\n\t      host: self.uri.host,\n\t      path: self.uri.path,\n\t      method: self.method,\n\t      headers: self.headers,\n\t      body: self.body\n\t    }\n\t    if (opts.service) {\n\t      options.service = opts.service\n\t    }\n\t    var signRes = aws4.sign(options, {\n\t      accessKeyId: opts.key,\n\t      secretAccessKey: opts.secret,\n\t      sessionToken: opts.session\n\t    })\n\t    self.setHeader('authorization', signRes.headers.Authorization)\n\t    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n\t    if (signRes.headers['X-Amz-Security-Token']) {\n\t      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n\t    }\n\t  } else {\n\t    // default: use aws-sign2\n\t    var date = new Date()\n\t    self.setHeader('date', date.toUTCString())\n\t    var auth = {\n\t      key: opts.key,\n\t      secret: opts.secret,\n\t      verb: self.method.toUpperCase(),\n\t      date: date,\n\t      contentType: self.getHeader('content-type') || '',\n\t      md5: self.getHeader('content-md5') || '',\n\t      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n\t    }\n\t    var path = self.uri.path\n\t    if (opts.bucket && path) {\n\t      auth.resource = '/' + opts.bucket + path\n\t    } else if (opts.bucket && !path) {\n\t      auth.resource = '/' + opts.bucket\n\t    } else if (!opts.bucket && path) {\n\t      auth.resource = path\n\t    } else if (!opts.bucket && !path) {\n\t      auth.resource = '/'\n\t    }\n\t    auth.resource = aws2.canonicalizeResource(auth.resource)\n\t    self.setHeader('authorization', aws2.authorization(auth))\n\t  }\n\n\t  return self\n\t}\n\tRequest.prototype.httpSignature = function (opts) {\n\t  var self = this\n\t  httpSignature.signRequest({\n\t    getHeader: function (header) {\n\t      return self.getHeader(header, self.headers)\n\t    },\n\t    setHeader: function (header, value) {\n\t      self.setHeader(header, value)\n\t    },\n\t    method: self.method,\n\t    path: self.path\n\t  }, opts)\n\t  debug('httpSignature authorization', self.getHeader('authorization'))\n\n\t  return self\n\t}\n\tRequest.prototype.hawk = function (opts) {\n\t  var self = this\n\t  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n\t}\n\tRequest.prototype.oauth = function (_oauth) {\n\t  var self = this\n\n\t  self._oauth.onRequest(_oauth)\n\n\t  return self\n\t}\n\n\tRequest.prototype.jar = function (jar) {\n\t  var self = this\n\t  var cookies\n\n\t  if (self._redirect.redirectsFollowed === 0) {\n\t    self.originalCookieHeader = self.getHeader('cookie')\n\t  }\n\n\t  if (!jar) {\n\t    // disable cookies\n\t    cookies = false\n\t    self._disableCookies = true\n\t  } else {\n\t    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n\t    var urihref = self.uri.href\n\t    // fetch cookie in the Specified host\n\t    if (targetCookieJar) {\n\t      cookies = targetCookieJar.getCookieString(urihref)\n\t    }\n\t  }\n\n\t  // if need cookie and cookie is not empty\n\t  if (cookies && cookies.length) {\n\t    if (self.originalCookieHeader) {\n\t      // Don't overwrite existing Cookie header\n\t      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n\t    } else {\n\t      self.setHeader('cookie', cookies)\n\t    }\n\t  }\n\t  self._jar = jar\n\t  return self\n\t}\n\n\t// Stream API\n\tRequest.prototype.pipe = function (dest, opts) {\n\t  var self = this\n\n\t  if (self.response) {\n\t    if (self._destdata) {\n\t      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n\t    } else if (self._ended) {\n\t      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n\t    } else {\n\t      stream.Stream.prototype.pipe.call(self, dest, opts)\n\t      self.pipeDest(dest)\n\t      return dest\n\t    }\n\t  } else {\n\t    self.dests.push(dest)\n\t    stream.Stream.prototype.pipe.call(self, dest, opts)\n\t    return dest\n\t  }\n\t}\n\tRequest.prototype.write = function () {\n\t  var self = this\n\t  if (self._aborted) { return }\n\n\t  if (!self._started) {\n\t    self.start()\n\t  }\n\t  if (self.req) {\n\t    return self.req.write.apply(self.req, arguments)\n\t  }\n\t}\n\tRequest.prototype.end = function (chunk) {\n\t  var self = this\n\t  if (self._aborted) { return }\n\n\t  if (chunk) {\n\t    self.write(chunk)\n\t  }\n\t  if (!self._started) {\n\t    self.start()\n\t  }\n\t  if (self.req) {\n\t    self.req.end()\n\t  }\n\t}\n\tRequest.prototype.pause = function () {\n\t  var self = this\n\t  if (!self.responseContent) {\n\t    self._paused = true\n\t  } else {\n\t    self.responseContent.pause.apply(self.responseContent, arguments)\n\t  }\n\t}\n\tRequest.prototype.resume = function () {\n\t  var self = this\n\t  if (!self.responseContent) {\n\t    self._paused = false\n\t  } else {\n\t    self.responseContent.resume.apply(self.responseContent, arguments)\n\t  }\n\t}\n\tRequest.prototype.destroy = function () {\n\t  var self = this\n\t  this.clearTimeout()\n\t  if (!self._ended) {\n\t    self.end()\n\t  } else if (self.response) {\n\t    self.response.destroy()\n\t  }\n\t}\n\n\tRequest.prototype.clearTimeout = function () {\n\t  if (this.timeoutTimer) {\n\t    clearTimeout(this.timeoutTimer)\n\t    this.timeoutTimer = null\n\t  }\n\t}\n\n\tRequest.defaultProxyHeaderWhiteList =\n\t  Tunnel.defaultProxyHeaderWhiteList.slice()\n\n\tRequest.defaultProxyHeaderExclusiveList =\n\t  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n\t// Exports\n\n\tRequest.prototype.toJSON = requestToJSON\n\trequest = Request\n\treturn request;\n}\n\nexport { requireRequest as __require };","start":1667202708036,"end":1667202708054,"order":"normal"}]}
